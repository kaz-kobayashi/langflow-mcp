"""基本分析モジュール abc とサプライ・チェイン基本分析システム SCBAS (Supply Chain Basic Analytics System)"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01abc.ipynb.

# %% auto 0
__all__ = ['folder', 'mapbox_access_token', 'demand_tree_map', 'abc_analysis', 'abc_analysis_all', 'add_abc',
           'demand_tree_map_with_abc', 'generate_figures_for_abc_analysis', 'rank_analysis',
           'rank_analysis_all_periods', 'show_rank_analysis', 'risk_pooling_analysis', 'show_inventory_reduction',
           'show_mean_cv', 'inventory_analysis', 'inventory_simulation', 'show_prod_inv_demand', 'plot_demands',
           'Scbas']

# %% ../nbs/01abc.ipynb 2
#data generation moduleのインポート
import sys
sys.path.append('..')
from .data import *

import colorlover as cl
from geopy.distance import great_circle as distance
import pickle
import numpy as np
import plotly.graph_objs as go
import plotly.express as px
import plotly

import pandas as pd
import random
import string
import datetime
import math
from collections import OrderedDict, defaultdict
import networkx as nx

from typing import List, Optional, Union, Tuple, Dict, Set, Any, DefaultDict
from pydantic import BaseModel, Field, ValidationError, validator, confloat, conint, constr, Json, ConfigDict
from pydantic.tools import parse_obj_as

folder = "./data/"
mapbox_access_token = 'pk.eyJ1IjoibWlraW9rdWJvIiwiYSI6ImNqYXQ3dHBqdzR5ZGwyd3BkeG5rOTl0b2UifQ.1utsXNi2V-WdzfWlvCMj_A'

# %% ../nbs/01abc.ipynb 13
def demand_tree_map(demand_df: pd.DataFrame, 
                    parent: str = "cust",
                    value: str  = "demand") -> plotly.graph_objects.Figure:
    """
    需要と売り上げのtreemapを生成する関数
    """
    
    if "date" not in demand_df.columns:
        demand_df.reset_index(inplace=True)
    demand_df["date"] = pd.to_datetime(demand_df.date)
    demand_df.set_index("date", inplace=True)

    #periods = max( (demand_df.index.max() - demand_df.index.min()).days, 1) #計画期間

    total_demand_df=pd.pivot_table(
            demand_df, index = ["prod","cust"], values = value, aggfunc = "sum")
    total_demand_df.reset_index(inplace=True)
    
    # treemap: pathで入れ子にする順番を決める（最初が親）；
    if parent =="cust":
        fig = px.treemap(total_demand_df, path=['cust','prod'], values=value, color_continuous_scale='RdBu')
    else:
        fig = px.treemap(total_demand_df, path=['prod','cust'], values=value, color_continuous_scale='RdBu')
        
    return fig

# %% ../nbs/01abc.ipynb 19
def abc_analysis(demand_df: pd.DataFrame, 
                 threshold: List[float], 
                 agg_col: str = "prod", 
                 value: str ="demand",
                 abc_name: str ="abc",
                 rank_name: str ="rank"
                ) -> Tuple[ pd.DataFrame, pd.DataFrame, Dict[int, List[str]] ] :
    """
    ABC分析のための関数
    """
    assert(sum(threshold) >=0.99)
    threshold = np.array(threshold)
    # print(threshold)
    theta = threshold.cumsum()  # ABC分析の閾値(累積量が閾値を超えるまでABCに分類）
    df = demand_df.copy()
    
    #ランク（大きいほど高い）
    temp_series = df.groupby([agg_col])[value].sum()
    sorted_series = temp_series.sort_values(ascending=False)

    # ABC分析のための準備：
    ind = []  # 値を降順に並べたときの名のリスト
    dem = []  # 値の降順に並べたときの量
    for i in sorted_series.index:
        ind.append(str(i))
        dem.append(sorted_series[i])

    # 0,1,2 ...を　A,B,C ... に変換するための辞書 map_ を準備
    alphabet = string.ascii_uppercase
    map_ = {}
    for i, a in enumerate(alphabet):
        map_[i] = a

    cum = 0
    count = 0
    total = sorted_series.sum()
    category = {i: [] for i in range(len(threshold))}
    rank = np.zeros(len(ind), dtype=np.int32)
    abc = np.zeros(len(ind), dtype=str)
    idx_ub = []
    for i in range(len(ind)):
        abc[i] = map_[count]
        cum += dem[i]
        category[count].append(ind[i])
        if cum > total * theta[count] and count<len(theta)-1:
            idx_ub.append(i)
            count += 1
        rank[i] = i

    idx_ub.append(len(ind))
    # print(category[0])       # 0がA, 1がB， 2がC

    agg_df = pd.DataFrame(sorted_series)
    agg_df["rank"] = rank
    agg_df["abc"] = abc

    abc = agg_df.to_dict()["abc"]
    rank = agg_df.to_dict()["rank"]
    name_list = list(df[agg_col])
    abc_column = []
    rank_column = []
    for name in name_list:
        abc_column.append(abc[name])
        rank_column.append(rank[name])
    df[abc_name] = abc_column
    df[rank_name] = rank_column

    return agg_df, df, category

# %% ../nbs/01abc.ipynb 21
def abc_analysis_all(deamnd_df: pd.DataFrame,
                     threshold: List[float]
                    ) -> Tuple[ pd.DataFrame, Dict[int, List[str]] ]:
    assert(sum(threshold) >=0.99)
    threshold = np.array(threshold)
    theta = threshold.cumsum()  # ABC分析の閾値(累積量が閾値を超えるまでABCに分類）
    temp_series = pd.pivot_table(demand_df, values="demand", index=["cust","prod"],aggfunc= ["sum","std"] )
    sorted_series = temp_series.sort_values(by=('sum', 'demand'),ascending=False)
    # ABC分析のための準備：
    ind = []  # 値を降順に並べたときの名のリスト
    dem = []  # 値の降順に並べたときの量
    for i,j in sorted_series.index:
        ind.append((str(i),str(j))) 
        dem.append(sorted_series.loc[(i,j),('sum', 'demand')])
    # 0,1,2 ...を　A,B,C ... に変換するための辞書 map_ を準備
    alphabet = string.ascii_uppercase
    map_ = {}
    for i, a in enumerate(alphabet):
        map_[i] = a

    cum = 0
    count = 0
    total = sorted_series[('sum', 'demand')].sum()
    category = {i: [] for i in range(len(threshold))}
    rank = np.zeros(len(ind), dtype=np.int32)
    abc = np.zeros(len(ind), dtype=str)
    idx_ub = []
    for i in range(len(ind)):
        abc[i] = map_[count]
        cum += dem[i]
        category[count].append(ind[i])
        if cum > total * theta[count] and count<len(theta)-1:
            idx_ub.append(i)
            count += 1
        rank[i] = i

    idx_ub.append(len(ind))
    # print(category[0])       # 0がA, 1がB， 2がC

    agg_df = pd.DataFrame(sorted_series)
    agg_df["rank"] = rank
    agg_df["abc"] = abc
    agg_df.columns = agg_df.columns.get_level_values(0) #列の階層をフラットにする．

    return agg_df, category

# %% ../nbs/01abc.ipynb 30
def add_abc(df: pd.DataFrame, 
            agg_df: pd.DataFrame, 
            col_name: str ="prod",
            value:str ="demand"
           ) -> pd.DataFrame:
    try:
        agg_df.reset_index(inplace=True)
    except:
        pass
    dic_ = {}
    for key, dem, rank, abc in zip(agg_df[col_name], agg_df[value], agg_df["rank"], agg_df["abc"]):
        dic_[ key ] = (dem, rank, abc)
    dem_list, rank_list, abc_list =[], [], [] 
    for row in df.itertuples():
        dem_list.append( dic_[row.name][0] )
        rank_list.append( dic_[row.name][1] )
        abc_list.append( dic_[row.name][2] )
    df[value] = dem_list
    df["rank"] = rank_list
    df["abc"] = abc_list
    return df

# %% ../nbs/01abc.ipynb 34
def demand_tree_map_with_abc(demand_df: pd.DataFrame, abc_col: str) ->plotly.graph_objects.Figure:
    """
    ABC別に色分けした需要のtreemapを生成する関数
    """
    if "date" not in demand_df.columns:
        demand_df.reset_index(inplace=True)
    demand_df["date"] = pd.to_datetime(demand_df.date)
    demand_df.set_index("date", inplace=True)

    #periods = max( (demand_df.index.max() - demand_df.index.min()).days, 1) #計画期間

    total_demand_df=pd.pivot_table(
            demand_df, index = ["prod","cust",abc_col], values = "demand", aggfunc = "sum")
    total_demand_df.reset_index(inplace=True)
    # Treemap: pathで入れ子にする順番を決める（最初が親）；
    fig = px.treemap(total_demand_df, path=['cust','prod'], values='demand', color=abc_col,
                    color_continuous_scale='RdYlBu')
    return fig

# %% ../nbs/01abc.ipynb 39
def generate_figures_for_abc_analysis(demand_df: pd.DataFrame,
                                      value: str = "demand",
                                      cumsum: bool =True, 
                                      cust_thres: str = "0.7, 0.2, 0.1",
                                      prod_thres: str = "0.7, 0.2, 0.1"
                                     ) -> Tuple[plotly.graph_objects.Figure,plotly.graph_objects.Figure,
                                                pd.DataFrame,pd.DataFrame,pd.DataFrame] :
    # 閾値の計算
    cust_threshold = [float(i) for i in cust_thres.split(",")]
    prod_threshold = [float(i) for i in prod_thres.split(",")]

    # ABC分析
    agg_df_prod, new_df, category_prod = abc_analysis(
        demand_df, prod_threshold, 'prod', value, "prod_ABC", "prod_rank")
    agg_df_cust, new_df, category_cust = abc_analysis(
        demand_df, cust_threshold, 'cust', value, "customer_ABC", "customer_rank")

    # 製品ABC分析のヒストグラムの生成
    if cumsum:
        agg_df_prod["cumsum_prod"] = agg_df_prod[value].cumsum()

    scales = cl.scales[str(len(category_prod))]['div']['RdYlBu']
    color_list = []
    for i in range(len(category_prod)):
        color_list.extend([scales[i]]*len(category_prod[i]))
    if cumsum:
        y_ = agg_df_prod["cumsum_prod"]/agg_df_prod["cumsum_prod"][-1]
    else:
        y_ = agg_df_prod[value]
    trace = go.Bar(
        x = agg_df_prod.index,
        y = y_,
        text = agg_df_prod.index,
        marker = dict(
            color=color_list
        )
    )
    data = [trace]
    if cumsum:
        layout = go.Layout(
            xaxis=dict(tickangle=-45),
            yaxis_tickformat = '%'
        )
    else:
        layout = go.Layout(
            xaxis=dict(tickangle=-45)
        )
        
    fig_prod = go.Figure(data=data, layout=layout)

    # 累積和の計算
    if cumsum:
        agg_df_cust["cumsum_cust"] = agg_df_cust[value].cumsum()
    
    # 顧客ABC分析のヒストグラムの生成
    scales = cl.scales[str(len(category_cust))]['div']['RdYlBu']
    color_list = []
    for i in range(len(category_cust)):
        color_list.extend([scales[i]]*len(category_cust[i]))
    if cumsum:
        y_ = agg_df_cust["cumsum_cust"]/agg_df_cust["cumsum_cust"][-1]
    else:
        y_ = agg_df_cust[value]

    trace = go.Bar(
        x = agg_df_cust.index,
        y = y_,
        #text = agg_df_cust.index,
        marker = dict(
            color = color_list
        )
    )
    data = [trace]
    if cumsum:
        layout = go.Layout(
            xaxis=dict(tickangle=-45),
            yaxis_tickformat = '%'
        )
    else:
        layout = go.Layout(
            xaxis=dict(tickangle=-45)
        )
    fig_cust = go.Figure(data=data, layout=layout)
        
    return fig_prod, fig_cust, agg_df_prod, agg_df_cust, new_df, category_prod, category_cust

# %% ../nbs/01abc.ipynb 47
def rank_analysis(df: pd.DataFrame, 
                  agg_col: str, 
                  value: str
                 ) -> Dict[int,int]:
    """
    全期間分のランク分析のための関数
    """
    temp_series = df.groupby([agg_col])[ value ].sum()
    sorted_series = temp_series.sort_values(ascending=False)
    rank = { } # ランクを格納する辞書
    count = 0
    for i in sorted_series.index:
        count += 1
        rank[i] = count
    return rank

# %% ../nbs/01abc.ipynb 48
def rank_analysis_all_periods(df: pd.DataFrame, 
                              agg_col: str, 
                              value: str,
                              agg_period: str
                             ) -> Dict[str, List[int] ]:
    """
    期別のランク分析のための関数
    """
    try:
        df.reset_index(inplace=True)
    except:
        pass
    agg_set = set(df[agg_col].unique())  # 集約する対象の集合
    rank = {}  # 対象の期ごとのランクのリストを保持する辞書
    for i in agg_set:
        rank[i] = []
    df["date"] = pd.to_datetime(df["date"])
    df.set_index("date", inplace=True)
    start_date = pd.to_datetime( min(df.index ))
    end_date = pd.to_datetime( max(df.index))
    for t in pd.date_range(start_date, end_date, freq=agg_period):
        selected_df = df[(df.index >= start_date ) & (df.index <= t)]  #ｓｔｒとdatetimeの比較！
        rank_in_period = rank_analysis(selected_df, agg_col, value)
        for i in rank:
            if i in rank_in_period:
                rank[i].append(rank_in_period[i])
            else:
                rank[i].append(np.nan)
        start_date = t
    df.reset_index(inplace=True)
    return rank

# %% ../nbs/01abc.ipynb 53
def show_rank_analysis(demand_df: pd.DataFrame,
                       agg_df_prod: pd.DataFrame = None, 
                       value: str ="demand", 
                       agg_period: str ="1m",
                       top_rank: int = 1
                      ) -> plotly.graph_objects.Figure:
    """
    ランク分析の可視化関数
    """
    try:
        demand_df.reset_index(inplace=True)
    except:
        pass
    agg_col = "prod"
    rank = rank_analysis_all_periods(
        demand_df, agg_col, value, agg_period)

    demand_df.set_index("date", inplace=True)
    x_range = [t for t in pd.date_range(
        min(demand_df.index), max(demand_df.index), freq=agg_period)]
    
    # 全期間での順位を得る
    if agg_df_prod is None:
        agg_df_prod, new_df, category_prod = abc_analysis(
            demand_df, [0.7,0.2,0.1] , agg_col, value, "ABC name", "Rank name")

    data = []
    for i in agg_df_prod.index[:int(top_rank)]:  # 全期間での順位の順に表示
        trace = go.Scatter(
            x= x_range,
            y= rank[i],
            mode='markers + lines',
            name=i,
            marker=dict(size=8,
                        #line= dict(width=1),
                        # color= "black",
                        opacity=0.3
                        ),
        )
        data.append(trace)

    layout = go.Layout(
        title="製品のランクの推移",
        xaxis=dict(
            tickangle=-45,
            title='期'
        ),
        yaxis=dict(
            title='ランク'
        )
    )
    return go.Figure(data=data, layout=layout)

# %% ../nbs/01abc.ipynb 58
def risk_pooling_analysis(demand_df: pd.DataFrame, 
                          agg_period="1w"
                         ) -> pd.DataFrame:
    """
    リスク共同管理の効果を見るための関数

    在庫を顧客側においた場合と、倉庫側においた場合の差を、標準偏差を計算することによって推定する。

    """
    try:
        demand_df.reset_index(inplace=True)
    except:
        pass

    demand_df["date"] = pd.to_datetime(demand_df.date)
    demand_df.set_index("date", inplace=True)

    attr =["prod","agg_std","sum_std","reduction","rank"]
    dic = {i: [] for i in attr}

    rank_dic = rank_analysis(demand_df, 'prod', 'demand')

    for p in set(demand_df["prod"]):
        dem_for_prod = demand_df[demand_df["prod"] == p]
        dem = dem_for_prod.groupby(["cust"]).resample(
            agg_period)["demand"].sum()
        alldem = dem_for_prod.resample(agg_period)["demand"].sum()
        agg_std = alldem.std()
        s = 0.
        for c in set(demand_df.cust):
            if c in dem:
                d = dem[c]
                std = d.std()
                if math.isnan(std):
                    pass
                else:
                    s += d.std()
        # print(p, agg_std, std, agg_std/std) #標準偏差の比率
        # print(p,s - agg_std)  #削減可能な在庫量 （ * z sqrt{LT (week)})
        dic["prod"].append(p)
        dic["agg_std"].append(agg_std)
        dic["sum_std"].append(s)
        dic["reduction"].append(s - agg_std)
        #dic["reduction_ratio"].append( (s - agg_std)/(alldem.sum()+0.00001))
        dic["rank"].append( rank_dic[p] )
    inv_reduction_df = pd.DataFrame(dic, columns=attr)
    inv_reduction_df.set_index("rank",inplace=True)
    inv_reduction_df.sort_values("reduction", ascending=False, inplace=True)
    inv_reduction_df.reset_index(inplace=True)
    return inv_reduction_df

# %% ../nbs/01abc.ipynb 62
def show_inventory_reduction(inv_reduction_df: pd.DataFrame
                            ) -> plotly.graph_objects.Figure:
    """
    在庫削減量の可視化関数
    """
    try:
        inv_reduction_df.reset_index(inplace=True)
    except ValueError:
        pass
    fig = px.bar(inv_reduction_df,x="prod",y="reduction",color="rank")
    fig.update_layout(xaxis_tickangle=-45)
    return fig

# %% ../nbs/01abc.ipynb 66
def show_mean_cv(demand_df: pd.DataFrame, prod_df:Optional[pd.DataFrame] = None, show_name: bool =True
                ) -> plotly.graph_objects.Figure:
    try:
        demand_df["date"] = pd.to_datetime(demand_df["date"])
        demand_df.set_index("date", inplace=True)
    except:
        pass
        
    gdf = pd.pivot_table(demand_df, values="demand", index="prod", aggfunc=["sum", "std"])
    gdf = gdf.sort_values(by =('sum', 'demand'), ascending=False)
    gdf.reset_index(inplace=True)
    #gdf.columns =["id", "prod", "mean", "std", "CV"]
    gdf.columns =["prod","sum","std"]
    #gdf["変動係数"] =  np.log(gdf["std"]/(gdf["sum"]+0.0001)+0.0001)
    gdf["変動係数"] =  gdf["std"]/(gdf["sum"]+0.0001)

    if prod_df is not None and "cust_value" in prod_df.columns:
        prod_color ={}
        for row in prod_df.itertuples():
            prod_color[row.name] = row.cust_value 
        color = [ ]
        for row in gdf.itertuples():
            color.append( prod_color[row.prod] )
        gdf["price"] = color
        
    if show_name:
        if prod_df is not None and "cust_value" in prod_df.columns:
            fig = px.scatter(gdf, x="sum", y="変動係数", size="std", hover_name="prod", text="prod", color = "price")
        else:
            fig = px.scatter(gdf, x="sum", y="変動係数", size="std", hover_name="prod", text="prod")
    else:
        if prod_df is not None and "cust_value" in prod_df.columns:
            fig = px.scatter(gdf, x="sum", y="変動係数", hover_name="prod", color = "price" )
        else:
            fig = px.scatter(gdf, x="sum", y="変動係数", hover_name="prod")
    return fig

# %% ../nbs/01abc.ipynb 71
def inventory_analysis(prod_df: pd.DataFrame,
                       demand_df: pd.DataFrame,
                       inv_reduction_df: pd.DataFrame,
                       z: float = 1.65,
                       LT: int = 1,
                       r: float = 0.3,
                       num_days: int = 7) ->pd.DataFrame:
    """
    工場における安全在庫量の計算

    工場を１箇所に集約したと仮定する。複数工場の場合には、顧客と工場の紐付け情報が必要になる。
    """
    try:
        demand_df.reset_index(inplace=True)
    except:
        pass
    try:
        prod_df.reset_index(inplace=True)
    except:
        pass
    new_prod_df = prod_df.copy()
    
    demand_df["date"] = pd.to_datetime(demand_df.date)
    demand_df.set_index("date", inplace=True)
    periods = max((demand_df.index.max() - demand_df.index.min()).days, 1)  # 計画期間（日）
    # 工場における製品の総需要量（週の平均）を追加
    average_demand_df = pd.pivot_table(
        demand_df, index="prod", values="demand", aggfunc="sum")*num_days/periods  # per week
    new_prod_df["average_demand"] = average_demand_df.values

    # 工場における製品需要の標準偏差（週あたり）を追加
    inv_reduction_df.reset_index(inplace=True)
    inv_reduction_df.set_index("prod", inplace=True)
    inv_reduction_dic = inv_reduction_df.to_dict()
    agg_std_dic = inv_reduction_dic["agg_std"]
    col = []
    for row in new_prod_df.itertuples():
        col.append(agg_std_dic[row.name])
    new_prod_df["standard_deviation"] = col

    new_prod_df["inv_cost"] = r * new_prod_df.plnt_value /365.*7.  # inventory cost (per week)
    new_prod_df["lot_size"] = np.sqrt(
        2 * new_prod_df.fixed_cost*new_prod_df.average_demand/new_prod_df.inv_cost)
    new_prod_df["safety_inventory"] = z*math.sqrt(LT)*new_prod_df.standard_deviation
    new_prod_df["target_inventory"] = new_prod_df.safety_inventory + LT*new_prod_df.average_demand #基在庫レベル
    new_prod_df["initial_inventory"] = new_prod_df.safety_inventory + new_prod_df.target_inventory//2
    new_prod_df.set_index("index", inplace=True)
    return new_prod_df

# %% ../nbs/01abc.ipynb 75
def inventory_simulation(prod_df: pd.DataFrame,
                         demand_df: pd.DataFrame
                        ) -> dict[str,pd.DataFrame]:
    """
    (Q,R)方策のシミュレーション
    """
    agg_period ="1d"
    LT = 1
    demand_df.reset_index(inplace=True)
    demand_df["date"] = pd.to_datetime(demand_df.date)
    demand_df.set_index("date", inplace=True)
    production_df = {}
    for row in prod_df.itertuples():
        p = row.name
        dem_for_prod = demand_df[demand_df["prod"] == p]
        dem = dem_for_prod.resample(agg_period)["demand"].sum()
        I = row.initial_inventory
        dic = OrderedDict()
        Prod = defaultdict(int) #initialized to 0
        for t, date in enumerate(dem.index):
            I = I - dem[date] + Prod[t-LT]
            if I < row.safety_inventory:
                Prod[t] = row.target_inventory - I
            dic[date] =[dem[date], I, Prod[t]]
        production_df[p] = pd.DataFrame.from_dict(dic, orient='index', columns=["demand", "inventory", "production"])
    return production_df

# %% ../nbs/01abc.ipynb 79
def show_prod_inv_demand(prod_name: str, 
                         production_df: pd.DataFrame,
                         scale: str="1d"
                        ) -> pd.DataFrame:
    """
    生産、在庫、需要の可視化関数
    """
    p = prod_name
    scale = scale
    df = production_df[p]["production"].resample(scale).sum()

    data = []
    trace = go.Scatter(
              x = list(df.index.astype('str')),
              y = production_df[p]["production"].resample(scale).sum().values.cumsum(),
              line = dict(
                  width = 2),
              name = "生産"
    )
    data.append( trace )

    trace = go.Scatter(
           x = list(df.index.astype('str')),
           y = production_df[p]["demand"].resample(scale).sum().values.cumsum(),
           line = dict(
              color = "green",
              width = 3),
           name = "需要"
        )
    data.append( trace )

    trace = go.Scatter(
           x = list(df.index.astype('str')),
           y = production_df[p]["inventory"].resample(scale).sum().values,
           line = dict(
              color = "orange",
              width = 1),
           name = "在庫"
        )
    data.append( trace )

    layout = go.Layout(
          title="生産，在庫，需要の関係",
          xaxis=dict(
            title='期'
          ),
          yaxis=dict(
            title='(累積）量'
          ),
        )
    fig = go.Figure(data=data, layout=layout)
    return fig

# %% ../nbs/01abc.ipynb 84
def plot_demands(prod_cust_list: List[str], 
                 demand_df: pd.DataFrame,
                 agg_period: str="1d"
                        ) -> pd.DataFrame:
    """
    需要の可視化関数
    """
    try:
        demand_df.reset_index(inplace=True)
    except:
        pass
    idx = pd.date_range(start=demand_df.date.min(), end=demand_df.date.max(), freq=agg_period)
    demand_df["date"] = pd.to_datetime(demand_df["date"])
    demand_df.set_index("date", inplace=True)
    demand_grouped = demand_df.groupby(
        ["prod", "cust"]).resample(agg_period)["demand"].sum()
    
    data = []
    for pc in prod_cust_list:
        prod, cust = pc.split(",")
        series = demand_grouped[(prod, cust)]
    
        trace = go.Scatter(
               x = series.index.astype('str'),
               y = series.values,
               line = dict(
                  width = 1),
               name = f"{prod},{cust}"
            )
        data.append( trace )
    layout = go.Layout(
          title="需要",
          xaxis=dict(
            title='期'
          ),
          yaxis=dict(
            title='需要量'
          ),
        )
    fig = go.Figure(data=data, layout=layout)
    return fig

# %% ../nbs/01abc.ipynb 88
class Scbas(BaseModel):
    model_config = ConfigDict(arbitrary_types_allowed=True)
    # cust_df: Optional[pd.DataFrame] = None 
    # prod_df: Optional[pd.DataFrame] = None
    demand_df: pd.DataFrame
    
    agg_df_prod: Optional[pd.DataFrame] = None
    agg_df_cust: Optional[pd.DataFrame] = None
    new_demand_df: Optional[pd.DataFrame] = None
    reduction_df: Optional[pd.DataFrame] = None
    new_prod_df: Optional[pd.DataFrame] = None

    category_prod: Optional[Dict[int,List[str]]] = None 
    category_cust: Optional[Dict[int,List[str]]] = None 
    nodes: Optional[List[Dict]] = None
    
    agg_period: str ="1w",

    def demand_tree_map(self, 
                    parent: str = "cust",
                    value: str  = "demand") -> plotly.graph_objects.Figure:
        return demand_tree_map(self.demand_df, parent = parent, value = value)

    def generate_figures_for_abc_analysis(self, 
                                      value: str = "demand",
                                      cumsum: bool =True, 
                                      cust_thres: str = "0.7, 0.2, 0.1",
                                      prod_thres: str = "0.7, 0.2, 0.1"
                                     ) -> Tuple[plotly.graph_objects.Figure,plotly.graph_objects.Figure,
                                                pd.DataFrame,pd.DataFrame,pd.DataFrame] :
        fig_prod, fig_cust, agg_df_prod, agg_df_cust, new_df, self.category_prod, self.category_cust = generate_figures_for_abc_analysis(self.demand_df, value, cumsum, cust_thres, prod_thres)
        self.agg_df_prod, self.agg_df_cust, self.new_demand_df = agg_df_prod, agg_df_cust, new_df
        self.prepare_nodes()
        return fig_prod, fig_cust, agg_df_prod, agg_df_cust, new_df, self.category_prod, self.category_cust

    def prepare_nodes(self) -> None:
        #prepare nodes for tree lists
        nodes = []
        # 0,1,2 ...を　A,B,C ... に変換するための辞書 map_ を準備
        alphabet = string.ascii_uppercase
        map_ = {}
        for i, a in enumerate(alphabet):
            map_[i] = a
        
        for i, prods_in_rank in self.category_prod.items():
            nodes.append( {"label": f"{map_[i]} rank", 
                           "value": f"RANK[{map_[i]}]", 
                           "children": [ {"label": p, "value":f"{p}", "children": 
                                         [ {"label": f"{map_[j]} rank", 
                                           "value": f"RANK[{p},{map_[j]}]", 
                                           "children": [ {"label": c, "value":f"{p},{c}" } for c in custs_in_rank]
                                           }
                                            for j, custs_in_rank in self.category_cust.items()
                                         ]
                                         } for p in prods_in_rank]
                          }
                        )
        self.nodes = nodes
            
    def show_rank_analysis(self,
                               value: str ="demand", 
                               top_rank: int = 1
                      ) -> plotly.graph_objects.Figure:
        return show_rank_analysis(self.demand_df, self.agg_df_prod, value, self.agg_period, top_rank)

    def risk_pooling_analysis(self) -> pd.DataFrame:
        self.reduction_df = risk_pooling_analysis(self.demand_df, self.agg_period)
        return self.reduction_df 
    
    def show_mean_cv(self, prod_df: pd.DataFrame = None, 
                     show_name: bool =True
                ) -> plotly.graph_objects.Figure:
        return show_mean_cv(self.demand_df, prod_df, show_name)

    def inventory_analysis(self, prod_df: pd.DataFrame,
                       z: float = 1.65,
                       LT: int = 1,
                       r: float = 0.3,
                       num_days: int = 7) ->pd.DataFrame:
        if self.reduction_df is None: 
            self.reduction_df = self.risk_pooling_analysis()
        self.new_prod_df = inventory_analysis(prod_df, self.demand_df, self.reduction_df, z, LT, r, num_days)
        return self.new_prod_df 
