"""配送計画システム METRO とその使用法"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02metroVI.ipynb.

# %% auto 0
__all__ = ['host', 'folder', 'mapbox_access_token', 'MAX_UINT', 'MAX_INT', 'Entity', 'Job', 'ShipmentStep', 'Shipment', 'Break',
           'VehicleCosts', 'VEHICLE_STEP_TYPE', 'VehicleStep', 'Vehicle', 'Matrix', 'Model', 'optimize_vrp', 'Summary',
           'Violation', 'Route', 'Solution', 'make_solution', 'compute_distance_table_for_vrp', 'generate_node',
           'generate_node_normal', 'build_model_for_vrp', 'generate_vrp', 'SolutionPrinter', 'pricing', 'BeamNode',
           'pricing_bs', 'time_convert', 'gannt_for_vrp', 'make_tw_fig_for_vrp', 'add_route_for_vrp',
           'add_road_for_vrp', 'make_fig_for_vrp', 'make_detailed_route', 'make_job_excel', 'make_shipment_excel',
           'make_vehicle_excel', 'make_break_excel', 'create_excel_for_metro', 'read_dfs_from_excel',
           'read_time_from_excel', 'compute_table_sub', 'make_table_for_metro', 'make_time_fig_for_excel',
           'make_tw_fig_for_excel', 'analyze_load', 'show_load', 'create_dfs_from_excel', 'unassigned_for_excel',
           'write_result_excel']

# %% ../nbs/02metroVI.ipynb 3
import sys
sys.path.append('..')
from .core import *
from .mypulp import GRB, quicksum
from .mypulp import Model as PulpModel

from typing import List, Optional, Union, Tuple, Dict, Set, Any, DefaultDict, Sequence
from pydantic import BaseModel, Field, ValidationError, validator, confloat, conint, constr, Json
from pydantic.tools import parse_obj_as
from datetime import datetime, date, time
import networkx as nx
import copy
import pickle
from collections import defaultdict
import numpy

import glob
import sys
import os 
import re
import random
import requests
import matplotlib.pyplot as plt
import math
import pandas as pd
import datetime as dt
from collections import namedtuple, OrderedDict
import json
import plotly.figure_factory as ff
import plotly.express as px
import plotly
from plotly.graph_objs import *
import numpy as np
from IPython.display import Image
from pprint import pprint
import ast
import subprocess
import platform
import polyline #nbdevと相性が悪いので，pipで入れる．
from faker import Faker

from openpyxl import Workbook, load_workbook
from openpyxl.worksheet.table import Table, TableStyleInfo
from openpyxl.chart import ScatterChart, Reference, Series
from openpyxl.worksheet.datavalidation import DataValidation
from openpyxl.formatting.rule import ColorScaleRule, CellIsRule, FormulaRule
from openpyxl.styles import Color, PatternFill, Font, Border, Alignment
from openpyxl.styles.borders import Border, Side
from openpyxl.utils.dataframe import dataframe_to_rows
from openpyxl.comments import Comment

from pyvrp import Model as PyvrpModel #モデルは別名でインポート
from pyvrp import (
  GeneticAlgorithm,
  Population, 
  PenaltyManager,
  read,
  Solution, #これも別名にする必要がある！
  Route, 
  CostEvaluator,
  Client, 
  ProblemData, 
  VehicleType, 
  RandomNumberGenerator,
)

from pyvrp.plotting import (
    plot_coordinates,
    plot_instance,
    plot_result,
    plot_route_schedule,
    plot_time_windows,
    plot_demands,
    plot_solution
)
from pyvrp.stop import MaxIterations, MaxRuntime, NoImprovement

from pyvrp.crossover import selective_route_exchange as srex

from pyvrp.diversity import broken_pairs_distance

from pyvrp.search import (
    LocalSearch,
    NODE_OPERATORS,
    ROUTE_OPERATORS,
    compute_neighbours,
)

host = "test-osrm-intel.aq-cloud.com"
#host = "localhost"
folder = "./data/metroIV/"
mapbox_access_token = 'pk.eyJ1IjoibWlraW9rdWJvIiwiYSI6ImNqYXQ3dHBqdzR5ZGwyd3BkeG5rOTl0b2UifQ.1utsXNi2V-WdzfWlvCMj_A'

# %% ../nbs/02metroVI.ipynb 11
MAX_UINT = int(numpy.iinfo(numpy.uintp).max)
MAX_INT = int(numpy.iinfo(numpy.intp).max)

class Entity(BaseModel):
    def __str__(self) -> str:
        repr = {k: v for k, v in self.model_dump().items() if k in self.model_fields_set}
        return str(repr)
        
class Job(Entity):
    id: int
    location: Union[None, Sequence[float]] = None #経度・緯度 [lon, lat] を入れる場合
    location_index: Union[None, int] = None       #行列のインデックスを入れる場合
    setup: Optional[int] = 0
    service: Optional[int] = 0
    delivery: Optional[Sequence[int]] = [0]
    pickup: Optional[Sequence[int]]  = [0]
    skills: Optional[Set[int]] = None
    priority: Optional[int] = 0
    time_windows: Optional[Sequence[Tuple[int, int]]] = None
    description: Optional[str] = ""

# %% ../nbs/02metroVI.ipynb 17
class ShipmentStep(Entity):
    id: int
    location: Optional[ Tuple[float,float] ] = None
    location_index: Optional[ int ] = None
    setup: Optional[ int ] = 0
    service: Optional[ int ] = 0
    time_windows: Optional[ Sequence[Tuple[int, int]] ] = None
    description: Optional[ str ] = ""

class Shipment(Entity):
    pickup: ShipmentStep
    delivery: ShipmentStep
    amount: Optional[Sequence[int]] = [0]
    skills: Optional[Set[int]] = None
    priority: Optional[int] = 0

# %% ../nbs/02metroVI.ipynb 21
class Break(Entity):
    id: int
    time_windows: Optional[ Sequence[ Tuple[int, int] ] ]= []
    service: Optional[ int ] = 0
    description: Optional[ str ] = ""
    max_load: Optional[ Sequence[int] ] = None

# %% ../nbs/02metroVI.ipynb 26
class VehicleCosts(Entity):
    fixed: Optional[int] = 0
    per_hour: int = 3600
    per_km:Optional[int] = 0

class VEHICLE_STEP_TYPE(Entity):
    START: str = "start"
    END: str = "end"
    BREAK: str = "break"
    SINGLE: str = "single"
    PICKUP: str = "pickup"
    DELIVERY: str = "delivery"

class VehicleStep(Entity):
    step_type: VEHICLE_STEP_TYPE
    id: Optional[int] = None
    service_at: Optional[int] = None
    service_after: Optional[int] = None
    service_before: Optional[int] = None
    
class Vehicle(Entity):
    id: int
    start: Union[None, Sequence[float]] = None
    end: Union[None, Sequence[float]] = None
    start_index: Union[None, int] = None
    end_index: Union[None, int] = None
    profile: Optional[ str ] = "car"
    capacity: Optional[ Union[Sequence[int]] ] = None
    skills: Optional[Set[int]] = None
    time_window: Optional[Tuple[int, int]] = None
    breaks: Optional[Sequence[Break]] = None
    description: str = ""
    costs: VehicleCosts = VehicleCosts()
    speed_factor: Optional[ float ] = 1.0
    max_tasks: Optional[ int ]= None
    max_travel_time: Optional[int] = None
    steps: Sequence[VehicleStep] = None

# %% ../nbs/02metroVI.ipynb 29
class Matrix(Entity):
    durations: List[List] = None
    distances: List[List] = None
    costs: List[List] = None

# %% ../nbs/02metroVI.ipynb 31
class Model(Entity):
    jobs: Optional[Sequence[Job]]             = Field( description="ジョブたち", default=None )
    shipments: Optional[Sequence[Shipment]]   = Field( description="輸送たち", default=None )
    vehicles: Optional[Sequence[Vehicle]]     = Field( description="運搬車たち", default=None )
    matrices: Optional[Dict[str,Matrix]]      = Field( description="行列たち", default=None )

# %% ../nbs/02metroVI.ipynb 34
def optimize_vrp(model, matrix=False, threads = 4, explore = 5, cloud = False, osrm=False, host="localhost"):
    # 呼び出し方法
    #./metroVI  -g -i test1.json -o output1.json -a car:test-osrm-intel.aq-cloud.com
    
    if cloud:
        time_stamp= dt.datetime.now().timestamp()
    else:
        time_stamp = 1

    with open(f"test{time_stamp}.json", 'w') as f:
        f.write(model.model_dump_json(exclude_none=True))

    if cloud:
        import pathlib
        p = pathlib.Path(".") #現在のフォルダ
        script = p / "scripts/metroVI"
    else:
        script = "./metroVI"
    
    if platform.system() == "Windows":
        if matrix:
            cmd = f"metro-win -i test{time_stamp}.json -o output{time_stamp}.json"
        else:
            cmd = f"metro-win - g -i test{time_stamp}.json -o output{time_stamp}.json"
    elif platform.system() == "Darwin":
        if platform.processor()[0]=="i": #intel 
            if matrix:
                cmd = f"{script}-mac-intel -i test{time_stamp}.json -o output{time_stamp}.json"
            else:
                if osrm:
                    cmd = f"{script}-mac-intel -g -i test{time_stamp}.json -o output{time_stamp}.json -a car:{host}"
                else:
                    cmd = f"{script}-mac-intel -g -i test{time_stamp}.json -o output{time_stamp}.json"
        elif platform.processor()[0]=="a": #arm 
            if matrix:
                cmd = f"{script}-mac-sillicon -i test{time_stamp}.json -o output{time_stamp}.json"
            else:
                if osrm:
                    cmd = f"{script}-mac-sillicon -g -i test{time_stamp}.json -o output{time_stamp}.json -a car:{host}"
                else:
                    cmd = f"{script}-mac-sillicon -g -i test{time_stamp}.json -o output{time_stamp}.json"
        else:
            print(f"{platform.system()} and {platform.processor()} may not be supported.")
            return -1
                
    elif platform.system() == "Linux": #cloud=Trueを仮定
        if matrix:
            cmd = f"{script}-linux-intel -i test{time_stamp}.json -o output{time_stamp}.json"
        else:
            if osrm:
                cmd = f"{script}-linux-intel -g -i test{time_stamp}.json -o output{time_stamp}.json -a car:{host}"
            else:
                cmd = f"{script}-linux-intel -g -i test{time_stamp}.json -o output{time_stamp}.json"
    else:
        print(platform.system(), "may not be supported.")
        return -1

    cmd +=  " -t " + str(threads) + " -x " + str(explore)
    # -g,                              add detailed route geometry and indicators
    # -t THREADS (=4),                 number of threads to use
    # -x EXPLORE (=5),                 exploration level to use (0..5)
 
    try:
        print("Now solving ...")
        o = subprocess.run(cmd.split(), check=True, capture_output=True)
        #print(o.stdout)
        print("Done")
    except subprocess.CalledProcessError as e:
        #print('ERROR:',e.stderr) # ERROR
        return "", "", e.stderr

    example1_in = open(f'test{time_stamp}.json', 'r')
    input_dic = json.load(example1_in)

    example1_out = open(f'output{time_stamp}.json', 'r')
    output_dic = json.load(example1_out)
    try:
        error =  output_dic["error"]
    except:
        error = ""
    if cloud:
        os.remove( p / f'test{time_stamp}.json')
        os.remove( p / f'output{time_stamp}.json')

    return input_dic, output_dic, error  #errorを返す

# %% ../nbs/02metroVI.ipynb 37
class Summary(Entity):
    cost: int #	total cost for all routes
    routes: int #	number of routes in the solution
    unassigned: int #	number of tasks that could not be served
    setup: int #	total setup time for all routes
    service: int #	total service time for all routes
    duration: int 	#total travel time for all routes
    waiting_time: int	#total waiting time for all routes                                
    priority: int	#total priority sum for all assigned tasks
    violations: Optional[Sequence[str]]	#array of violation objects for all routes
#[amount]	total amount for all routes
    delivery: Optional[Sequence[int]]	#total delivery for all routes
    pickup:  Optional[Sequence[int]] 	#total pickup for all routes
    distance: Optional[int]	 =None           #total distance for all routes: provided when using the -g flag.

class Violation(Entity):
    cause: str  
    duration: Optional[int] =None
# "delay" if actual service start does not meet a task time window and is late on a time window end
# "lead_time" if actual service start does not meet a task time window and is early on a time window start
# "load" if the vehicle load goes over its capacity
# "max_tasks" if the vehicle has more tasks than its max_tasks value
# "skills" if the vehicle does not hold all required skills for a task
# "precedence" if a shipment precedence constraint is not met (pickup without matching delivery, delivery before/without matching pickup)
# "missing_break" if a vehicle break has been omitted in its custom route
# "max_travel_time" if the vehicle has more travel time than its max_travel_time value
# "max_load" if the load during a break exceed its max_load value

class Route(Entity):
    vehicle: int #	id of the vehicle assigned to this route
    steps: Optional[Sequence[Any]]	#array of step objects
    cost: int  #cost for this route
    setup: int #	total setup time for this route
    service: int #	total service time for this route
    duration: int #	total travel time for this route
    waiting_time: int #	total waiting time for this route
    priority: int #	total priority sum for tasks in this route
    violations: Optional[Sequence[Violation]]=None	#array of violation objects for this route
    #amount: Optional[Sequence[int]]	#total amount for jobs in this route
    delivery: Optional[Sequence[int]] =None	#total delivery for tasks in this route
    pickup: Optional[Sequence[int]] =None	 #total pickup for tasks in this route
    description: str =None #vehicle description, if provided in input
    geometry: Optional[str] = None #*	polyline encoded route geometry
    distance: Optional[int] = None #*

class Solution(Entity):
    code: int	#status code
    error: Optional[str] =None	  #error message (present iff code is different from 0)
    summary: Optional[Summary] =None #object summarizing solution indicators
    unassigned: Optional[Sequence[Any]]  =None	#array of objects describing unassigned tasks with their id, type, and if provided, description, location and location_index
    routes: Optional[Sequence[Route]] =None	#array of route objects

# %% ../nbs/02metroVI.ipynb 39
def make_solution(output_dic:dict) -> tuple:
    
    solution = Solution.model_validate(output_dic)
    sol_dict = solution.model_dump()
    summary_df = pd.DataFrame.from_dict(sol_dict["summary"], orient='index').T

    if len(sol_dict["routes"])>0:
        dfs = []
        for r in sol_dict["routes"]:
            df = pd.DataFrame.from_dict(r, orient='index').T
            df.drop("steps", axis=1, inplace=True)
            dfs.append(df)
        route_summary_df = pd.concat(dfs)
        route_summary_df.reset_index(inplace=True)
        route_summary_df.drop("index", axis=1, inplace=True)
    else:
        route_summary_df = None

    if len(sol_dict["unassigned"])>0:
        dfs = []
        for r in sol_dict["unassigned"]:
            df = pd.DataFrame.from_dict(r, orient='index').T
            dfs.append(df)
        unassigned_df = pd.concat(dfs)
        unassigned_df.reset_index(inplace=True)
        unassigned_df.drop("index", axis=1, inplace=True)
    else:
        unassigned_df = None

    route_df_dic = {}
    for r in sol_dict["routes"]:
        if len(sol_dict["routes"])>0:
            dfs= []
            for j in r["steps"]:
                df = pd.DataFrame.from_dict(j, orient='index').T
                dfs.append(df)
            route_df = pd.concat(dfs)
            route_df.reset_index(inplace=True)
            route_df.drop("index", axis=1, inplace=True)
            route_df_dic[ r["vehicle"] ] = route_df
    return summary_df, route_summary_df, unassigned_df, route_df_dic

# %% ../nbs/02metroVI.ipynb 43
def compute_distance_table_for_vrp(node_df, toll=True, host="localhost"):
    ROUTE =[]
    for row in node_df.itertuples():
        ROUTE.append( ast.literal_eval(row.location) )
    route_str =""
    for (i,j) in ROUTE[:]:
        route_str += str(i)+","+str(j)+";"
        
    if toll:
        response = requests.get(f'http://{host}:5000/table/v1/driving/'+route_str[:-1]+"?annotations=distance,duration")
    else:
        response = requests.get(f'http://{host}:5000/table/v1/driving/'+route_str[:-1]+"?annotations=distance,duration&exclude=toll")
    
    result = response.json()
    #print(result)
    try:
        durations = result["durations"]
        distances = result["distances"]
    except:
        raise ValueError 
    return  durations,  distances

# %% ../nbs/02metroVI.ipynb 51
def generate_node(n, random_seed=1, prefecture=None, matrix=False, host=host):
    """
    郵便番号データをもとに日本のノードデータをランダムに生成する関数
    """
    #data_generationで分割して保存した郵便番号データが保存されていると仮定
    input_prefix = "./data/output_chunk_"
    def combine_csv_files(input_prefix):
        # ファイル名パターンに基づいて分割されたCSVファイルのリストを取得
        file_list = glob.glob(input_prefix + "*.csv")
        # 分割されたCSVファイルを読み込んで結合
        combined_df = pd.concat([pd.read_csv(file) for file in file_list], ignore_index=True)
        return combined_df 
        
    df = combine_csv_files(input_prefix)
    Faker.seed(random_seed)
    np.random.seed(random_seed)
    random.seed(random_seed)
    fake = Faker("ja_JP")
    # select customers 
    if prefecture == None:
        # if n> len(df):
        #     print("number of customers is too large! It exceeds the number of zip points in Japan!")
        #     return -1
        # else:
        node_df = df.sample(n=n, random_state=random_seed, replace=True)
    else:
        node_df = df[df.name1 == prefecture]
        # if n> len(node_df):
        #     print("number of customers is too large! Change the prefecture or set to None!")
        #     return -1
        # else:
        node_df = node_df.sample(n=n, random_state=random_seed, replace=True)

    node_df.reset_index(inplace=True)
    node_df.drop("index", axis=1, inplace=True)
    
    fake_name = []
    fake_name_set = set([])
    for _ in range(len(node_df)):
        while 1:
            temp = fake.company() + f" 第 {random.randint(1,100)} 支店" 
            if temp not in fake_name_set:
                fake_name.append(temp)
                fake_name_set.add(temp)
                break
    
    node_df.rename(columns={"name1": "都道府県", "name2": "市区町村", "name3": "大字"}, inplace=True) 
    node_df["name"] = fake_name 
    
    node_df["location"] = "[" + node_df.longitude.astype(str)  + ","+ node_df.latitude.astype(str) +"]"

    if matrix:
        time_df = make_time_df_for_vrp(node_df, host=host)
    else:
        time_df = ""
    
    node_df = node_df.reindex(columns=["name","zip", "都道府県","市区町村","大字","location"])
        
    return node_df, time_df

# %% ../nbs/02metroVI.ipynb 56
def generate_node_normal(n, lat_center, lon_center, std= 0.1, country_code="ja_JP", random_seed=1, matrix=False):
    """
    ノードデータを正規分布にしたがってランダムに生成する関数
    """
    Faker.seed(random_seed)
    np.random.seed(random_seed)
    random.seed(random_seed)
    fake = Faker(country_code)
    
    lat_list = np.random.normal(lat_center,std,n)
    lon_list = np.random.normal(lon_center,std,n)
    fake_name = []
    for _ in range(n):
        fake_name.append(fake.company())

    node_df = pd.DataFrame({"name": fake_name, "longitude": lon_list, "latitude": lat_list})
    
    node_df["location"] = "[" + node_df.longitude.astype(str)  + ","+ node_df.latitude.astype(str) +"]"

    if matrix:
        durations,  distances, _ = compute_durations(node_df)
        time_df = make_time_df(node_df, durations, distances)
    else:
        time_df = ""
        
    node_df = node_df.reindex(columns=["name", "location"])
        
    return node_df, time_df

# %% ../nbs/02metroVI.ipynb 60
def build_model_for_vrp(job_df, shipment_df, vehicle_df, break_df, time_df = None, cost_per_hour=3600):
    
    vehicle_L, job_L, shipment_L = [], [], []
    
    if break_df is not None:
        break_L = [ ]
        for i, row in enumerate(break_df.itertuples()):
            break_L.append(  Break(id=i, time_windows= ast.literal_eval(row.time_windows),
                                   service=int(row.service), max_load= None)
                          )
    else:
        break_L = None

    #vehicle
    for i, row in enumerate(vehicle_df.itertuples()):
        temp = {"id":i, 
             "description": row.name, 
             "start": ast.literal_eval(row.start), 
             "start_index":  row.start_index,
             "end": ast.literal_eval(row.end), 
             "end_index":  row.end_index,
             "capacity":ast.literal_eval(row.capacity),
             "time_window":ast.literal_eval(row.time_window),
             "skills":ast.literal_eval(row.skills)}
        if break_L is not None:
             temp["breaks"] =  [ break_L[j] for j in ast.literal_eval(row.breaks)]
            
        if len(ast.literal_eval(row.start))==0:    
            del temp["start"]  #発地点なし             
        if len(ast.literal_eval(row.end))==0:
            del temp["end"]    #着地点なし
        if pd.isnull(row.start_index) or row.start_index==-1:
            del temp["start_index"] 
        if pd.isnull(row.end_index) or row.end_index==-1:
             del temp["end_index"]  
        vehicle_L.append( Vehicle(**temp, costs=VehicleCosts(per_hour=cost_per_hour)) )
        
    #shipment
    if shipment_df is not None:
        for i, row in enumerate(shipment_df.itertuples()):
            temp = {"amount": ast.literal_eval(row.amount),
                 "skills": ast.literal_eval(row.skills),
                 "priority": int(row.priority),
                 "pickup": {"id":len(job_df)+i, 
                            "service": int(row.pickup_service),
                            "location": ast.literal_eval(row.pickup_location),
                             "location_index": row.pickup_index,  
                            "time_windows": ast.literal_eval(row.pickup_time_windows)
                           }, 
                  "delivery": {"id": len(job_df)+len(shipment_df)+i, 
                            "service": int(row.delivery_service),
                            "location": ast.literal_eval(row.delivery_location),
                            "location_index": row.delivery_index,  
                            "time_windows": ast.literal_eval(row.delivery_time_windows)
                           }, 
                 }
            if pd.isnull(row.pickup_index) or row.pickup_index==-1 or pd.isnull(row.delivery_index) or row.delivery_index==-1:
                del temp["pickup"]["location_index"] 
                del temp["delivery"]["location_index"] 
                
            shipment_L.append( Shipment(**temp) )
    
    #job 
    if job_df is not None:
        for i, row in enumerate(job_df.itertuples()):
            temp = {"id":i, 
                 "description": str(row.name), 
                 "location": ast.literal_eval(row.location), 
                 "location_index": row.location_index,
                 "service": int(row.service),
                 "pickup":  ast.literal_eval(row.pickup),
                 "delivery":  ast.literal_eval(row.delivery),
                "time_windows":  ast.literal_eval(row.time_windows),
                "skills":ast.literal_eval(row.skills),
                "priority": int(row.priority)
                }
            if pd.isnull(row.location_index) or row.location_index==-1:
                del temp["location_index"] 
            job_L.append( Job(**temp) )

    if time_df is not None: #移動時間行列を準備
        #n = int(np.sqrt(len(time_df)))
        n = len(node_df)
        duration = np.full((n,n),100000) #移動時間の上限を10万秒に設定
        for (i,j,t) in zip( time_df["from_node"], time_df["to_node"], time_df["time"]):
            duration[i,j] = t
        L = duration.tolist()
        #model["matrix"] = L 
    else:
        L = None
        
    model = Model()
    model.vehicles=  vehicle_L
    model.jobs = job_L
    if L is not None:
        model.matrices = {"car": Matrix(durations=L)}

    model.shipments= shipment_L
    #model.model_dump_json(exclude_none=True)
    #model = {"vehicles": vehicle_L, "jobs": job_L, "shipments": shipment_L}


    return model

# %% ../nbs/02metroVI.ipynb 64
def generate_vrp(node_df, num_depots = 1, open_flag=False, num_jobs=10, num_shipments=0, num_time_windows =1, time_window_bounds =(0,36000), 
                 time_window_ratio =0.9, delivery_bounds =(0,0), pickup_bounds =(0,0), 
                 service_bounds=(0,0), amount_bounds =(0,0), priority_bounds = (0,100), load_factor = 0.9,
                 num_customers_per_route = 5, skill_flag =False, breaks = None):
    """
    郵便番号データをもとに配送計画問題のデータをランダムに生成する関数（ノード生成を分離）
    """
    n = num_jobs + num_shipments*2 + num_depots #number of points 
    assert n == len(node_df)

    #積み込み積み降ろし (shipment) データフレーム
    # num_job+i => num_jobs + num_shipments + i (i-th shipment) 
    pick_loc, del_loc = [],[]
    pick_name, del_name = [], [] 
    pick_index, del_index =[], []
    for i in range(num_shipments):
        pick_loc.append( node_df.loc[num_jobs+i,"location"] )
        del_loc.append( node_df.loc[num_jobs+num_shipments+i,"location"] )
        pick_name.append( node_df.loc[num_jobs+i,"name"] )
        del_name.append( node_df.loc[num_jobs+num_shipments+i,"name"] )
        pick_index.append(num_jobs+i)
        del_index.append(num_jobs+num_shipments+i)

    shipment_df = pd.DataFrame({"amount": np.random.randint(amount_bounds[0],amount_bounds[1]+1,num_shipments),
                                "pickup_point": pick_name, 
                                "pickup_location": pick_loc,
                                "pickup_index": pick_index, 
                                "pickup_service": np.random.randint(service_bounds[0],service_bounds[1]+1,num_shipments),
                                "delivery_point": del_name, 
                                 "delivery_location": del_loc,
                                 "delivery_index": del_index, 
                                "delivery_service": np.random.randint(service_bounds[0],service_bounds[1]+1,num_shipments)}) 
    shipment_df["amount"] = "[" + shipment_df["amount"].astype(str) +"]"
    
    width = (time_window_bounds[1]-time_window_bounds[0])//num_time_windows #１つの時間枠の設定範囲
    tw_width = int(time_window_ratio*width) #時間枠の幅
    
    pickup_time_windows =[] 
    delivery_time_windows =[] 
    for i in range(num_shipments):
        tw_list =[]
        for i in range(num_time_windows):
            st = np.random.randint(0, (width-tw_width)//2 +1 )
            tw_list.append( [width*i+st, width*i+st+tw_width ] )
        pickup_time_windows.append( str( tw_list ) )
        
        tw_list =[]
        for i in range(num_time_windows):
            st = np.random.randint((width-tw_width)//2, width-tw_width +1 )
            tw_list.append( [width*i+st, width*i+st+tw_width ] )
        delivery_time_windows.append( str( tw_list ) )
    shipment_df["delivery_time_windows"] = delivery_time_windows
    shipment_df["pickup_time_windows"] = pickup_time_windows
    
    skills = []
    for i in range(num_shipments):
        if skill_flag:
            if random.random()<0.5:
                skills.append("[0]")
            else:
                skills.append("[0,1]")
        else:
            skills.append("[0]")
            
    shipment_df["skills"] = skills
    shipment_df["priority"] = np.random.randint(priority_bounds[0],priority_bounds[1]+1,num_shipments)

    #ジョブ (job) データフレーム
    job_df = node_df.loc[:num_jobs-1, ["name", "location"] ]
    job_df["delivery"] = np.random.randint(delivery_bounds[0],delivery_bounds[1]+1,num_jobs) 
    job_df["delivery"] = "[" + job_df["delivery"].astype(str) +"]"
    job_df["pickup"] = np.random.randint(pickup_bounds[0],pickup_bounds[1]+1,num_jobs) 
    job_df["pickup"] = "[" + job_df["pickup"].astype(str) +"]"
    job_df["service"] = np.random.randint(service_bounds[0],service_bounds[1]+1,num_jobs) 
    job_df["location_index"] = [i for i in range(num_jobs)]

    time_windows =[] 
    for i in range(num_jobs):
        tw_list =[]
        for i in range(num_time_windows):
            st = np.random.randint(0, width-tw_width +1 )
            tw_list.append( [width*i+st, width*i+st+tw_width ] )
        time_windows.append( str( tw_list ) )
    job_df["time_windows"] = time_windows

    skills = []
    for i in range(num_jobs):
        if skill_flag:
            if random.random()<0.5:
                skills.append("[0]")
            else:
                skills.append("[0,1]")
        else:
            skills.append("[0]")
            
    job_df["skills"] = skills
    job_df["priority"] = np.random.randint(priority_bounds[0],priority_bounds[1]+1,num_jobs)
    
    # 運搬車 (vehicle) データフレーム      
    demand = pd.concat([job_df.pickup, job_df.delivery,shipment_df.amount],axis=0)
    demand = demand.apply(ast.literal_eval)
    total_load = sum(demand.sum())
    max_load = max(demand.sum())

    total_customers = num_jobs + num_shipments
    average_load = total_load / total_customers
    capacity = int(max(average_load * num_customers_per_route, max_load))
    n_vehicles = max( round(total_load/load_factor/capacity), 1 )

    vehicle_df = pd.DataFrame({"name": [ f"truck{str(i)}" for i in range(n_vehicles)] } )
    
    #複数デポの場合には順番に割り振る
    depots, depot_index = [],[]
    for i in range(n_vehicles):
        depot_id = num_jobs + num_shipments*2 + (i%num_depots)
        depots.append( node_df.iloc[depot_id].location )
        depot_index.append( depot_id )
    vehicle_df["start"] = depots
    vehicle_df["start_index"] = depot_index
    
    if open_flag == True: #オープンルートの場合
        vehicle_df["end"] = str([])
        vehicle_df["end_index"] = None
    else: 
        vehicle_df["end"] = depots
        vehicle_df["end_index"] = depot_index

    vehicle_df["capacity"] = "["+str(capacity)+"]"
    vehicle_df["time_window"] = str(list(time_window_bounds))

    skills = []
    for i in range(n_vehicles):
        if skill_flag:
            if random.random()<0.5:
                skills.append("[0]")
            else:
                skills.append("[0,1]")
        else:
            skills.append("[0]")
            
    vehicle_df["skills"] = skills 
    
    if pd.isnull(breaks):
        breaks = []
    vehicle_df["breaks"] = str(breaks)  # lunch and/or supper or empty
    
    shipment_df = shipment_df.reindex(columns=["amount", "pickup_point", "pickup_service", "pickup_time_windows","pickup_location","pickup_index",
                                       "delivery_point", "delivery_service", "delivery_time_windows","delivery_location","delivery_index",
                                       "skills","priority"])
    
    job_df = job_df.reindex(columns=["name","service", "pickup","delivery","time_windows","location","location_index","skills","priority"])
    
    return job_df, shipment_df, vehicle_df

# %% ../nbs/02metroVI.ipynb 72
from ortools.sat.python import cp_model

class SolutionPrinter(cp_model.CpSolverSolutionCallback):
    """得られた巡回路とその費用を保管する"""

    def __init__(self, variables: Dict, G: nx.DiGraph, prize: List, start_index: int,  limit: int):
        cp_model.CpSolverSolutionCallback.__init__(self)
        self.__variables = variables
        self.__solution_count = 0
        self.__solution_limit = limit
        self.__G = G
        self.__prize = prize
        self.__start_index = start_index

        self.costs = []
        self.tours = [] #見つかった解のリストを保管

    def on_solution_callback(self) -> None:
        self.__solution_count += 1

        dist = 0
        total_prize = 0
        next_node = {}
        for (i,j), v in self.__variables.items():
            if i==j and self.value(v)==0: #self loopでない場合には賞金を得る
                total_prize += self.__prize[i]
            if i != j and self.value(v)==1:
                next_node[i] = j
                dist += self.__G[i][j]["weight"]
        
        #print(self.__solution_count, ":", total_prize, dist, dist-total_prize)
   
        current = self.__start_index
        tour = [current]
        for i in range(len(self.__prize)):
            j = next_node[current]
            tour.append(j)
            current = j
            if current == self.__start_index:
                break
        self.costs.append(dist+G[tour[-1]][self.__start_index]["weight"])
        self.tours.append(tour)
        
        #print("tour=", tour)
        if self.__solution_count >= self.__solution_limit:
            print(f"Stop search after {self.__solution_limit} solutions")
            self.stop_search()

    def solution_count(self) -> int:
        return self.__solution_count
        
#TODO: 大きいときには疎なグラフを作って列挙

# %% ../nbs/02metroVI.ipynb 73
def pricing(dual: List, start_index:int, capacity:Optional[int], 
            max_duration:Optional[int], G: nx.DiGraph, limit:int = 100) -> SolutionPrinter:
    n = len(G)
    cpmodel = cp_model.CpModel()
    prize = dual #dual price （往復を仮定）
    x = {}
    for u, v in G.edges:
        x[u, v] = cpmodel.new_bool_var(f"x_{u}_{v}")
    
    circuit = [(u, v, x) for (u, v), x in x.items()]
    cpmodel.add_circuit(circuit)
    
    #MTZ constraints
    # p = {}
    # for i in range(n):
    #     p[i] = cpmodel.new_int_var(0, n, f"potential_{i}")
    # for v, w in G.edges:
    #     if v != w:
    #         if w != start_index:  # The depot node is special.
    #             cpmodel.add(p[v] + 1 == p[w]).OnlyEnforceIf(x[v, w])
    # cpmodel.add(p[start_index]==0)

    #capacity constraints
    if capacity is None:
        capacity = 1000000
    p_volume, d_volume = {}, {}
    delivery, pickup = {}, {}
    for v in G:
        if v != start_index:
            p_volume[v] = cpmodel.new_int_var(0, capacity, f"p_volume_{v}") #点v出発時の積み込み量
            d_volume[v] = cpmodel.new_int_var(0, capacity, f"d_volume_{v}") #点v到着時の配達量
    p_volume[start_index] = 0
    d_volume[start_index] = 0
    for v, w in G.edges:
        if v != w:
            if w != start_index:  # The depot node is special.
                cpmodel.add(p_volume[v] + G.nodes[w]["pickup"][0] == p_volume[w]).OnlyEnforceIf(x[v, w])
            if v != start_index:  # The depot node is special.
                cpmodel.add(d_volume[v] - G.nodes[v]["delivery"][0] == d_volume[w]).OnlyEnforceIf(x[v, w])
    for j in model.jobs:
        v = j.location_index
        cpmodel.add(p_volume[v]+d_volume[v]-G.nodes[v]["delivery"][0] <= capacity)
    #自由度を消す
    for j in model.jobs:
        v = j.location_index
        cpmodel.add(p_volume[v]==0).OnlyEnforceIf(x[v, v])
        cpmodel.add(d_volume[v]==0).OnlyEnforceIf(x[v, v])
        
    #時間枠（自由度がないように強制する）
    t = {}
    if max_duration is None:
        max_duration_ = 100000
    for v in G:
        if v != start_index:
            t[v] = cpmodel.new_int_var(0, max_duration_, f"time_{v}")
    t[start_index] = 0
    cpmodel.add(t[start_index]==0)
    for v, w in G.edges:
        if v != w:
            if w != start_index:  # The depot node is special.
                cpmodel.add(t[v] + G[v][w]["weight"] == t[w]).OnlyEnforceIf(x[v, w])
    for v in G:
        if v != start_index:
            for (earlt,late) in G.nodes[v]["time_windows"]:
                cpmodel.add(early <= t[v]).OnlyEnforceIf(~x[v, v])
                cpmodel.add(t[j.location_index] <= late).OnlyEnforceIf(~x[v, v])
            cpmodel.add(t[v]==0).OnlyEnforceIf(x[v, v])
        
    cpmodel.add(x[start_index,start_index]==0)
    if max_duration is not None:
        cpmodel.add(sum(G[u][v]["weight"]*x for (u, v), x in x.items() if u != v) <=max_duration)
    cpmodel.minimize(-sum(prize[i]*(1-x[i,i]) for i in range(n)) +
                     sum(G[u][v]["weight"]*x for (u, v), x in x.items() if u != v))
    cpmodel.add(-sum(prize[i]*(1-x[i,i]) for i in range(n)) +
                     sum(G[u][v]["weight"]*x for (u, v), x in x.items() if u != v)
               <= -1)
    
    solution_printer = SolutionPrinter(x, G, prize, start_index, limit)
    
    solver = cp_model.CpSolver()
    solver.parameters.num_search_workers = 8
    solver.parameters.max_time_in_seconds = 100
    solver.parameters.enumerate_all_solutions = False #True
    
    solver.parameters.log_search_progress =  False
    status = solver.Solve(cpmodel, solution_printer)

    return solution_printer

# %% ../nbs/02metroVI.ipynb 75
from heapq import heapify, heappush, heappop, nsmallest

class BeamNode(BaseModel):
    path_list: List[int] = []
    departure: int = 0
    duration: int = 0
    total_cost: int = 0
    # pickup: int = 0
    # delivery: int = 0
    residual: int      #容量の残差
    min_residual: int  #始点から現在の点までの容量残差の最小値
    
    def __lt__(self, other: "BeamNode"): 
        if self.total_cost == other.total_cost:
            return self.duration < other.duration
        else:
            return self.total_cost < other.total_cost

def pricing_bs(dual, start_index, capacity, max_duration, G, limit=1000, search_width = 20):
    root = BeamNode(path_list = [start_index],
                    residual = capacity,
                    min_residual = capacity
                   )
    if max_duration is None:
        max_duration = 1000000
            
    bests = [root] #最良解を保管するヒープ
    heapify(bests)
    num_of_bests = limit
    
    nodes = [root] 
    while True:
        top_nodes = []
        heapify(top_nodes)
        for node in nodes:
            i = node.path_list[-1]
            for j in G.successors(i):
                if j not in set(node.path_list):
                    
                    if node.duration + G[i][j]["weight"] + G[j][start_index]["weight"] > max_duration: #稼働時間上限
                        continue

                    arrival = node.departure + G[i][j]["weight"]
                    for (earlr, late) in G.nodes[j]["time_windows"]:
                        if arrival>= early and arrival <=late: 
                            departure = arrival + G.nodes[j]["service"]
                            break
                    else:
                        continue #時間枠逸脱
                    residual = node.residual - G.nodes[j]["pickup"][0] #容量の残差から積み込み量を減じる
                    min_residual = min( residual, node.min_residual- G.nodes[j]["delivery"][0])
                    if residual >=0 and min_residual>=0:
                        score = node.total_cost + G[i][j]["weight"] - G[i][start_index]["weight"] + G[j][start_index]["weight"] - dual[j]
                        
                        new_path_list = node.path_list.copy()
                        new_path_list.append(j)
                        new_node = BeamNode(path_list = new_path_list,
                                            departure = departure,
                                            duration = node.duration + G[i][j]["weight"], #サービス時間はいれない 
                                            total_cost = score,
                                            # pickup = node.pickup + G.nodes[j]["pickup"][0],
                                            # delivery = node.delivery + G.nodes[j]["delivery"][0],
                                            residual = residual, 
                                            min_residual = min_residual
                                           )
                        heappush(top_nodes, new_node)
         
        if len(top_nodes)==0:
            break
            
        top_nodes = nsmallest(search_width, top_nodes) 
    
        nodes = top_nodes
        for node in nodes:
            heappush(bests, node)
    
        bests = nsmallest(num_of_bests, bests)

    solution_printer = SolutionPrinter(None,None,None,_,_)
    for sol in bests:
        j = sol.path_list[-1]
        solution_printer.costs.append( sol.duration + G[j][start_index]["weight"]  )
        solution_printer.tours.append( sol.path_list + [start_index] )

    return solution_printer


# %% ../nbs/02metroVI.ipynb 94
def time_convert(sec, start):
    """
    時間変換のユーテリティ関数
    """
    try:
        start = pd.to_datetime(start)
    except:
        pass
    seconds = int(sec)
    try:
        finish = start + dt.timedelta(seconds=seconds)
        return finish.strftime("%Y-%m-%d %H:%M")
    except TypeError:
        finish = (dt.datetime.combine(dt.date(2000,1,1), start) + dt.timedelta(seconds=seconds))
        return finish.strftime("%H:%M")

# %% ../nbs/02metroVI.ipynb 98
def gannt_for_vrp(route_df_dic, start="2000/01/01 00:00:00"):
    """
    ルートのガントチャートを生成する関数
    """
    L = []
    for v, route in route_df_dic.items():
        for row in route.itertuples():
            arrival_time = time_convert(row.arrival, start) #到着時刻
            after_wait_time =time_convert(row.arrival+row.waiting_time, start) #待ち終了時刻
            departure_time = time_convert(row.arrival+row.waiting_time+row.service, start) #出発時刻
    
            ar = arrival_time
            after_wait = after_wait_time
            dp = departure_time
    
            if row.type == "start":
                prev_name = "Start"
            elif row.type == "end":
                move = dict(Task= "Move", Start= st, Finish= ar, Resource=f"Vehicle{v}", 
                            labels = prev_name + " => " + "end")
                L.append(move)
                break
            else:
                move = dict(Task= "Move", Start=st, Finish= ar, Resource=f"Vehicle{v}", 
                            labels = prev_name + f" => {row.id}"  ) 
                L.append(move)
    
                #待ち
                wait = dict(Task= "Wait", Start= ar, Finish=after_wait, Resource=f"Vehicle{v}",labels =row.id)
                L.append(wait)
                #サービス
                if row.type =="break":
                    serve = dict(Task="Break", Start=after_wait, Finish=dp, Resource=f"Vehicle{v}",labels = row.id)
                else:
                    serve = dict(Task= "Service", Start=after_wait, Finish=dp, Resource=f"Vehicle{v}",labels = row.id)
                L.append(serve)
                prev_name = f"{row.id}"
            st = departure_time #以前の出発時刻を保存
    
    df = pd.DataFrame( L ) 
    fig = px.timeline(df, x_start="Start", x_end="Finish", y="Resource", color="Task", hover_name ="labels",
                     color_discrete_sequence=["red",  "blue", "goldenrod", "green", "magenta"])

    #from plotly.figure_factory import create_gantt
    #https://plotly.github.io/plotly.py-docs/generated/plotly.figure_factory.create_gantt.html
    #fig = create_gantt(df, index_col ="Resource")
    
    return fig

# %% ../nbs/02metroVI.ipynb 102
def make_tw_fig_for_vrp(job_df, shipment_df, start="2000/01/01 00:00:00"):
    """
    時間枠を可視化する関数
    """
    L = []
    for row in job_df.itertuples():
        tw_list = ast.literal_eval(row.time_windows)
        for i,tw in enumerate(tw_list):
            L.append(dict(Task=f"time window {i}", Start=time_convert(tw[0],start), Finish=time_convert(tw[1],start), Resource=row.name))
    
    for row in shipment_df.itertuples():
        tw_list = ast.literal_eval(row.pickup_time_windows)  
        for i,tw in enumerate(tw_list):
            L.append(dict(Task=f"pickup time window {i}", Start=time_convert(tw[0],start), Finish=time_convert(tw[1],start), Resource= row.pickup_point))
        tw_list = ast.literal_eval(row.delivery_time_windows)  
        for i,tw in enumerate(tw_list):
            L.append(dict(Task=f"delivery time window {i}", Start=time_convert(tw[0],start), Finish=time_convert(tw[1],start), Resource= row.delivery_point))
    df = pd.DataFrame( L ) 
    fig = px.timeline(df, x_start="Start", x_end="Finish", y="Resource", color="Task")
    return fig

# %% ../nbs/02metroVI.ipynb 108
def add_route_for_vrp(output_dic, map_style=0):
   
    line_color =["yellow", "black", "white" ]
    data = [] 
    for r in output_dic["routes"]:
        edge_trace_x, edge_trace_y = [], []
        for i, s in enumerate(r["steps"]):
            try:
                lon,lat = s["location"]
            except:
                pass
            if i==0:
                lat0, lon0 = lat, lon
                continue

            edge_trace_x += [lat0, lat, None]
            edge_trace_y += [lon0, lon, None]
            lat0, lon0 = lat, lon

        data.append(
            Scattermapbox(  # edge
                lat=edge_trace_x,
                lon=edge_trace_y,
                line=dict(width=2, color=line_color[ map_style ]),
                hoverinfo='none',
                mode='lines',
                name="vehicle:"+str(r["vehicle"])
            ))   
    return data

# %% ../nbs/02metroVI.ipynb 110
def add_road_for_vrp(output_dic, map_style=0):
    
    line_color =["yellow", "black", "white" ]
    data =[] 
    for i,r in enumerate(output_dic["routes"]):
        try: #道路の描画
            route = polyline.decode(output_dic["routes"][i]["geometry"])
            edge_trace_x, edge_trace_y = [], []
            for i, (lat,lon) in enumerate(route):
                if i==0:
                    lat0, lon0 = lat, lon
                    continue

                edge_trace_x += [lat0, lat, None]
                edge_trace_y += [lon0, lon, None]
                lat0, lon0 = lat, lon
        except: #失敗した場合には直線で描画
            for i, s in enumerate(r["steps"]):
                try:
                    lon,lat = s["location"]
                except:
                    pass
                if i==0:
                    lat0, lon0 = lat, lon
                    continue

                edge_trace_x += [lat0, lat, None]
                edge_trace_y += [lon0, lon, None]
                lat0, lon0 = lat, lon

        data.append(
            Scattermapbox(  # edge
                lat=edge_trace_x,
                lon=edge_trace_y,
                line=dict(width=3, color=line_color[ map_style ]),
                hoverinfo='none',
                mode='lines',
                name="vehicle"+str(r["vehicle"])
            ))    
    return data

# %% ../nbs/02metroVI.ipynb 112
def make_fig_for_vrp(input_dic, output_dic, show_mode = "road", map_style=0):
    """
    図の表示
    """
    maps = ["satellite-streets" , "open-street-map", "dark"]
    
    #jobs 
    latitude, longitude, text = [], [], []
    max_demand = 0
    max_priority = 0
    for i,j in enumerate(input_dic["jobs"]):
        latitude.append( j["location"][1] )
        longitude.append( j["location"][0] )
        text.append(f"{i} : {j['description']}, pickup:delivery={j['pickup'][0]}:{j['delivery'][0]}, priority={j['priority']}")
        max_demand = max(max_demand, j["pickup"][0])
        max_demand = max(max_demand, j["delivery"][0])
        max_priority = max(max_priority, j["priority"])
    node_size =[]
    node_color =[]
    for j in input_dic["jobs"]:      
        node_size.append( 10*(j["pickup"][0]+j["delivery"][0])/(max_demand+1) + 5 )
        node_color.append( j["priority"]/(max_priority+1) )
        
    #vehicles
    latitude2, longitude2, text2 = [], [], []
    for j in input_dic["vehicles"]:
        if "start" in j:
            latitude2.append(j["start"][1])
            longitude2.append(j["start"][0])
            text2.append( f"{j['id']}:start")
        if "end" in j:
            latitude2.append(j["end"][1])
            longitude2.append(j["end"][0])
            text2.append( str(j["id"])+":end")
    
    #shipments
    latitude3, longitude3, text3 = [], [], []
    edge_trace_x, edge_trace_y = [], []
    if "shipments" in input_dic:
        for j in input_dic["shipments"]:
            latitude3.append( j['pickup']["location"][1] )
            longitude3.append( j['pickup']["location"][0] )
            text3.append(f"Pickup : amount={j['amount']}")
            
            latitude3.append( j['delivery']["location"][1] )
            longitude3.append( j['delivery']["location"][0] )
            text3.append(f"Delivery")
            
            edge_trace_x += [j['pickup']["location"][1], j['delivery']["location"][1], None]
            edge_trace_y += [j['pickup']["location"][0], j['delivery']["location"][0], None]
     
    data =[]
    #ルートデータ追加
    if show_mode == "road": #道路地図を描画
        data.extend( add_road_for_vrp(output_dic, map_style) )

    elif show_mode =="route": #ルートを直線で描画
        data.extend( add_route_for_vrp(output_dic, map_style) ) 
        
    data.extend([
        Scattermapbox(  # Jobs
            lat=latitude,
            lon=longitude,
            mode='markers',
            marker=dict(
                size=node_size, color=node_color, opacity=0.8
            ),
            #hoverinfo= "text",
            #hovertext=text,
            text = text, 
            name="Jobs"
        ),
        Scattermapbox(  # Vehicles
            lat=latitude2,
            lon=longitude2,
            mode='markers',
            marker=dict(
                size=20, color="blue", opacity=0.8
            ),
            #text=text2,
            name="Depot(s)"
        ),
        Scattermapbox(  # shipment arc 
            lat= edge_trace_x,
            lon= edge_trace_y,
            line=dict(width=5, color='orange'),
            hoverinfo='none',
            mode='lines',
            name="Shipment Arcs"
        ),
        Scattermapbox(  # shipment node
            lat=latitude3,
            lon=longitude3,
            mode='markers',
            marker=dict(
                size=30, color="red", opacity=0.8
            ),
            #hoverinfo= "text",
            #hovertext=text3,
            text = text3, 
            name="Shipments"
        ),
    ])
        
    layout = Layout(
        title ="点の大きさ：需要量  点の色：優先度 (Size:Demand Color:Priority)",
        showlegend=True,
        autosize=True,
        hovermode='closest',
        mapbox=dict(
            accesstoken=mapbox_access_token,
            bearing=0,
            center=dict(
                lat=latitude2[0],
                lon=longitude2[0]
            ),
            pitch=0,
            zoom=10,
            style= maps[ map_style ]
        ),
    )
    fig = Figure(data=data, layout=layout)
    # resize fig
    fig.update_layout(
        autosize=False,
        width=1000,
        height=1000,
        paper_bgcolor="LightSteelBlue",
    )
    return fig

# %% ../nbs/02metroVI.ipynb 117
def make_detailed_route(input_dic, output_dic, route_df_dic, route_id=0, matrix=False, 
                        map_style=0, straight = None, host="localhost"):
    """
    詳細ルートの図を描画する関数
    """
    ROUTE = []
    latitude, longitude = [], [] 
    for node in output_dic["routes"][route_id]["steps"]:
        #print(node["location"])
        if "location" in node: #最後がbreakでパス型だと位置がないため
            ROUTE.append( node["location"] )
            longitude.append(node["location"][0])
            latitude.append(node["location"][1])
            
    vid = output_dic["routes"][route_id]["vehicle"]
    vehicle = input_dic["vehicles"][vid]
    latitude2, longitude2, text2 = [], [], []
    if "start" in vehicle:
        latitude2.append(vehicle["start"][1])
        longitude2.append(vehicle["start"][0])
        text2.append( f"{vehicle['id']}:start")
        
    if "end" in vehicle:
        latitude2.append(vehicle["end"][1])
        longitude2.append(vehicle["end"][0])
        text2.append( str(vehicle["id"])+":end")

    if matrix == False: #詳細ルート準備
        
        if straight == True:
            straight_flag = "true"
        elif  straight == False:
            straight_flag = "false"
        elif pd.isnull(straight):
            straight_flag = "default"
        else:
            print("Unknown straight option")
            return -1,-1,-1

        route_str =""
        for (i,j) in ROUTE:
            route_str += str(i)+","+str(j)+";"
        try:
            #print(f'http://{host}:5000/route/v1/driving/'+route_str[:-1]+f"?annotations=distance,duration&overview=full&continue_straight={straight_flag}")
            response = requests.get(f'http://{host}:5000/route/v1/driving/'+route_str[:-1]+f"?annotations=distance,duration&overview=full&continue_straight={straight_flag}")
            result = response.json()
            route = polyline.decode(result["routes"][0]["geometry"])
        except:
            print("route draw error")
            matrix = True #失敗した場合には，直線で描画
    if matrix == True: 
        route = []
        for (lon,lat) in ROUTE:
            route.append( (lat,lon) )
        
    maps = ["satellite-streets" , "open-street-map", "dark"]
    line_color =["yellow", "black", "white" ]
    node_color =["blue", "red", "yellow" ]
    
    edge_trace_x, edge_trace_y = [], []
    for i, (lat,lon) in enumerate(route):
        if i==0:
            lat0, lon0 = lat, lon
            continue
        edge_trace_x += [lat0, lat, None]
        edge_trace_y += [lon0, lon, None]
        lat0, lon0 = lat, lon

    data=[   
        Scattermapbox(  # node
            lat=latitude,
            lon=longitude,
            mode='markers',
            marker=dict(
                size=30, color=node_color[map_style], opacity= 0.9 
            ),
            #hoverinfo= "text",
            #hovertext=text,
            #text = route_df_dic[route_id].name, 
            name="Nodes"
        ),
    ]
    data.append(
            Scattermapbox(  # Vehicles
            lat=latitude2,
            lon=longitude2,
            mode='markers',
            marker=dict(
                size=40, color="blue", opacity=0.8
            ),
            name="Depot(s)"
        ))
        
    data.append(
        Scattermapbox(  # edge
            lat=edge_trace_x,
            lon=edge_trace_y,
            line=dict(width=5, color=line_color[ map_style ]),
            hoverinfo='none',
            mode='lines'
        ))    
    layout = Layout(
        title ="ルート詳細 Datailed Route",
        showlegend=True,
        autosize=True,
        hovermode='closest',
        mapbox=dict(
            accesstoken=mapbox_access_token,
            bearing=0,
            center=dict(
                lat=latitude[0],
                lon=longitude[0]
            ),
            pitch=0,
            zoom=10,
            style= maps[ map_style ]
        ),
    )
    fig = Figure(data=data, layout=layout)
    # resize fig
    fig.update_layout(
        autosize=False,
        width=1000,
        height=1000,
        paper_bgcolor="LightSteelBlue",
    )
    return fig

# %% ../nbs/02metroVI.ipynb 130
def make_job_excel(wb, n_job=100, num_dim = 3, num_tw = 3, num_skill = 3, date_flag = True):
    #wb = Workbook()
    ws = wb.create_sheet(title="ジョブ")
    tw_list =[]
    for i in range(num_tw):
        tw_list.extend( [f"最早時刻{i+1}", f"最遅時刻{i+1}" ] )

    ws.append(["名称","作業時間（分）","経度（小数)","緯度(小数)"]+
              tw_list + 
              [f"積み込み量{i+1}" for i in range(num_dim)]+
              [f"積み降ろし量{i+1}" for i in range(num_dim)]+
              [f"スキル{i+1}（0か1)" for i in range(num_skill)]+["優先度（1..100)"]
              )
    #時間フォーマット
    for i in range(n_job):
        for j in range(num_tw*2):
            if date_flag:
                ws.cell(2+i,5+j).number_format = 'yyyy/m/d\\ h:mm;@'
            else:
                ws.cell(2+i,5+j).number_format = 'h:mm;@'

    #作業時間バリデーション
    dv = DataValidation(type="whole", allow_blank=False)
    ws.add_data_validation(dv)
    dv.add('B2:B1048576')  
    
    #緯度経度バリデーション
    dv = DataValidation(type="decimal", allow_blank=False)
    ws.add_data_validation(dv)
    dv.add('C2:D1048576')  
    
    #日付・時刻バリデーション
    dv = DataValidation(type="time") 
    ws.add_data_validation(dv)
    c1 = ws.cell(2,4+2*num_tw)
    dv.add(f'E2:{c1.column_letter}1048576')   
    #積み込み・積み降ろし
    dv = DataValidation(type="whole",
                    operator="greaterThanOrEqual",
                    formula1=0)
    ws.add_data_validation(dv)
    c2 = ws.cell(2,4+2*num_tw+1) 
    c3 = ws.cell(2,4+2*num_tw+2*num_dim) 
    dv.add(f'{c2.column_letter}2:{c3.column_letter}1048576') 
    #スキル
    dv = DataValidation(type="whole",
                    operator="between",
                    formula1=0,
                    formula2=1)
    ws.add_data_validation(dv)
    c4 = ws.cell(2,4+2*num_tw+2*num_dim +1)
    c5 = ws.cell(2,4+2*num_tw+2*num_dim +num_skill)
    dv.add(f'{c4.column_letter}2:{c5.column_letter}1048576') 
    #優先度
    dv = DataValidation(type="whole",
                    operator="between",
                    formula1=1,
                    formula2=100)
    ws.add_data_validation(dv)
    c6 = ws.cell(2,4+2*num_tw+2*num_dim +num_skill+1)
    dv.add(f'{c6.column_letter}2:{c6.column_letter}1048576') 
    
    #コメント
    ws.cell(1,1).comment = Comment("ジョブ（顧客）の名称（住所などの付加情報）", "logopt")
    ws.cell(1,2).comment = Comment("作業時間（分）", "logopt")
    ws.cell(1,3).comment = Comment("ジョブの経度．形式例 140.268． Google Mapで右クリック", "logopt")
    ws.cell(1,4).comment = Comment("ジョブの緯度．形式例 35.6983． Google Mapで右クリック", "logopt")
    col = 5
    for i in range(2*num_tw):
        ws.cell(1,col+i).comment = Comment("ジョブの時間枠（日付時刻型，時刻型）", "logopt")
    col += 2* num_tw
    for i in range(2*num_dim):
        ws.cell(1,col+i).comment = Comment("ジョブの積み込み・積み降ろし量を次元別（容量とか重量など）", "logopt")
    col += 2*num_dim
    for i in range(num_skill):
        ws.cell(1,col+i).comment = Comment("ジョブを遂行にスキルが必要な場合には1，必要ない場合には0", "logopt")
    col += num_skill
    ws.cell(1,col).comment = Comment("ジョブの優先度（1から100の整数）", "logopt")
    return wb

# %% ../nbs/02metroVI.ipynb 132
def make_shipment_excel(wb, n_shipment=100, num_dim = 3, num_tw = 3, num_skill = 3, date_flag = True):
    ws = wb.create_sheet(title="輸送")
    pick_tw_list =[]
    for i in range(num_tw):
        pick_tw_list.extend( [f"最早時刻{i+1}（積み込み）", f"最遅時刻{i+1}（積み込み）" ] )
    deli_tw_list =[]
    for i in range(num_tw):
        deli_tw_list.extend( [f"最早時刻{i+1}（積み降ろし）", f"最遅時刻{i+1}（積み降ろし）" ] )
        
    ws.append([""]*num_dim +["積み込み"]+[""]*(3+num_tw*2) +["積み降ろし"]+[""]*(3+num_tw*2) )
    ws.append([f"輸送量{i+1}" for i in range(num_dim)]+ 
              ["名称（積み込み）","作業時間（（積み込み））","経度（積み込み）","緯度（積み込み）"]+
              pick_tw_list + 
              ["名称（積み降ろし）","作業時間（（積み降ろし））","経度（積み降ろし）","緯度（積み降ろし）"]+
              deli_tw_list + 
              [f"スキル{i+1}（0か1)" for i in range(num_skill)]+["優先度(1..100)"]
              )
    #1行目のマージ
    ws.merge_cells(start_row=1, start_column=num_dim+1, end_row=1, end_column=num_dim+4+num_tw*2)
    ws.merge_cells(start_row=1, start_column=num_dim+5+num_tw*2, end_row=1, end_column=num_dim+8+num_tw*4)

    #時間フォーマット（積み込み）
    for i in range(n_shipment):
        for j in range(num_tw*2):
            if date_flag:
                ws.cell(3+i, num_dim+5+j).number_format = 'yyyy/m/d\\ h:mm;@'
            else:
                ws.cell(3+i,num_dim+5+j).number_format = 'h:mm;@'
    #時間フォーマット（積み降ろし）
    for i in range(n_shipment):
        for j in range(num_tw*2):
            if date_flag:
                ws.cell(3+i, num_dim+9+num_tw*2+j).number_format = 'yyyy/m/d\\ h:mm;@'
            else:
                ws.cell(3+i,num_dim+9+num_tw*2+j).number_format = 'h:mm;@'
                
    #輸送量バリデーション
    dv = DataValidation(type="whole", allow_blank=False)
    ws.add_data_validation(dv)
    c1 = ws.cell(2, num_dim)
    dv.add(f'A3:{c1.column_letter}1048576')  
    
    #作業時間
    c1 = ws.cell(2, num_dim+2)
    dv.add(f'{c1.column_letter}3:{c1.column_letter}1048576')      
    c1 = ws.cell(2, num_dim+4+2*num_tw+2)
    dv.add(f'{c1.column_letter}3:{c1.column_letter}1048576')  
    
    #緯度経度バリデーション
    dv = DataValidation(type="decimal", allow_blank=False)
    ws.add_data_validation(dv)
    c1 = ws.cell(2, num_dim+3)
    c2 = ws.cell(2, num_dim+4)        
    dv.add(f'{c1.column_letter}3:{c2.column_letter}1048576')  
    c1 = ws.cell(2, num_dim+4+2*num_tw+3)
    c2 = ws.cell(2, num_dim+4+2*num_tw+4)
    dv.add(f'{c1.column_letter}3:{c2.column_letter}1048576')  
        
    #日付・時刻バリデーション
    dv = DataValidation(type="time") 
    ws.add_data_validation(dv)
    c1 = ws.cell(2,num_dim+5)
    c2 = ws.cell(2,num_dim+4+2*num_tw)
    dv.add(f'{c1.column_letter}3:{c2.column_letter}1048576')   
    c1 = ws.cell(2,num_dim+4+2*num_tw+5)
    c2 = ws.cell(2,num_dim+4+4*num_tw+4)
    dv.add(f'{c1.column_letter}3:{c2.column_letter}1048576')    

    #スキル
    dv = DataValidation(type="whole",
                    operator="between",
                    formula1=0,
                    formula2=1)
    ws.add_data_validation(dv)
    c4 = ws.cell(2,8+4*num_tw+num_dim +1)
    c5 = ws.cell(2,8+4*num_tw+num_dim +num_skill)
    dv.add(f'{c4.column_letter}3:{c5.column_letter}1048576') 
    
    #優先度
    dv = DataValidation(type="whole",
                    operator="between",
                    formula1=1,
                    formula2=100)
    ws.add_data_validation(dv)
    c6 = ws.cell(2,8+4*num_tw+num_dim +num_skill+1)
    dv.add(f'{c6.column_letter}3:{c6.column_letter}1048576') 

    #コメント
    col = 1
    for i in range(num_dim):
        ws.cell(2,col+i).comment = Comment("輸送の荷量を次元別（容量とか重量など）", "logopt")
    col += num_dim
    ws.cell(2,col).comment = Comment("積み込み地点の名称（住所などの付加情報）", "logopt")
    col +=1
    ws.cell(2,col).comment = Comment("作業時間（分）", "logopt")
    col +=1
    ws.cell(2,col).comment = Comment("積み込み地点の経度．形式例 140.268． Google Mapで右クリック", "logopt")
    col +=1
    ws.cell(2,col).comment = Comment("積み込み地点の緯度．形式例 35.6983． Google Mapで右クリック", "logopt")
    col +=1
    for i in range(2*num_tw):
        ws.cell(2,col+i).comment = Comment("積み込みの時間枠（日付時刻型，時刻型）", "logopt")
    col += 2* num_tw
    
    ws.cell(2,col).comment = Comment("積み降ろし地点の名称（住所などの付加情報）", "logopt")
    col +=1
    ws.cell(2,col).comment = Comment("作業時間（分）", "logopt")
    col +=1
    ws.cell(2,col).comment = Comment("積み降ろし地点の経度．形式例 140.268． Google Mapで右クリック", "logopt")
    col +=1
    ws.cell(2,col).comment = Comment("積み降ろし地点の緯度．形式例 35.6983． Google Mapで右クリック", "logopt")
    col +=1
    for i in range(2*num_tw):
        ws.cell(2,col+i).comment = Comment("積み降ろしの時間枠（日付時刻型，時刻型）", "logopt")
    col += 2* num_tw
    for i in range(num_skill):
        ws.cell(2,col+i).comment = Comment("ジョブを遂行にスキルが必要な場合には1，必要ない場合には0", "logopt")
    col += num_skill
    ws.cell(2,col).comment = Comment("ジョブの優先度（1から100の整数）", "logopt")
    return wb

# %% ../nbs/02metroVI.ipynb 134
def make_vehicle_excel(wb, n_vehicle=100, num_dim = 3, num_skill = 3, num_break = 2, date_flag = True):
    ws = wb.create_sheet(title="運搬車")
    ws.append(["名称", "出発経度（小数）", "出発緯度（小数）", "到着経度（小数）", "到着緯度（小数）", "最早時刻", "最遅時刻"]+
              [f"積載量上限{i+1}" for i in range(num_dim)] + 
              [f"スキル{i+1}（0か1)" for i in range(num_skill)]+
              [f"休憩{i+1}（0か1)" for i in range(num_break)]
              )
    #時間フォーマット
    for i in range(n_vehicle):
        for j in range(2):
            if date_flag:
                ws.cell(2+i, 6+j).number_format = 'yyyy/m/d\\ h:mm;@'
            else:
                ws.cell(2+i,6+j).number_format = 'h:mm;@'
                
    #緯度経度バリデーション
    dv_latlng = DataValidation(type="decimal", allow_blank=True)
    ws.add_data_validation(dv_latlng)
    dv_latlng.add('B2:E1048576')   
    
    #日付・時刻バリデーション
    dv = DataValidation(type="time") 
    ws.add_data_validation(dv)
    dv.add('F2:G1048576')   
    
    #積載量バリデーション
    dv_load = DataValidation(type="whole",
                    operator="greaterThan",
                    formula1=0)
    ws.add_data_validation(dv_load)
    c1 = ws.cell(2, 7+num_dim)
    dv_load.add(f"H2:{c1.column_letter}1048576")
    #スキル，休憩バリデーション
    dv_other = DataValidation(type="whole",
                    operator="between",
                    formula1=0,
                    formula2=1)
    ws.add_data_validation(dv_other)
    c2 = ws.cell(2, 7+num_dim+1) #スキルの先頭
    c3 = ws.cell(2, 7+num_dim + num_skill + num_break) #休憩の終わり
    dv_other.add(f"{c2.column_letter}2:{c3.column_letter}1048576")

    
    #コメント
    ws.cell(1,1).comment = Comment("運搬車の名称（ドライバーなどの付加情報）", "logopt")
    ws.cell(1,2).comment = Comment("発地の経度．形式例 140.268． Google Mapで右クリック", "logopt")
    ws.cell(1,3).comment = Comment("発地の緯度．形式例 35.6983． Google Mapで右クリック", "logopt")
    ws.cell(1,4).comment = Comment("着地の経度．形式例 140.268． Google Mapで右クリック", "logopt")
    ws.cell(1,5).comment = Comment("着地の緯度．形式例 35.6983． Google Mapで右クリック", "logopt")
    ws.cell(1,6).comment = Comment("運搬車の最早開始時刻（日付時刻型，時刻型）", "logopt")
    ws.cell(1,7).comment = Comment("運搬車の最遅終了時刻（日付時刻型，時刻型）", "logopt")
    col = 8
    for i in range(num_dim):
        ws.cell(1,col+i).comment = Comment("運搬車の積載量上限（正数）を次元別（容量とか重量など）", "logopt")
    col += num_dim
    for i in range(num_skill):
        ws.cell(1,col+i).comment = Comment("運搬車（ドライバー）がスキルをもつ場合には1，ない場合には0", "logopt")
    col += num_skill
    for i in range(num_break):
        ws.cell(1,col).comment = Comment("運搬車（ドライバー）に休憩を指定する場合には1，そうでない場合には0", "logopt")
    
    return wb

# %% ../nbs/02metroVI.ipynb 136
def make_break_excel(wb, num_break = 2, date_flag = False):
    ws = wb.create_sheet(title="休憩")
    ws.append(["名称", "最早時刻", "最遅時刻", "休憩時間（分）"])
    for i in range(num_break):
        ws.append([f"休憩{i+1}"])
    #時間フォーマット
    for i in range(num_break):
        for j in range(2):
            if date_flag:
                ws.cell(2+i, 2+j).number_format = 'yyyy/m/d\\ h:mm;@'
            else:
                ws.cell(2+i,2+j).number_format = 'h:mm;@'
    #日付・時刻バリデーション
    dv = DataValidation(type="time") 
    ws.add_data_validation(dv)
    dv.add('B2:C1048576')  
    
    #作業時間バリデーション
    dv = DataValidation(type="whole", allow_blank=False)
    ws.add_data_validation(dv)
    dv.add('D2:D1048576')  
    
    #コメント
    ws.cell(1,1).comment = Comment("休憩の名称（例：昼食休憩）", "logopt")
    ws.cell(1,2).comment = Comment("休憩の最早開始時刻（日付時刻型，時刻型）", "logopt")
    ws.cell(1,3).comment = Comment("休憩の最遅終了時刻（日付時刻型，時刻型）", "logopt")
    ws.cell(1,4).comment = Comment("休憩時間（分）", "logopt")
    return wb

# %% ../nbs/02metroVI.ipynb 140
def create_excel_for_metro(n_job=100, n_shipment=100, n_vehicle=100, num_dim = 1, num_tw = 1, num_skill = 1, num_break=1, date_flag = False):
    
    wb = Workbook()
    ws = wb.active
    wb.remove(ws)
    wb = make_job_excel(wb, n_job, num_dim, num_tw, num_skill, date_flag)
    wb = make_shipment_excel(wb, n_shipment, num_dim, num_tw, num_skill, date_flag)        
    wb = make_vehicle_excel(wb, n_vehicle, num_dim, num_skill, num_break, date_flag)
    wb = make_break_excel(wb, num_break, date_flag)
    
    return wb

# %% ../nbs/02metroVI.ipynb 143
def read_dfs_from_excel(wb):
    #job 
    data = wb["ジョブ"].values
    cols = next(data)[:]
    data = list(data)
    job_df = pd.DataFrame(data, columns=cols).dropna(how="all") 

    #shipment
    data = wb["輸送"].values
    next(data) #1行跳ばす
    cols = next(data)[:]
    data = list(data)
    shipment_df = pd.DataFrame(data, columns=cols).dropna(how="all") 

    #vehicle
    data = wb["運搬車"].values
    cols = next(data)[:]
    data = list(data)
    vehicle_df = pd.DataFrame(data, columns=cols).dropna(how="all") 

    #break
    data = wb["休憩"].values
    cols = next(data)[:]
    data = list(data)
    break_df = pd.DataFrame(data, columns=cols).dropna(how="all") 
    
    return job_df, shipment_df, vehicle_df, break_df

# %% ../nbs/02metroVI.ipynb 145
def read_time_from_excel(wb):
    #job 
    data = wb["移動時間"].values
    cols = next(data)[:]
    data = list(data)
    time_df = pd.DataFrame(data, columns=cols).dropna(how="all") 
    return time_df

# %% ../nbs/02metroVI.ipynb 147
def compute_table_sub(job_df, shipment_df, vehicle_df, break_df, num_dim=1, 
                      num_tw=1, num_skill=1, num_break=1, toll=True, host="localhost"):
    #ユニークな経度・緯度の情報を抽出
    location_index ={}
    idx = 0
    for row in job_df.itertuples():
        lng = row[3]
        lat = row[4]
        if (lng,lat) not in location_index:
            location_index[(lng,lat)] = idx
            idx+=1
    for row in shipment_df.itertuples():
        lng = row[3+num_dim]
        lat = row[4+num_dim]
        if (lng,lat) not in location_index:
            location_index[(lng,lat)] = idx
            idx+=1
        col = 4+num_dim+2*num_tw + 3
        lng = row[col]
        lat = row[col+1]
        if (lng,lat) not in location_index:
            location_index[(lng,lat)] = idx
            idx+=1
    for row in vehicle_df.itertuples():
        lng = row[2]
        lat = row[3]
        if pd.isnull(lng) or pd.isnull(lat):
            pass
        else:
            if (lng,lat) not in location_index:
                location_index[(lng,lat)] = idx
                idx+=1
        lng = row[4]
        lat = row[5]
        if pd.isnull(lng) or pd.isnull(lat):
            pass
        else:
            if (lng,lat) not in location_index:
                location_index[(lng,lat)] = idx
                idx+=1
    #点のデータフレーム生成，時間計算
    idx_list, lng_list, lat_list = [],[],[]
    for (lng,lat) in location_index:
        idx_list.append( location_index[(lng,lat)] )
        lng_list.append( lng )
        lat_list.append( lat )
    cust_df = pd.DataFrame({"name": idx_list, "lat": lat_list, "lon": lng_list })
    durations,  distances, node_df = compute_durations(cust_df, toll=toll, host= host ) #coreで移動時間・移動距離を計算
    
    return durations,  distances, node_df, location_index

# %% ../nbs/02metroVI.ipynb 149
def make_table_for_metro(wb, num_dim=1, num_tw=1, num_skill=1, num_break=1, toll=True, host="localhost"):

    job_df, shipment_df, vehicle_df, break_df = read_dfs_from_excel(wb)
    
    durations,  distances, node_df, location_index = compute_table_sub(job_df, shipment_df, vehicle_df, 
                                                                       break_df, num_dim, num_tw, num_skill, 
                                                                       num_break, toll, host)
    
    #移動時間データフレーム生成
    time_df = make_time_df(node_df, durations, distances)
    time_df = time_df[ ["from_node", "to_node", "time", "distance"] ]
    #シート生成・書き出し
    ws = wb.create_sheet(title="地点")
    for r in dataframe_to_rows(node_df, index=False, header=True):
        ws.append(r)
    ws = wb.create_sheet(title="移動時間")
    for r in dataframe_to_rows(time_df, index=False, header=True):
        ws.append(r)
    #基本データにlocation_index追加    
    ws = wb["ジョブ"]
    col = 4+num_tw * 2+num_dim * 2+num_skill+2
    ws.cell(1,col).value = "location_index"
    for i, row in enumerate(job_df.itertuples()):
        lng = row[3]
        lat = row[4]
        ws.cell(2+i,col).value = location_index[lng,lat]
    ws = wb["輸送"]
    col = 8 + num_tw*4+num_dim+num_skill+2
    ws.cell(2,col).value = "pickup_index"
    ws.cell(2,col+1).value = "delivery_index"
    for i, row in enumerate(shipment_df.itertuples()):
        lng = row[3+num_dim]
        lat = row[4+num_dim]
        ws.cell(3+i,col).value = location_index[lng,lat]

        latlng_col = 4+num_dim+2*num_tw + 3
        lng = row[latlng_col]
        lat = row[latlng_col+1]
        ws.cell(3+i,col+1).value = location_index[lng,lat]
    ws = wb["運搬車"]
    col =8+num_dim+num_skill+num_break
    ws.cell(1,col).value = "start_index"
    ws.cell(1,col+1).value = "end_index"
    for i, row in enumerate(vehicle_df.itertuples()):
        lng = row[2]
        lat = row[3]
        if pd.isnull(lng) or pd.isnull(lat):
            ws.cell(2+i,col).value = None 
        else:
            ws.cell(2+i,col).value = location_index[lng,lat]
        lng = row[4]
        lat = row[5]
        if pd.isnull(lng) or pd.isnull(lat):
            ws.cell(2+i,col+1).value = None
        else:
            ws.cell(2+i,col+1).value = location_index[lng,lat]
    return wb, durations, distances

# %% ../nbs/02metroVI.ipynb 153
def make_time_fig_for_excel(job_df, shipment_df, vehicle_df, break_df, num_dim=1, num_tw=1, 
                            num_skill=1, num_break=1, toll=True, host="localhost"):

    durations,  distances, node_df, location_index = compute_table_sub(job_df, shipment_df, vehicle_df, 
                                                                       break_df, num_dim, num_tw, num_skill,
                                                                       num_break, toll, host)
    
    name, duration = [], []
    for row in job_df.itertuples():
        name.append(row[1])
        lng = row[3]
        lat = row[4]
        i = location_index[lng,lat]
        min_time = 999999999 
        for row in vehicle_df.itertuples():
            lng = row[2]
            lat = row[3]
            if pd.isnull(lng):
                dur = 0 
            else:
                j = location_index[lng,lat]
                dur = durations[j][i]
            lng = row[4]
            lat = row[5]
            if pd.isnull(lng):
                dur+= 0 
            else:
                j = location_index[lng,lat]
                dur+= durations[i][j]
            if dur < min_time:
                min_time = dur

        duration.append(min_time)

    for row in shipment_df.itertuples():
        name.append( str(row[num_dim+1]) + "=>" + str(row[num_dim+num_tw*2+5]) )

        lng = row[3+num_dim]
        lat = row[4+num_dim]
        pickup = location_index[lng,lat]

        latlng_col = 4+num_dim+2*num_tw + 3
        lng = row[latlng_col]
        lat = row[latlng_col+1]
        delivery = location_index[lng,lat]
        min_time = 999999999 
        for row in vehicle_df.itertuples():
            lng = row[2]
            lat = row[3]
            if pd.isnull(lng):
                dur = 0 
            else:
                j = location_index[lng,lat]
                dur = durations[j][pickup] + durations[pickup][delivery] 
            lng = row[4]
            lat = row[5]
            if pd.isnull(lng):
                dur+= 0 
            else:
                j = location_index[lng,lat]
                dur+= durations[delivery][j]
            if dur < min_time:
                min_time = dur

        duration.append(min_time)
    df = pd.DataFrame({"名称": name, "最短移動時間(s)": duration})
    df.sort_values(by="最短移動時間(s)", inplace=True)
    fig = px.bar(df, x="名称", y="最短移動時間(s)")
    fig_hist = px.histogram(df, x="最短移動時間(s)")
    return fig, fig_hist

# %% ../nbs/02metroVI.ipynb 159
def make_tw_fig_for_excel(job_df, shipment_df, vehicle_df, num_dim = 1, num_tw = 1):
    """
    Excel用のデータフレームを用いた時間枠を可視化する関数
    """
    start = vehicle_df.iloc[:,5].min()
    #print(start)
    finish = vehicle_df.iloc[:,6].max()
    L = []
    for row in job_df.itertuples():
        for j in range(num_tw):
            if pd.isnull(row[5+j*2]):
                L.append(dict(Task=f"時間枠 {j}", Start= start.strftime('%Y-%m-%d %H:%M'), Finish=finish.strftime('%Y-%m-%d %H:%M'), Resource=row[1]))
            else:
                tw0 = row[5+j*2]
                tw1 = row[6+j*2]
                L.append(dict(Task=f"時間枠 {j}", Start= tw0.strftime('%Y-%m-%d %H:%M'), Finish=tw1.strftime('%Y-%m-%d %H:%M'), Resource=row[1]))
                
    for row in shipment_df.itertuples():
        for j in range(num_tw): 
            if pd.isnull(row[num_dim+5+j*2]):
                L.append(dict(Task=f"時間枠 {j}", Start= start.strftime('%Y-%m-%d %H:%M'), Finish=finish.strftime('%Y-%m-%d %H:%M'), Resource=row[num_dim+1]))
            else:
                tw0 = row[num_dim+5+j*2]
                tw1 = row[num_dim+6+j*2]  
                L.append(dict(Task=f"積み込み時間枠 {j}", Start= tw0.strftime('%Y-%m-%d %H:%M'), 
                              Finish=tw1.strftime('%Y-%m-%d %H:%M'), Resource=row[num_dim+1]))
            
            if pd.isnull(row[num_dim+9+num_tw*2+j*2]):
                L.append(dict(Task=f"時間枠 {j}", Start= start.strftime('%Y-%m-%d %H:%M'), Finish=finish.strftime('%Y-%m-%d %H:%M'), Resource=row[num_dim+4+num_tw*2+1]))
            else:
                tw0 = row[num_dim+9+num_tw*2+j*2]
                tw1 = row[num_dim+10+num_tw*2+j*2]
                L.append(dict(Task=f"積み降ろし時間枠 {j}", Start= tw0.strftime('%Y-%m-%d %H:%M'), Finish=tw1.strftime('%Y-%m-%d %H:%M'), 
                              Resource=row[num_dim+4+num_tw*2+1]))
    df = pd.DataFrame( L ) 
#    print(L)
    fig = px.timeline(df, x_start="Start", x_end="Finish", y="Resource", color="Task")
    return fig

# %% ../nbs/02metroVI.ipynb 167
def analyze_load(job_df, vehicle_df, num_dim=1, num_tw = 1, num_skill = 1):
    demand = {}
    skill = {}
    for i,row in enumerate(job_df.itertuples()):
        for j in range(2*num_dim):
            demand[i,j] = row[5+2*num_tw+j]
        skill[i] = set([])
        for k in range(num_skill):
            if pd.isnull(row[5+2*num_tw+2*num_dim+k]):
                pass
            elif row[5+2*num_tw+2*num_dim+k]>0: 
                skill[i].add(k)

    v_skill ={}
    capacity ={}
    vehicle_name ={}
    for v,row in enumerate(vehicle_df.itertuples()):
        vehicle_name[v] = row[1]
        for j in range(num_dim):
            capacity[v,j] = row[8+j]
        v_skill[v] = set([])
        for k in range(num_skill):
            if pd.isnull(row[8+num_dim+k]):
                pass
            elif row[8+num_dim+k]>0:
                v_skill[v].add(k)

    model = PulpModel()
    x = {}
    m = len(job_df)
    n = len(vehicle_df)
    for i in range(m):
        for v in range(n):
            if skill[i]<=v_skill[v]:
                x[i,v] = model.addVar(name=f"x({i},{v})", vtype="C")
    surplus, slack ={},{}
    for v in range(n):
        for j in range(num_dim):
            slack[v,j,0] = model.addVar(name=f"slack({v},{j},0)", vtype="C") #for pickup
            slack[v,j,1] = model.addVar(name=f"slack({v},{j},1)", vtype="C") #for delivery
            surplus[v,j,0] = model.addVar(name=f"surplus({v},{j},0)", vtype="C") #for pickup
            surplus[v,j,1] = model.addVar(name=f"surplus({v},{j},1)", vtype="C") #for delivery
    y = model.addVar(name ="y", vtype="C") #超過の最大値
    z = model.addVar(name ="z", vtype="C") #スラックの最小値
    model.update()
    #割当制約
    for i in range(m):
        model.addConstr(quicksum(x[i,v] for v in range(n) if (i,v) in x) == 1, name=f"Assign({i})")
    #容量制約
    for v in range(n):
        for j in range(num_dim):
            model.addConstr(quicksum(demand[i,j]*x[i,v] for i in range(m) if (i,v) in x) + capacity[v,j]*slack[v,j,0] 
                            == capacity[v,j]+ capacity[v,j]*surplus[v,j,0], name=f"pickup({v},{j})")   #積み込み上限
            model.addConstr(quicksum(demand[i,num_dim+j]*x[i,v] for i in range(m) if (i,v) in x) + capacity[v,j]*slack[v,j,1] 
                            == capacity[v,j] + capacity[v,j]*surplus[v,j,1], name=f"delivery({v},{j})") #積み降ろし上限
    #最小のスラックを最大化
    for v in range(n):
        for j in range(num_dim):
            for k in range(2):
                model.addConstr(slack[v,j,k]>=z, name=f"slack_min({v},{j},{k})")
    #最大の超過を最小化
    for v in range(n):
        for j in range(num_dim):
            for k in range(2):
                model.addConstr(surplus[v,j,k]<=y, name=f"surplus_max({v},{j},{k})")
    #超過は最小化（第１目的）；スラックの最小値の最大化（第２目的）
    model.setObjective(-z + 999999.*y + .01* quicksum(surplus[v,j,k]+slack[v,j,k] for v in range(n) for j in range(num_dim) for k in range(2)), GRB.MINIMIZE)
    model.optimize()
    # for (i,v) in x:
    #     if x[i,v].X > 0.001:
    #         print(i,v,x[i,v].X)

    v_list, j_list, k_list,val_list =[],[],[],[]
    for v in range(n):
        for j in range(num_dim):
            for k in range(2):
                v_list.append(vehicle_name[int(v)])
                j_list.append(j+1)
                if k==0:
                    k_list.append("積み込み")
                else:
                    k_list.append("積み降ろし")
                val_list.append(surplus[v,j,k].X)
                #if surplus[v,j,k].X > 0:
                #    print(v,j,k,surplus[v,j,k].X)   
    df = pd.DataFrame({"運搬車":v_list, "荷量次元": j_list, "積み込み・積み降ろし":k_list, "超過":val_list})
    fig_surplus = px.bar(df, x="運搬車", y="超過", facet_row="荷量次元", facet_col="積み込み・積み降ろし", range_y=[0,1])

    v_list, j_list, k_list,val_list =[],[],[],[]
    for v in range(n):
        for j in range(num_dim):
            for k in range(2):
                v_list.append(vehicle_name[int(v)])
                j_list.append(j+1)
                if k==0:
                    k_list.append("積み込み")
                else:
                    k_list.append("積み降ろし")
                val_list.append(slack[v,j,k].X)
                #print(v,j,k,slack[v,j,k].X)
    #print(model.ObjVal,z.X)
    df = pd.DataFrame({"運搬車":v_list, "荷量次元": j_list, "積み込み・積み降ろし":k_list, "余裕":val_list})
    fig_slack = px.bar(df, x="運搬車", y="余裕", facet_row="荷量次元", facet_col="積み込み・積み降ろし", range_y=[0,1])
    return fig_surplus, fig_slack 

# %% ../nbs/02metroVI.ipynb 173
def show_load(job_df, num_dim=1, num_tw=1):
    demand = {}
    for i,row in enumerate(job_df.itertuples()):
        for j in range(2*num_dim):
            demand[i,j] = row[5+2*num_tw+j]
    c_list, j_list, k_list,val_list =[],[],[],[]
    for i,row in enumerate(job_df.itertuples()):
        for j in range(num_dim):
            for k in range(2): #k=0 pickup, k=1 delivery 
                c_list.append(row[1]) #顧客名
                j_list.append(j+1)
                if k==0:
                    k_list.append("積み込み")
                else:
                    k_list.append("積み降ろし")
                val_list.append(demand[i,num_dim*k+j])
    df = pd.DataFrame({"顧客": c_list, "荷量次元": j_list, "積み込み・積み降ろし":k_list, "荷量":val_list})
    df.sort_values("荷量", inplace=True, ascending=False)
    fig_hist = px.histogram(df, x= "荷量", facet_row="荷量次元", facet_col="積み込み・積み降ろし")
    fig_bar = px.bar(df, x= "荷量", y="顧客", facet_row="荷量次元", facet_col="積み込み・積み降ろし")
    return fig_bar, fig_hist

# %% ../nbs/02metroVI.ipynb 179
def create_dfs_from_excel(job_df, shipment_df, vehicle_df, break_df, num_dim = 1, 
                          num_tw = 1, num_skill = 1, num_break=1, date_flag = False):
    #運搬車の最早開始時刻
    start = vehicle_df.iloc[:,5].min()
    finish = vehicle_df.iloc[:,6].max()
    max_time = time_delta(finish,start)
    #job_df
    name, service, delivery, pickup, location, time_windows, skills, priority = [],[],[],[],[],[],[],[]
    location_index = [] 
    for row in job_df.itertuples():
        try:
            location_index.append( int(row.location_index) )
        except:
            location_index.append( -1 )
            
        name.append(str(row[1]))
        service.append( int(row[2]*60) )  #作業時間（分）を秒に変換 [600]
        location.append( f"[{row[3]},{row[4]}]" ) #経度緯度
        TW =[ ]
        col = 5
        for j in range(num_tw):
            if pd.isnull(row[col+2*j]) or pd.isnull(row[col+1+2*j]):
                pass   #入力がない場合には追加しない！
            else:
                early = max(time_delta(row[col+2*j],start),0)
                late = max(time_delta(row[col+1+2*j],start),0) 
                if early >= late:
                    #print(early, late, row[col+2*j], row[col+1+2*j])
                    raise ValueError("時間枠が不正です．")
                TW.append( [early, late] )
        # TWが空の場合には運搬車の最大時間とする．
        if len(TW)==0:
            TW = f"[[0,{max_time}]]"
        time_windows.append( str(TW) )
        PICK, DELI =[], []
        col += num_tw*2
        for j in range(num_dim): #積み込み量
            try:
                PICK.append( int(row[col+j]) )
            except:
                PICK.append(0)
        col += num_dim

        for j in range(num_dim): #積み降ろし量
            try:
                DELI.append( int(row[col+j]) )
            except:
                DELI.append(0) 
        pickup.append( str(PICK ))
        delivery.append( str(DELI ))
        col += num_dim
        
        SKILL =[0] #少なくとも1つのスキルをもつ
        for j in range(num_skill):
            if pd.isnull(row[col+j]):
                pass  #行がNoneの場合は何も追加しない
            elif row[col+j]>0: #j番目のスキルをもつ
                SKILL.append(j+1)
        skills.append( str(SKILL) )
        col += num_skill
        try:
            priority.append( int(row[col]) )
        except:
            priority.append(1)
    job_df = pd.DataFrame( {"name": name, 
                            "service": service,
                            "location": location, 
                            "time_windows": time_windows,
                            "pickup": pickup, 
                            "delivery": delivery, 
                            "skills": skills, 
                            "priority": priority,
                            "location_index": location_index
                           })

    #shipment_df
    amount, pick_name, pick_loc, pick_tw, pick_service, del_name, del_loc, del_service, del_tw, skills, priority = [],[],[],[],[],[],[],[],[],[],[]
    pickup_index, delivery_index = [], [] 
    
    for row in shipment_df.itertuples():
        try:
            pickup_index.append( int(row.pickup_index) )
        except:
            pickup_index.append( -1 ) 
        try:
            delivery_index.append( int(row.delivery_index) )
        except:
            delivery_index.append( -1 )
            
        AMOUNT =[]
        col = 1
        for j in range(num_dim):
            try:
                AMOUNT.append( int(row[col+j]) )
            except:
                AMOUNT.append(0) #なにもない場合には0を入れる！
        amount.append( str(AMOUNT) )
        col = num_dim +1  
        pick_name.append(str(row[col]))
        col +=1
        try:
            pick_service.append( int(row[col]*60) )  #作業時間（分）を秒に変換 [600]
        except:
            pick_service.append( 0 )
        col +=1
        pick_loc.append( f"[{row[col]},{row[col+1]}]" ) #経度緯度
        TW =[ ]
        col +=2
        for j in range(num_tw):
            if pd.isnull(row[col+2*j]) or pd.isnull(row[col+1+2*j])  :
                pass   #入力がない場合には追加しない！
            else:
                early = max(time_delta(row[col+2*j],start),0)
                late = max(time_delta(row[col+1+2*j],start),0) 
                if early >= late:
                    raise ValueError("時間枠が不正です．")
                TW.append( [early, late] )
        if len(TW)==0:
            TW = f"[[0,{max_time}]]"
        pick_tw.append( str(TW) )
        col += num_tw*2
        #delivery
        del_name.append(str(row[col]))
        col +=1
        try:
            del_service.append( int(row[col]*60) )  #作業時間（分）を秒に変換 [600]
        except:
            del_service.append( 0 )
        col +=1
        del_loc.append( f"[{row[col]},{row[col+1]}]" ) #経度緯度
        TW =[ ]
        col +=2
        for j in range(num_tw):
            if pd.isnull(row[col+2*j]) or pd.isnull(row[col+1+2*j])  :
                pass   #入力がない場合には追加しない！
            else:
                early = max(time_delta(row[col+2*j],start),0)
                late = max(time_delta(row[col+1+2*j],start),0) 
                if early >= late:
                    raise ValueError("時間枠が不正です．")
                TW.append( [early, late] )
        if len(TW)==0:
            TW = f"[[0,{max_time}]]"                
        del_tw.append( str(TW) )
        col += num_tw*2    
        SKILL =[0]
        for j in range(num_skill):
            try: #行がNoneの場合は何も追加しない
                if row[col+j]>0: #j番目のスキルをもつ
                    SKILL.append(j+1)
            except:
                pass 
        skills.append( str(SKILL) )
        col += num_skill
        try:
            priority.append( int(row[col]) )
        except:
            priority.append( 1 )
    shipment_df = pd.DataFrame({"amount": amount,
            "pickup_point": pick_name, 
            "pickup_service": pick_service,
            "pickup_time_windows":pick_tw, 
            "pickup_location": pick_loc,                          
            "delivery_point": del_name, 
            "delivery_service": del_service,
            "delivery_time_windows":del_tw, 
            "delivery_location": del_loc,
            "skills": skills, "priority": priority,
            "pickup_index": pickup_index, 
            "delivery_index": delivery_index
            }) 
    
    #vehicle_df
    name, st, end, capacity, time_window, skills, breaks = [],[],[],[],[],[],[]
    start_index, end_index = [], [] 
    for row in vehicle_df.itertuples():
        try:
            start_index.append( int(row.start_index) )
        except:
            start_index.append( -1 )
        try:
            end_index.append( int(row.end_index) )
        except:
            end_index.append( -1 )
            
        col = 1 
        name.append(str(row[col]))
        col +=1
        if pd.isnull(row[col]) or pd.isnull(row[col+1]):
            st.append("[]")
        else:
            st.append( f"[{row[col]},{row[col+1]}]" ) #出発経度緯度
        col +=2
        if pd.isnull(row[col]) or pd.isnull(row[col+1]):
            end.append("[]")
        else:
            end.append( f"[{row[col]},{row[col+1]}]" ) #到着経度緯度
        col +=2
        time_window.append( f"[{time_delta(row[col],start)}, {time_delta(row[col+1],start)}]" )
        col +=2    
        CAP =[]
        for j in range(num_dim):
            try:
                CAP.append( int(row[col+j]) )
            except:
                CAP.append(0)
        capacity.append( str(CAP) )
        col+=num_dim  
        SKILL =[0]
        for j in range(num_skill):
            try: #行がNoneの場合は何も追加しない
                if row[col+j]>0: #j番目のスキルをもつ
                    SKILL.append(j+1)
            except:
                pass 
        skills.append( str(SKILL) )
        col += num_skill
        BREAK =[ ]
        for j in range(num_break):
            try: #行がNoneの場合は何も追加しない
                if row[col+j]>0: #j番目の休憩（順番は0から）
                    BREAK.append(j)
            except:
                pass 
        breaks.append( str(BREAK) )
    vehicle_df = pd.DataFrame({"name": name,
            "start": st, 
            "end": end,
            "time_window": time_window, 
            "capacity": capacity, 
            "skills": skills,
            "breaks": breaks,
            "start_index": start_index,
            "end_index": end_index              
            }) 
    #break_df
    description, time_windows, service= [],[],[]
    for row in break_df.itertuples():
        col = 1 
        description.append(str(row[col]))
        col +=1
        if pd.isnull(row[col]) or pd.isnull(row[col+1]):
            time_windows.append( f"[(0,{max_time})]" )
        else:
            time_windows.append( f"[({max(time_delta(row[col],start),0)}, {time_delta(row[col+1],start)})]" )
        col+=2
        if pd.isnull(row[col]):
            service.append(0)
        else:
            service.append( int(row[col]*60) )
    break_df = pd.DataFrame( {"description": description, "time_windows": time_windows, "service": service} )
    return job_df, shipment_df, vehicle_df, break_df, start

# %% ../nbs/02metroVI.ipynb 190
def unassigned_for_excel(job_df, shipment_df, vehicle_df, output_dic):
    """
    Excel用の未割り当てを返す関数
    """
    n_jobs = len(job_df)
    n_thres = n_jobs + len(shipment_df)
    unassigned_job, unassigned_shipment = [], [] 
    for d in output_dic["unassigned"]:
        if  n_jobs <= d["id"]< n_thres: #pickup point 
            shipment_id = d["id"]-n_jobs
            unassigned_shipment.append(shipment_id)
        elif d["id"] <=n_jobs:
            unassigned_job.append( d["id"] )
    unassigned_shipment_df = shipment_df.iloc[ unassigned_shipment, : ]
    unassigned_job_df = job_df.iloc[ unassigned_job, :]
    
    assigned_vehicle = []
    for r in output_dic["routes"]:
        assigned_vehicle.append( r["vehicle"] )
    assigned_vehicle = set(assigned_vehicle)
    unassigned_vehicle =[ ]
    for i in range(len(vehicle_df)):
        if i not in assigned_vehicle:
            unassigned_vehicle.append(i)
    unassigned_vehicle_df = vehicle_df.iloc[unassigned_vehicle, :] 

    return unassigned_job_df, unassigned_shipment_df, unassigned_vehicle_df 

# %% ../nbs/02metroVI.ipynb 193
def write_result_excel(start, route_df_dic, unassigned_job_df, unassigned_shipment_df, 
                       unassigned_vehicle_df, output_dic, num_tw):
    wb = Workbook()
    ws = wb.active
    wb.remove(ws)

    ws = wb.create_sheet(title="サマリー")
    ws.append(["METRO 最適化サマリー"])

    ws.append(["総移動時間", output_dic["summary"]["cost"]] )
        
    ws.append(["未処理ジョブ"])
    if len(unassigned_job_df) > 0:
        for row in dataframe_to_rows(unassigned_job_df,index=True, header=True):
            ws.append(row)
    ws.append(["未処理輸送"])
    if len(unassigned_shipment_df) > 0:
        for row in dataframe_to_rows(unassigned_shipment_df, index=True, header=True):
            ws.append(row) 
    ws.append(["未使用運搬車"])
    if len(unassigned_vehicle_df) > 0:
        for row in dataframe_to_rows(unassigned_vehicle_df, index=True, header=True):
            ws.append(row) 

    #ルート
    for r in route_df_dic:
        ws = wb.create_sheet(title=f"ルート{r}")
        tw_list = {}
        for i in range(num_tw*2):
            tw_list[i] = []
        arrival = []
        #skills = [ ]
        for row in route_df_dic[r].itertuples():
            arrival.append( add_seconds(start, row[8]) )
            #スキルから既定値の0を除く
            # try:
            #     skill = re.findall(r"\d+", row.skills)
            #     skill.remove("0")
            #     s = []
            #     for i in skill:
            #         s.append(int(i))
            # except:
            #     s = "[]"
            # skills.append(s)
            
        #     tw = re.findall(r"\d+", row[6])
        #     tw_data = list(map(int, tw)) #時間枠のデータ
        #     for i in range(num_tw*2):
        #         try:
        #             tw_list[i].append( add_seconds(start,tw_data[i]) )  
        #         except:
        #             tw_list[i].append("")
        # count = 0
        # for i in range(num_tw):  
        #     route_df_dic[r][f"最早時刻{i+1}"] = tw_list[count]
        #     count+=1
        #     route_df_dic[r][f"最遅時刻{i+1}"] = tw_list[count]
        #     count+=1
            
        route_df_dic[r]["到着時刻"] = arrival                 
        route_df_dic[r]["作業時間"] = route_df_dic[r]["service"]//60
        route_df_dic[r]["経過時間"] = route_df_dic[r]["duration"]//60
        route_df_dic[r]["待ち時間"] = route_df_dic[r]["waiting_time"]//60
        #route_df_dic[r]["skills"] = skills
        route_df_dic[r].rename(columns={"description": "名称"}, inplace=True)
        
        # tw_col =[]
        # for i in range(num_tw):
        #     tw_col.extend([f"最早時刻{i+1}",f"最遅時刻{i+1}"])
        df = route_df_dic[r][["名称", "到着時刻","作業時間","待ち時間", "経過時間"]]
        #df = df.astype({"積み込み量":str,"配達量":str,"積載量":str,"スキル":str})

        for row in dataframe_to_rows(df, index=True, header=True):
            ws.append(row)

    return wb
