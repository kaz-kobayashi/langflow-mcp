"""在庫最適化と安全在庫配置システム MESSA (MEta Safety Stock Allocation system)"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/03inventory.ipynb.

# %% auto 0
__all__ = ['folder', 'folder_bom', 'make_excel_messa', 'prepare_df_for_messa', 'prepare_opt_for_messa', 'messa_for_excel',
           'generate_pyvis_for_messa', 'ww', 'best_distribution', 'best_histogram', 'fit_demand', 'eoq',
           'simulate_inventory', 'multi_stage_simulate_inventory', 'optimize_qr', 'optimize_ss', 'approximate_ss',
           'base_stock_simulation', 'base_stock_simulation_using_dist', 'multi_stage_base_stock_simulation',
           'network_base_stock_simulation', 'initial_base_stock_level', 'max_demand_compute',
           'dynamic_programming_for_SSA', 'tabu_search_for_SSA', 'read_willems', 'extract_data_for_SSA',
           'draw_graph_for_SSA', 'make_df_for_SSA', 'draw_graph_for_SSA_from_df', 'solve_SSA', 'periodic_inv_opt',
           'periodic_inv_opt_fit_one_cycle', 'plot_inv_opt_lr_find', 'plot_inv_opt', 'plot_simulation']

# %% ../nbs/03inventory.ipynb 3
import warnings
import random
import string
import datetime
import math
import pickle
from collections import OrderedDict, defaultdict
import xml.etree.ElementTree as ET
import plotly.graph_objs as go
import plotly.express as px
import plotly

from plotly.subplots import make_subplots
from scipy.stats import truncnorm
from scipy.stats import norm
import scipy.stats as st

import pandas as pd
import colorlover as cl
import numpy as np
import networkx as nx
from IPython.display import Image, YouTubeVideo

import matplotlib.pyplot as plt

from openpyxl import Workbook, load_workbook
from openpyxl.worksheet.table import Table, TableStyleInfo
from openpyxl.chart import ScatterChart, Reference, Series
from openpyxl.worksheet.datavalidation import DataValidation
from openpyxl.formatting.rule import ColorScaleRule, CellIsRule, FormulaRule
from openpyxl.styles import Color, PatternFill, Font, Border, Alignment
from openpyxl.styles.borders import Border, Side
from openpyxl.utils.dataframe import dataframe_to_rows
from openpyxl.comments import Comment

import pyvis

import sys
sys.path.append('..')

from .core import *

folder = "./data/"
folder_bom = "./data/bom/"

# %% ../nbs/03inventory.ipynb 13
def make_excel_messa():
    #テンプレ生成
    wb = Workbook()
    ws = wb.active
    wb.remove(ws)
    ws = wb.create_sheet(title="品目")
    ws.append(["品目名称（ID）","処理時間（日）", "最大保証リード時間（日）","平均需要量（units/日）","需要の標準偏差","在庫費用（円/unit/日）","品切れ費用（円/unit/日）","発注固定費用（円）"])

    ws.cell(1,1).comment = Comment("在庫地点を表す品目の名称(ID)", "logopt")
    ws.cell(1,2).comment = Comment("在庫地点での処理時間（入庫から出庫までに必要な時間）", "logopt")
    ws.cell(1,3).comment = Comment("下流の在庫地点（顧客）に保証しているリード時間での上限", "logopt")
    ws.cell(1,4).comment = Comment("品目の1日あたりの平均需要量（需要がない場合は空白）", "logopt")
    ws.cell(1,5).comment = Comment("品目の1日あたりの標準偏差（需要がない場合は空白，ある場合には非負の値）", "logopt")
    ws.cell(1,6).comment = Comment("品目1単位・1日あたりの在庫費用；正の値", "logopt")
    ws.cell(1,7).comment = Comment("品目1単位・1日あたりの品切れ費用；在庫費用より大きな数", "logopt")
    ws.cell(1,8).comment = Comment("発注1回あたりの固定費用", "logopt")
    
    
    #データチェック
    dv = DataValidation(type="decimal", allow_blank=False)
    ws.add_data_validation(dv)
    dv.add('B2:H1048576')  
    
    
    ws = wb.create_sheet(title="部品展開表")
    ws.append(["子品目（ID）","親品目(ID)","必要量(units)"])
    
    ws.cell(1,1).comment = Comment("上流（調達側）の在庫地点を子品目として入力", "logopt")
    ws.cell(1,2).comment = Comment("下流（顧客側）の在庫地点を親品目として入力", "logopt")
    ws.cell(1,3).comment = Comment("親品目を1単位製造するために必要な子品目の数", "logopt")

    #データチェック
    dv = DataValidation(type="decimal", allow_blank=False)
    ws.add_data_validation(dv)
    dv.add('C2:C1048576') 
    
    return wb

# %% ../nbs/03inventory.ipynb 17
def prepare_df_for_messa(wb): 
    #基本wbのシートの読み込みとデータフレームの準備
    data = wb["品目"].values
    cols = next(data)[:]
    data = list(data)
    item_df = pd.DataFrame(data, columns=cols).dropna(how="all") 
    data = wb["部品展開表"].values
    cols = next(data)[:]
    data = list(data)
    bom_df = pd.DataFrame(data, columns=cols).dropna(how="all") 
    return item_df, bom_df

# %% ../nbs/03inventory.ipynb 19
def prepare_opt_for_messa(wb):
    if set(wb.sheetnames) != set(["品目","部品展開表"]):
        raise ValueError("シート名が不正です．")
    item_df, bom_df = prepare_df_for_messa(wb)
    
    item_df.fillna(0, inplace=True)
    ProcTime = np.array(item_df.iloc[:,1], int)
    LTUB     = np.array(item_df.iloc[:,2], int)
    mu       = np.array(item_df.iloc[:,3], float)
    sigma    = np.array(item_df.iloc[:,4], float)
    h        = np.array(item_df.iloc[:,5], float)
    b        = np.array(item_df.iloc[:,6], float)
    fc       = np.array(item_df.iloc[:,7], float)
    
    for i in range(len(h)):
        if h[i]<=0 or b[i]<=0:
            raise ValueError(f"{i}番目のデータエラー：在庫費用・品切れ費用は正の数でなければなりません．")
        
    omega = b/(b+h)
    z = norm.ppf(omega)
    G = SCMGraph()
    for row in item_df.itertuples():
        G.add_node(row[1])

    edges = []
    for row in bom_df.itertuples():
        edges.append( (row[1],row[2],float(row[3])) )
    G.add_weighted_edges_from(edges)

    #点のラベルの付け替え
    mapping ={i:idx for idx,i in enumerate(G)}
    G = nx.relabel_nodes(G, mapping=mapping, copy=True)

    #需要と標準偏差の計算
    for v in G.up_order():
        if G.out_degree(v) == 0:
            pass
        else:
            total = 0.
            total_square = 0.
            for w in G.successors(v):
                #print(w, mu[w], sigma[w])
                total += mu[w]*G[v][w]["weight"]
                total_square += (sigma[w]*G[v][w]["weight"])**2
            mu[v] = total
            sigma[v] = np.sqrt(total_square)
            
    # 少なくとも1つのノードは正の需要を持つ必要がある（最終製品）
    if all(mu[i] <= 0.000001 for i in range(len(G))):
        raise ValueError("エラー：少なくとも1つの品目に正の需要が必要です．")
            
    return G, ProcTime,  LTUB, z, mu, sigma, h

# %% ../nbs/03inventory.ipynb 23
def messa_for_excel(wb, best_NRT, best_MaxLI, best_MinLT):
    item_df, bom_df = prepare_df_for_messa(wb)

    item_df.fillna(0, inplace=True)
    ProcTime = np.array(item_df.iloc[:,1], int)
    LTUB     = np.array(item_df.iloc[:,2], int)
    mu       = np.array(item_df.iloc[:,3], float)
    sigma    = np.array(item_df.iloc[:,4], float)
    h        = np.array(item_df.iloc[:,5], float)
    b        = np.array(item_df.iloc[:,6], float)
    fc       = np.array(item_df.iloc[:,7], float)
    omega = b/(b+h)
    z = norm.ppf(omega)
    
    G = SCMGraph()
    for row in item_df.itertuples():
        G.add_node(row[1])

    edges = []
    for row in bom_df.itertuples():
        edges.append( (row[1],row[2],float(row[3])) )
    G.add_weighted_edges_from(edges)

    #点のラベルの付け替え
    mapping ={i:idx for idx,i in enumerate(G)}
    G = nx.relabel_nodes(G, mapping=mapping, copy=True)

    #需要と標準偏差の計算
    for v in G.up_order():
        if G.out_degree(v) == 0:
            pass
        else:
            total = 0.
            total_square = 0.
            for w in G.successors(v):
                #print(w, mu[w], sigma[w])
                total += mu[w]*G[v][w]["weight"]
                total_square += (sigma[w]*G[v][w]["weight"])**2
            mu[v] = total
            sigma[v] = np.sqrt(total_square)

    ws = wb["品目"]
    col_ = ["補充リード時間", "保証リード時間", "正味補充時間（在庫日数）"]
    for j in range(3):
        ws.cell(1,9+j).value = col_[j]

    for i, v in enumerate(best_MaxLI):
        ws.cell(2+i,9).value = int(v)
    for i, v in enumerate(best_MinLT):
        ws.cell(2+i,10).value = int(v)
    for i, v in enumerate(best_NRT):
        ws.cell(2+i,11).value = int(v)

    s, S = {}, {}
    s0, S0 = {},{}
    for i, v in enumerate(best_NRT):
        if int(best_NRT[i])>=1:
            s[i], S[i] = approximate_ss(mu[i], sigma[i], best_NRT[i]-1, b[i], h[i], fc[i])
            s0[i], S0[i] = approximate_ss(mu[i], sigma[i], best_NRT[i]-1, b[i], h[i], 0.) #固定費が0のとき（基在庫方策）
        else: #正味補充時間（リード時間）が0のとき
            s[i], S[i] = approximate_ss(mu[i], sigma[i], 0, b[i], h[i], fc[i])
            s0[i] = S0[i] = mu[i]  

    for i, name in enumerate(item_df.iloc[:,0]):
        #if int(best_NRT[i])==0:
        #    continue #在庫が0なのでシミュレーション省略

        ws = wb.create_sheet(f"シミュレーション{name}") #品目ごとに行う
        RLT = int(best_MaxLI[i])
        GLT = int(best_MinLT[i])
        if RLT < GLT:
            GLT = RLT #在庫 (NRT = RLT-GLT) が負にならないように
        NRT= RLT - GLT #正味補充時間（在庫日数）
        #NRT += int((S[i]-s[i])/(mu[i]+0.0001)) #固定費による発注間隔があるときの初期在庫量の調整（リード時間を基在庫レベルが発注点になるまでの平均日数を加える
        
        initial_inv = mu[i]*NRT + z[i]*sigma[i]*np.sqrt(NRT)+ int((S[i]-s[i])/mu[i])*mu[i] #初期在庫量；これから需要量を減じた値を初期在庫量とする

        #print(initial_inv, NRT, mu[i]*NRT + z[i]*sigma[i]*np.sqrt(NRT))    
        n_periods= 100
        ws.append(["期","需要","発注量","在庫量","期首在庫ポジション","発注後在庫ポジション","発注固定費用","在庫費用","品切れ費用"])
        for t in range(RLT):
            ws.append([t+1,0,0,0,0,0,0,0,0]) #期は１から，rowは2から（RLT＝０のときには必要なし）
        for t in range(1+RLT,n_periods):
            row = t+1 #期と行番号は１行ずれている(補充リード時間RLT=0のときは，t=1から)
            
            if GLT==0: #保証リード時間が0のときは需要分を減じる
                INIT_INV = f"={initial_inv}-B{row}"
            else:
                INIT_INV = f"={initial_inv}"
            
            if t==RLT+1: #初期在庫ポジションは S-demand
                # 期 t (row=t+1)
                # 需要    f"=MAX(INT(NORMINV(RAND(),{float(mu[i])},{float(sigma[i])})),0)"
                # 発注量  f"=IF(E{row}<$L$3,$L$2-E{row},0)"
                # 在庫  "{INIT_INV}+C{row-RLT}" or f"=D{row-1}-B{row-GLT}+C{row-RLT}"  
                # 期首在庫ポジション f"=F{row-1}-B{row}"
                # 発注後在庫ポジション f"=E{row}+C{row}"
                ws.append([t,f"=MAX(INT(NORMINV(RAND(),{float(mu[i])},{float(sigma[i])})),0)", f"=IF(E{row}<$L$3,$L$2-E{row},0)", 
                           f"{INIT_INV}+C{row-RLT}", f"=L2-B{row}", f"=E{row}+C{row}", 
                           f"=IF(C{row}>0,$L$6,0)", f"=IF(D{row}>0,D{row}*$L$5,0)", f"=IF(D{row}<0,-D{row}*$L$4,0)" ])
            else:
                ws.append([t,f"=MAX(INT(NORMINV(RAND(),{float(mu[i])},{float(sigma[i])})),0)", f"=IF(E{row}<$L$3,$L$2-E{row},0)", 
                           f"=D{row-1}-B{row-GLT}+C{row-RLT}", f"=F{row-1}-B{row}",f"=E{row}+C{row}",
                           f"=IF(C{row}>0,$L$6,0)", f"=IF(D{row}>0,D{row}*$L$5,0)", f"=IF(D{row}<0,-D{row}*$L$4,0)"])

        ws.append(["","","","","","合計",f"=SUM(G2:G{n_periods})",f"=SUM(H2:H{n_periods})", f"=SUM(I2:I{n_periods})"])

        
        ws["K2"].value = "基在庫レベル"
        ws["K3"].value = "発注点"
        ws["K4"].value = "品切れ費用"
        ws["K5"].value = "在庫費用"
        ws["K6"].value = "固定費用"
        ws["K8"].value = "総費用"

        ws["L1"].value = "(s,S)方策"
        ws["L2"].value = S[i]
        ws["L3"].value = s[i]
        ws["L4"].value = b[i]
        ws["L5"].value = h[i]
        ws["L6"].value = fc[i]
        ws["L8"].value = f"=SUM(G{n_periods+1}:I{n_periods+1})"
        
        ws["M1"].value = "基在庫方策"
        ws["M2"].value = S0[i]
        ws["M3"].value = s0[i]

        c1 = ScatterChart()
        c1.title = "在庫推移チャート"
        c1.style = 13
        c1.y_axis.title = '在庫量'
        c1.x_axis.title = '期'
        xvalues = Reference(ws, min_col=1, min_row=2, max_row=n_periods)
        yvalues = Reference(ws, min_col=4, min_row=1, max_row=n_periods)
        series1 = Series(yvalues, xvalues, title_from_data=True)
        c1.series.append(series1)
        #series.smooth = True # Make the line smooth
        ws.add_chart(c1, f"K11")
    return wb

# %% ../nbs/03inventory.ipynb 30
def generate_pyvis_for_messa(wb, G, best_sol=None, best_MaxLI=None, best_MinLT=None, notebook=True):
    item_df, bom_df = prepare_df_for_messa(wb)
    item_name = list(item_df.iloc[:,0])
    net = pyvis.network.Network(height='500px', width='500px', directed = True, notebook = notebook, bgcolor='#ffffff', 
                                font_color=False, layout=True, heading='')
    pos = G.layout()
    level =[]
    for i in G.nodes():
        x,y = pos[i]
        level.append(x)

    for i in G.nodes():
        if best_sol is None:
            net.add_node(i, label=f"{item_name[i]}", level=level[i], shape="box", color="pink")
        else:
            if best_sol[i]==1:
                net.add_node(i, label=f"{item_name[i]}\n [{int(best_MaxLI[i])},{int(best_MinLT[i])}]", 
                             level=level[i], shape="box", color="pink")
            else:
                net.add_node(i, label=f"{item_name[i]}\n [{int(best_MaxLI[i])},{int(best_MinLT[i])}]", 
                             level=level[i], shape="box", color="yellow")
    for (i,j) in G.edges():
        net.add_edge(i,j, color="black")
    return net

# %% ../nbs/03inventory.ipynb 39
def ww(demand, fc =100., vc=0., h=5.):
    T = len(demand)
    fixed = np.full(T,fc) 
    variable = np.full(T,vc)
    hc = np.full(T,h)
    F = np.full(T, 99999999999.)

    prev =np.full(T,-1)
    for i in range(T):
        if i==0: 
            cum=fixed[i]+variable[i]*demand[i]
        else:
            cum=F[i-1]+fixed[i]+variable[i]*demand[i]
        cumh=0
        for j in range(i,T):
            if cum < F[j]:
                F[j] = cum
                prev[j] = i-1
            if j==(T-1): 
                break
            cumh += hc[j]
            cum += (variable[i]+cumh)*demand[j+1]

    #print("Optimal Value=", F[T-1])
    setup = np.zeros(T)
    j=T-1
    while j !=-1:
        i = prev[j]
        setup[i+1]=1
        j=i
    #print(setup)

    dem = 0
    order = np.zeros(T)
    for t in range(T-1,-1,-1):
        #print(t, demand[t])
        dem+=demand[t]
        if setup[t]==1:
            order[t] = dem
            dem = 0
            
    return F[T-1], order

# %% ../nbs/03inventory.ipynb 43
def best_distribution(data):
    
    def best_fit_distribution(data, bins=200):
        """Model data by finding best fit distribution to data"""
        # Distributions to check
        DISTRIBUTIONS = [        
            st.alpha,st.anglit,st.arcsine,st.beta,st.betaprime,st.bradford,st.burr,st.cauchy,st.chi,st.chi2,st.cosine,
            st.dgamma,st.dweibull,st.expon,st.exponnorm,st.exponweib,st.exponpow,st.f,st.fatiguelife,st.fisk,
            st.foldcauchy,st.foldnorm,st.genlogistic,st.genpareto,st.gennorm,st.genexpon,
            st.genextreme,st.gausshyper,st.gamma,st.gengamma,st.genhalflogistic,st.gompertz,st.gumbel_r,
            st.gumbel_l,st.halfcauchy,st.halflogistic,st.halfnorm,st.halfgennorm,st.hypsecant,st.invgamma,st.invgauss,
            st.invweibull,st.johnsonsb,st.johnsonsu,st.ksone,st.kstwobign,st.laplace,st.levy,
            st.logistic,st.loggamma,st.loglaplace,st.lognorm,st.lomax,st.maxwell,st.mielke,st.nakagami,st.ncx2,st.ncf,
            st.nct,st.norm,st.pareto,st.pearson3,st.powerlaw,st.powerlognorm,st.powernorm,st.rdist,st.reciprocal,
            st.rayleigh,st.rice,st.recipinvgauss,st.semicircular,st.t,st.triang,st.truncexpon,st.truncnorm,st.tukeylambda,
            st.uniform,st.vonmises,st.vonmises_line,st.wald,st.weibull_min,st.weibull_max,st.wrapcauchy
        ]
        #DISTRIBUTIONS = [   st.truncnorm ]  #テスト用
        # Best holders
        best_distribution = st.norm
        best_params = (0.0, 1.0)
        best_sse = np.inf

        # Estimate distribution parameters from data
        for distribution in DISTRIBUTIONS:

            y, x = np.histogram(data, bins=bins, density=True)
            x = (x + np.roll(x, -1))[:-1] / 2.0

            # Try to fit the distribution
            #if 1:
            try:
                # Ignore warnings from data that can't be fit
                with warnings.catch_warnings():
                    warnings.filterwarnings('ignore')

                    # fit dist to data
                    params = distribution.fit(data)

                    # Separate parts of parameters
                    arg = params[:-2]
                    loc = params[-2]
                    scale = params[-1]

                    # Calculate fitted PDF and error with fit in distribution
                    pdf = distribution.pdf(x, loc=loc, scale=scale, *arg)
                    sse = np.sum(np.power(y - pdf, 2.0))

                    #print(distribution.name, sse, params)

                    # identify if this distribution is better
                    if best_sse > sse > 0:
                        best_distribution = distribution
                        best_params = params
                        best_sse = sse
            except Exception:
                pass

        return (best_distribution.name, best_params)
    
    
    def make_pdf(dist, params, size=10000):
        """Generate distributions's Probability Distribution Function """

        # Separate parts of parameters
        arg = params[:-2]
        loc = params[-2]
        scale = params[-1]

        # Get sane start and end points of distribution
        start = dist.ppf(0.01, *arg, loc=loc, scale=scale) if arg else dist.ppf(0.01, loc=loc, scale=scale)
        end = dist.ppf(0.99, *arg, loc=loc, scale=scale) if arg else dist.ppf(0.99, loc=loc, scale=scale)

        # Build PDF and turn into pandas Series
        x = np.linspace(start, end, size)
        y = dist.pdf(x, loc=loc, scale=scale, *arg)
        pdf = pd.Series(y, x)

        return pdf, start, end 

    data_range = (data.min(), data.max())

    data = pd.Series(data)

    # Find best fit distribution
    best_fit_name, best_fit_params = best_fit_distribution(data, 200)
    best_dist = getattr(st, best_fit_name)
    #print(best_fit_name, best_fit_params )
    
    params = best_fit_params
    arg = params[:-2]
    loc = params[-2]
    scale = params[-1]
    frozon_dist = best_dist(loc=loc, scale=scale, *arg)

    # Make PDF with best params 
    pdf, start, end = make_pdf(best_dist, best_fit_params)
    
    D = [go.Histogram(x= data.values, histnorm="probability density", name="Data Histgram", nbinsx=200)]
    #print(end, data_range[1])
    #if end < data_range[1]*100.: #ちゃんと収束している
    if frozon_dist.pdf(0)<=10.:
        D.append(go.Scatter(x=pdf.index, y=pdf.values, name= "Best Fit Distribution"))
    fig = go.Figure(D)
    fig.update_layout(
        title_text='Best fit to demand distribution', # title of plot
        xaxis_title_text='demand', # xaxis label
        yaxis_title_text='probability(density)', # yaxis label
    )
#     bins = int(data_range[1]-data_range[0])
#     y,x= np.histogram(data, bins= bins)
#     if bins <=30:
#         x = x - 0.5 #ビンの範囲は [i,i+1) なので，左に0.5だけシフト（平均を合わせるため）
#     hist_dist = st.rv_histogram( (y,x) ).freeze()

    return fig, frozon_dist, best_fit_name, best_fit_params 

# %% ../nbs/03inventory.ipynb 48
def best_histogram(data, nbins = 50):
    
    data_range = (data.min(), data.max())
    data = pd.Series(data)
    bins = max(int(data_range[1]-data_range[0]),1)
    y,x= np.histogram(data, bins= min(bins,nbins) )
    if bins < 50:
        x = x - 0.5 #ビンの範囲は [i,i+1) なので，左に0.5だけシフト（平均を合わせるため）
    hist_dist = st.rv_histogram( (y,x) ).freeze()
    D = [go.Histogram(x= data.values, histnorm="probability density", name="Data Histgram", nbinsx=200)]

    start = hist_dist.ppf(0.01)
    end =  hist_dist.ppf(0.99)
    size =10000
    x = np.linspace(start, end, size)
    y = hist_dist.pdf(x)
    pdf = pd.Series(y, x)
    D.append(go.Scatter(x=pdf.index, y=pdf.values, name= "Best Fit Distribution"))
    return go.Figure(D), hist_dist

# %% ../nbs/03inventory.ipynb 57
def fit_demand(demand_df, cust_selected, prod_selected, agg_period="1d", nbins=50, L=1):
    """
    需要分布の推定（顧客と製品に対して）:リード時間Lを入力とし，その間の需要の分布を計算する必要がある！
    """
    try:
        demand_df.reset_index(inplace=True)
    except ValueError:
        pass
    demand_df["date"] = pd.to_datetime(demand_df["date"])
    demand_df.set_index("date", inplace=True)
    demand_grouped = demand_df.groupby(
        ["cust", "prod"]).resample(agg_period)["demand"].sum()

    dic = {}
    for c in cust_selected:
        for p in prod_selected:
            if (c,p) in demand_grouped:
                data = demand_grouped[c, p].values
                df = pd.Series(data)
                data = df.rolling(window=L).sum()[L-1:].values #L日前から直前までの需要の合計
                fig, best_dist, best_fit_name, best_fit_params = best_distribution(data)
                fig2, hist_dist = best_histogram(data, nbins = nbins)

                dic[c,p] = fig, fig2, best_dist, hist_dist, best_fit_name, best_fit_params 
            else:
                dic[c,p] = None
    return dic

# %% ../nbs/03inventory.ipynb 68
def eoq(K, d, h, b, r, c, theta, discount=None):

    if b is None:
        omega = 1.
    else:
        omega = b/(b+h)
    if discount is None:
        return np.sqrt(2*K*d/h/omega), np.sqrt(2*K*h*d*omega)
    else:
        if discount =="incremental":
            cost, Q =[], []
            for j in range(len(c)):
                Kj = K + (c[0] - c[j])*theta[j]
                Q.append( np.sqrt(2*d*Kj/(h+r*c[j])/omega) )
                cost.append(d*c[j] + np.sqrt(2*d*Kj*(h+r*c[j])*omega))
            jstar = np.argmin(np.array(cost))
            return  Q[jstar], cost[jstar]
        
        elif discount=="all":
            min_cost = np.inf
            q_star = None
            for j in range(len(c)):
                Q = np.sqrt(2*d*K/(h+r*c[j])/omega)
                if Q > theta[j]:
                    C = d*c[j] + np.sqrt(2*d*K*(h+r*c[j])*omega)
                    if min_cost > C:
                        min_cost = C
                        q_star = Q
                else:
                    C = d*c[j] + d*K/theta[j]+(h+r*c[j])*theta[j]/2.
                    if min_cost > C:
                        min_cost = C
                        q_star = theta[j]
            return  q_star, min_cost
        else:
            raise ValueError("No such discount option!")

# %% ../nbs/03inventory.ipynb 72
def simulate_inventory(n_samples = 1, n_periods = 10, mu = 100., sigma = 10., LT = 3,
                        Q = 300., R=100., b =100., h = 1., fc=10000., S = None):
    """
    (Q,R)方策と(s,S)方策による在庫シミュレーション
    """
    demand = np.maximum(np.random.normal(mu, sigma, (n_samples, n_periods)), 0.)
    I = np.zeros((n_samples, n_periods+1))
    fixed_cost = np.zeros((n_samples, n_periods+1))
    
    omega = b/(b+h)
    z = norm.ppf(omega)
    
    #[:, 0] = LT*mu + z*sigma*np.sqrt(LT)  #リード時間分の安全在庫量
    if LT ==0:
        I[:, 0] = 0.
        NI = mu
    else:
        if S is None:
            I[:, 0] = R
            NI = R-1
        else:
            I[:, 0] = R
            NI = R-1 # net inventory
    production = np.zeros((n_samples, n_periods+1)) 
    #production = np.full( (n_samples, LT), mu) #毎期平均分だけ発注してあるものと仮定
    cost = np.zeros((n_samples, n_periods))
    for t in range(1,n_periods):

        NI = NI - demand[:, t] 

        if S is None: #(Q,R)-policy            
            prod = np.where(NI < R, Q, 0.)
        else: #(s,S)-policy
            prod = np.where(NI < R, S-NI, 0.)
        fixed_cost[:,t] = np.where(NI < R, fc, 0.)
        production[:, t] = prod #生産量の更新
        NI = NI + production[:, t] #発注後在庫ポジション
        #在庫量の更新
        if t-LT>=0:
            I[:, t] = I[:, t-1] - demand[:, t] + production[:, t-LT]
        else:
            I[:, t] = I[:, t-1] - demand[:, t]
            
        #print(t,NI[0],I[0,t], demand[0,t])

    cost = np.where(I<0, -b*I, h*I) + fixed_cost #在庫・品切れ費用に固定費用を加える
    return np.sum(cost,axis=1)/n_periods, I

# %% ../nbs/03inventory.ipynb 77
def multi_stage_simulate_inventory(n_samples = 1, n_periods = 10, mu = 100., sigma = 10., LT = np.array([1, 1, 1]),
                        s= None , S = None, b =100., h = np.array([10., 5., 2.]), fc=10000.):
    """
    多段階ネットワークに対する(s,S)方策による在庫シミュレーション
    """
    # 初期エシェロン在庫量は、最終需要地点以外には、定期発注方策の1日分の時間を加えておく。
    ELT = np.zeros(n_stages,dtype=int)
    ELT[0] = LT[1]
    for i in range(1,n_stages):
        ELT[i] = ELT[i-1] + 1 + LT[i]
    #print("Echelon LT=", ELT)
    maxLT = LT.max()
    demand = np.maximum(np.random.normal(mu, sigma, (n_samples, n_periods)), 0.)
    I = np.zeros((n_samples, n_stages, n_periods+1)) #エシェロン在庫量
    T = np.zeros((n_samples, n_stages, n_periods+1)) #輸送中在庫量
    fixed_cost = np.zeros((n_samples, n_stages, n_periods+1))
    
    omega = b/(b+h)
    z = norm.ppf(omega)
    
    I[:,:, 0] = ELT[:]*mu + z[:]*sigma*np.sqrt(ELT[:])  #エシェロンリード時間分の安全在庫量
    NI = I[:,:,0]  # 正味在庫ポジション
    production = np.zeros((n_samples, n_stages, maxLT)) 
    cost = np.zeros((n_samples, n_periods))
    
    for t in range(n_periods):
        for i in range(n_stages):
            I[:, i, t+1] = I[:,i,t] - demand[:, t] + production[:,i,(t-LT[i]) % LT[i]]
            if i != n_stages-1:
                cap = np.maximum(I[:, i+1, t]-I[:, i, t]- T[:,i+1,t] , 0.) #i+1の実在庫量
                prod_temp = np.where(NI[:,i] < s[i], S[i]-NI[:,i], 0.)
                prod = np.minimum( prod_temp, cap)
            else:
                prod = np.where(NI[:,i] < s[i], S[i]-NI[:,i], 0.)
            T[:, i, t+1] = T[:, i, t] + prod  - production[:, i, (t-LT[i]) % LT[i]]  # 輸送中在庫量の更新
            fixed_cost[:,i,t] = np.where(NI[:,i] < s[i], fc, 0.)
            NI[:,i] = NI[:,i] - demand[:, t] + prod #在庫ポジション
            production[:,i, t % LT[i]] = prod 
    cost = np.where(I[:,0,:] <0, -b*I[:,0,:], h[0]*I[:,0,:]) + fixed_cost[:,0,:]
    for i in range(1, n_stages):
        cost+= np.where(I[:,i,:]<0, 0., (h[i-1]-h[i])*I[:,i,:])+ fixed_cost[:,i,:]

    return np.sum(cost,axis=1)/n_periods, I , T

# %% ../nbs/03inventory.ipynb 80
def optimize_qr(n_samples = 1, n_periods = 10, mu = 100., sigma = 10., LT = 3,
                Q = None, R = None, z = None, b =100., h = 1., fc=10000., alpha = 1.):
    """
    (Q,R)方策のパラメータ最適化
    """
    omega = b/(b+h)
    #print("臨界率=", omega)
    #print("安全在庫係数=", norm.ppf(omega) )
    z = norm.ppf(omega)

    if Q is None:
        Qhat = int(np.sqrt(2*fc*mu/h/omega)) #EOQ formula--ユーザーによって与えられていないとき
        #print("Qhat=",Qhat)
        if Qhat < mu :
            print("Use base stock policy!")
    else:
        Qhat = Q
        
    if R is None:
        Rhat = int(LT*mu+ z*sigma*np.sqrt(LT))  #z is derived by b and h
        s_appro, S_appro = approximate_ss(mu, sigma, LT, b, h, fc)
        Rhat = min(Rhat, int(s_appro))
        #print("Rhat=",Rhat)
        #Rの探索（Qhatが小さいとうまくいかない）
        c = []
        std = []
        min_cost = np.inf
        min_R = -1
        for R in range(Rhat,Rhat*10): #探索範囲 
            cost, I = simulate_inventory(n_samples =n_samples, n_periods =n_periods, mu=mu, sigma=sigma, LT=LT, Q=Qhat, R=R, b=b, h=h, fc=fc) 
            #print("R=",R, "cost=",cost.mean(), min_cost)
            if cost.mean() > min_cost:
                break
            c.append(cost.mean())
            std.append(cost.std())
            risk_cost = cost.mean() + alpha*cost.std()
            if min_cost > risk_cost:
                min_cost = risk_cost
                min_R = R
        #print("min cost=", min_cost, "min_R=", min_R)
        Rhat = min_R
    else:
        Rhat = R

    #Qの探索
    if Q  is None:
        min_Q = -1
        min_cost = np.inf
        c, std = [], []
        for Q in range(Qhat-10,Qhat*10): #探索範囲 
            #print("Q=",Q, "cost=",cost.mean(), min_cost)
            cost, I = simulate_inventory(n_samples =n_samples, n_periods =n_periods, mu=mu, sigma=sigma, LT=LT, Q=Q, R=Rhat, b=b, h=h, fc=fc) 
            c.append(cost.mean())
            std.append(cost.std())
            risk_cost = cost.mean() + alpha*cost.std()
            if cost.mean() > min_cost and Q>Qhat:
                break
            if min_cost>risk_cost:
                min_cost = risk_cost
                min_Q = Q
        #print("min cost=", min_cost, "R*=", Rhat, "Q*=", min_Q)
    return Rhat, min_Q

# %% ../nbs/03inventory.ipynb 85
def optimize_ss(n_samples = 1, n_periods = 10, mu = 100., sigma = 10., LT = 3,
                Q = None, R = None, z = None, b =100., h = 1., fc=10000., alpha = 1., S = None):
    """
    (s,S)方策のパラメータ最適化
    """
    omega = b/(b+h)
    #print("臨界率=", omega)
    #print("安全在庫係数=", norm.ppf(omega) )
    z = norm.ppf(omega)

    if Q is None:
        Qhat = int(np.sqrt(2*fc*mu/h/omega)) #EOQ formula--ユーザーによって与えられていないとき
        #print("Qhat=",Qhat)
        if Qhat < mu :
            print("Use base stock policy!")
    else:
        Qhat = Q
        
    if R is None:
        Rhat = int(LT*mu+ z*sigma*np.sqrt(LT))  #z is derived by b and h
        s_appro, S_appro = approximate_ss(mu, sigma, LT, b, h, fc)
        Rhat = min(Rhat, int(s_appro))
        #print("Rhat=",Rhat)
        #Rの探索（Qhatが小さいとうまくいかない）
        c = []
        std = []
        min_cost = np.inf
        min_R = -1
        for R in range(Rhat-10,Rhat*10): #探索範囲 
            cost, I = simulate_inventory(n_samples =n_samples, n_periods =n_periods, mu=mu, sigma=sigma, LT=LT, Q=Qhat, R=R,  b=b, h=h, fc=fc, S=R+Qhat) 
            if cost.mean() > min_cost and R >= Rhat+10:
                break
            c.append(cost.mean())
            std.append(cost.std())
            risk_cost = cost.mean() + alpha*cost.std()
            if min_cost > risk_cost:
                min_cost = risk_cost
                min_R = R
        #print("min cost=", min_cost, "min_R=", min_R)
        Rhat = min_R
    else:
        Rhat = R

    #Sの探索
    if S is None:
        min_S = -1
        min_cost = np.inf
        c, std = [], []
        for S in range(min_R+Qhat-10,min_R+Qhat*10): #探索範囲 
            #print("Q=",Q, "cost=",cost.mean(), min_cost)
            cost, I = simulate_inventory(n_samples =n_samples, n_periods =n_periods, mu=mu, sigma=sigma, LT=LT, Q=Q, R=Rhat,  b=b, h=h, fc=fc, S=S) 
            c.append(cost.mean())
            std.append(cost.std())
            risk_cost = cost.mean() + alpha*cost.std()
            if cost.mean() > min_cost and S>min_R+Qhat:
                break
            if min_cost>risk_cost:
                min_cost = risk_cost
                min_S = S
        #print("min cost=", min_cost, "R*=", Rhat, "S*=", min_S)
    return Rhat, min_S

# %% ../nbs/03inventory.ipynb 90
def approximate_ss(mu = 100., sigma = 10., LT = 0, b =100., h = 1., fc=10000.):
    sigmaL = sigma*np.sqrt(LT+1)+0.000001
    muL = mu*(LT+1)
    Q = 1.3 * mu**0.494*(fc/h)**0.506*(1+sigmaL**2/mu**2)**0.116
    z =np.sqrt(Q*h/sigmaL/b)+0.0000001
    s = 0.973*muL + sigmaL*(0.183/z+1.063-2.192*z)
    S = s+Q
    
    if Q<=mu*1.5: 
        omega = b/(b+h)
        z = norm.ppf(omega)
        S0 = muL+ z*sigmaL 
        s = min(s, S0)
        S = min(s+Q,S0)
    return s, S

# %% ../nbs/03inventory.ipynb 108
def base_stock_simulation(n_samples, n_periods, demand, capacity, LT, b, h, S):
    """
    単一段階在庫システムの定期発注方策に対するシミュレーションと微分値の計算
    """
    I = np.zeros((n_samples, n_periods+1))
    T = np.zeros((n_samples, n_periods+1))

    I[:, 0] = S  # initial inventory
    production = np.zeros((n_samples, LT))
    
    #以下の方法で初期化するには，輸送中在庫量も定義しなければならない．
    #mu = np.mean(demand)
    #I[:, 0] = max(S - mu*LT, 0) 
    #production = np.full( (n_samples, LT), mu)
    sum_dC = 0.
    for t in range(n_periods):
        I[:, t+1] = I[:, t] - demand[:, t] + \
            production[:, (t-LT) % LT]  # 在庫量の更新
        prod = np.minimum(capacity, S+demand[:, t]-I[:, t]-T[:, t])  # 生産量の計算

        #print(t,demand[:,t],I[:,t],ITI[:,t],prod,production[:, (t-LT) % LT])

        T[:, t+1] = T[:, t] + prod - production[:, (t-LT) % LT]  # 輸送中在庫量の更新
        production[:, t % LT] = prod  # 生産量の更新

        dC = np.where(I[:, t] < 0, -b, h)
        sum_dC += dC.sum()

    total_cost = (-1*b*I[I < 0].sum() + h*I[I > 0].sum())/n_periods/n_samples
    return sum_dC/n_samples/n_periods, total_cost, I

# %% ../nbs/03inventory.ipynb 109
def base_stock_simulation_using_dist(n_samples, n_periods, demand, capacity, LT, b, h, S):
    """
    単一段階在庫システムの定期発注方策に対するシミュレーションと微分値の計算
    """
    I = np.zeros((n_samples, n_periods+1))
    T = np.zeros((n_samples, n_periods+1))
    I[:, 0] = S  # initial inventory
    production = np.zeros((n_samples, LT))
    sum_dC = 0.
    for t in range(n_periods):
        I[:, t+1] = I[:, t] - demand[:, t] + \
            production[:, (t-LT) % LT]  # 在庫量の更新
        prod = np.minimum(capacity, S+demand[:, t]-I[:, t]-T[:, t])  # 生産量の計算

        #print(t,demand[:,t],I[:,t],ITI[:,t],prod,production[:, (t-LT) % LT])

        T[:, t+1] = T[:, t] + prod - production[:, (t-LT) % LT]  # 輸送中在庫量の更新
        production[:, t % LT] = prod  # 生産量の更新

        dC = np.where(I[:, t] < 0, -b, h)
        sum_dC += dC.sum()

    total_cost = (-1*b*I[I < 0].sum() + h*I[I > 0].sum())/n_periods/n_samples
    return sum_dC/n_samples/n_periods, total_cost, I

# %% ../nbs/03inventory.ipynb 119
def multi_stage_base_stock_simulation(n_samples, n_periods, demand, capacity, LT, b, h, S):
    """
    多段階在庫システムの定期発注方策に対するシミュレーションと微分値の計算
    """

    maxLT = LT.max()
    #print("maxLT=", maxLT)
    # 在庫量
    I = np.zeros((n_samples, n_stages, n_periods+1))
    T = np.zeros((n_samples, n_stages, n_periods+1))
    for i in range(n_stages):
        if i == 0:
            I[:, i, 0] = S[i]
        else:
            I[:, i, 0] = S[i]-S[i-1]  # initial inventory
    #print("Initial Inventory =", I[:, :, 0])
    # 微分値
    dI = np.zeros((n_samples, n_stages, n_stages, n_periods+1))
    dT = np.zeros((n_samples, n_stages, n_stages, n_periods+1))
    for i in range(n_stages):
        dI[:, i, i, 0] = 1
        if i!=0:
            dI[:, i, i-1, 0] = -1

    dProd = np.zeros((n_samples, n_stages, n_stages, maxLT))
    production = np.zeros((n_samples, n_stages, maxLT))
    T[:, :, 0] = production[:, :].sum(axis=2)  # initial in-transit inventory

    prod = {}  # 生産量の一時保管用の辞書
    for t in range(n_periods):
        EI = (I[:, :, t]+T[:, :, t]).cumsum(axis=1)  # echelon inventory
        dEI = (dI[:, :, :, t]+dT[:, :, :, t]).cumsum(axis=1)
        for i in range(n_stages):
            if i != n_stages-1:
                cap = I[:, i+1, t].copy()
                # 生産量の計算
                prod[i] = np.minimum(capacity[i], S[i]+demand[:, t]-EI[:, i])
                prod[i] = np.minimum(prod[i], cap)
            else:
                prod[i] = np.minimum(capacity[i], S[i]+demand[:, t]-EI[:, i])
                #print("production=", prod[i],EI[:, i])

            # 生産量の微分値の計算
            for j in range(n_stages):
                if i == j:
                    dProd[:, i, j, t % LT[i]] = 1. - dEI[:, i, j]
                else:
                    dProd[:, i, j, t % LT[i]] = - dEI[:, i, j]
                dProd[:, i, j, t % LT[i]] = np.where((prod[i] == 0.) | (
                    prod[i] == capacity[i]), 0., dProd[:, i, j, t % LT[i]])
                if i != n_stages-1:
                    dProd[:, i, j, t % LT[i]] = np.where(
                        (prod[i] == cap), dI[:, i+1, j, t], dProd[:, i, j, t % LT[i]])

        for i in range(n_stages):
            T[:, i, t+1] = T[:, i, t] + prod[i] - \
                production[:, i, (t-LT[i]) % LT[i]]  # 輸送中在庫量の更新

        I[:, 0, t+1] = I[:, 0, t] - demand[:, t] + \
            production[:, 0, (t-LT[0]) % LT[0]]   # 在庫量の更新(stage 0)

        for i in range(1, n_stages):
            I[:, i, t+1] = I[:, i, t] - prod[i-1] + \
                production[:, i, (t-LT[i]) % LT[i]]  # 在庫量の更新(stages 1..)

        for i in range(n_stages):
            production[:, i, t % LT[i]] = prod[i]  # 生産量の更新

        #print(t, demand[:, t], I[:, :, t],I[:, :, t+1], T[:, :, t], prod)

        # 微分値の更新
        for i in range(n_stages):
            for j in range(n_stages):
                if i != 0:
                    dI[:, i, j, t+1] = dI[:, i, j, t] - dProd[:, i-1, j, t %
                                                              LT[i]] + dProd[:, i, j, (t-LT[i]) % LT[i]]
                else:
                    dI[:, i, j, t+1] = dI[:, i, j, t] + \
                        dProd[:, i, j, (t-LT[i]) % LT[i]]

                dT[:, i, j, t+1] = dT[:, i, j, t] + dProd[:, i, j, t %
                                                          LT[i]] - dProd[:, i, j, (t-LT[i]) % LT[i]]

    total = -b*I[:, 0, :][I[:, 0, :] < 0].sum() + h[0] * \
        I[:, 0, :][I[:, 0, :] > 0].sum()
    total += h[0]*T[:, 0, :].sum()
    for i in range(1, n_stages):
        total += h[i]*(I[:, i, :] + T[:, i, :]).sum()
    total_cost = total/n_samples/n_periods

    dC = np.zeros(n_stages)  # derivative
    for j in range(n_stages):
        total = np.where(I[:, 0, :] < 0, -b*dI[:, 0, j, :],
                         h[0]*dI[:, 0, j, :]).sum()
        for i in range(n_stages):
            #total += h[i]*( dI[:,i,j,:] + dT[:,i-1,j,:]).sum()
            if i == 0:
                total += h[i]*dT[:, i, j, :].sum()
            else:
                total += h[i]*(dI[:, i, j, :] + dT[:, i, j, :]).sum()
        dC[j] = total/n_samples/n_periods

    return dC, total_cost, I  #, dI, dT, dProd

# %% ../nbs/03inventory.ipynb 129
def network_base_stock_simulation(G, n_samples, n_periods, demand, capacity, LT, ELT, b, h, S, phi, alpha):
    """
    ネットワーク型定期発注方策に対するシミュレーションと微分値の計算
    """
    maxLT = int(LT.max())
    #print("maxLT=", maxLT)

    #点のラベルの付け替え
    mapping ={i:idx for idx,i in enumerate(G)}
    G = nx.relabel_nodes(G, mapping=mapping, copy=True)

    n_stages = len(G)
    # 在庫量
    I = np.zeros((n_samples, n_stages, n_periods+1))
    # 輸送中在庫量
    T = np.zeros((n_samples, n_stages, n_periods+1))
    # エシェロン在庫量（ローカル保存用）
    EI = np.zeros((n_samples, n_stages))
    # 初期在庫量: todo 子孫の需要の安全分の和で十分？ 輸送中在庫を定義しないとダメ！
    for i in G:
        init_ = S[i]
        for j in G.successors(i):
            # rint(j,S[j],phi[i,j])
            init_ -= phi[i, j]*S[j]
        I[:, i, 0] = init_  # initial inventory
    #print("Initial Inventory =", I[:, :, 0])
    
    #エシェロン在庫費用
#     echelon_h = np.zeros(len(G))
#     for i in G:
#         echelon_h[i] = h[i] 
#         for j in G.predecessors(i):
#             echelon_h[i] -= phi[j, i]*h[j]
    #print("Echelon Holding Cost", echelon_h)        

    # 微分値
    dI = np.zeros((n_samples, n_stages, n_stages, n_periods+1))
    dT = np.zeros((n_samples, n_stages, n_stages, n_periods+1))
    # エシェロン在庫の微分値（ローカル保存用）
    dEI = np.zeros((n_samples, n_stages, n_stages))
    for i in G:
        dI[:, i, i, 0] = 1
        for j in G.successors(i):
            dI[:, i, j, 0] = -phi[i, j]

    dProd = np.zeros((n_samples, n_stages, n_stages, maxLT))
    production = np.zeros((n_samples, n_stages, maxLT))
    # 生産量が0でない場合には、以下を生かす
    # T[:, :, 0] = production[:, :].sum(axis=2)  # initial in-transit inventory

    prod = {}  # 生産量の一時保管用の辞書
    dummy = np.zeros(n_samples)  # 後続点の生産量の一時保管用
    min_inv_dic = {}  # 先行点の最小在庫量の一時保管用
    for t in range(n_periods):
        # エシェロン在庫量の計算
        for i in G.up_order():
            if G.out_degree(i) == 0:  # demand point
                EI[:, i] = I[:, i, t] + T[:, i, t] - demand[i][:, t]
                dEI[:, i, :] = dI[:, i, :, t] + dT[:, i, :, t]
            else:
                EI[:, i] = I[:, i, t] + T[:, i, t]
                dEI[:, i, :] = dI[:, i, :, t] + dT[:, i, :, t]
                for j in G.successors(i):
                    EI[:, i] += phi[i, j]*EI[:, j]
                    dEI[:, i, :] += phi[i, j] * dEI[:, j, :]
        #print("Echelon Inventory=",EI)
        # print("Inventory=",I[:,:,t])
    #    dEI = (dI[:, :, :, t]+dT[:, :, :, t]).cumsum(axis=1)
        # 生産量の計算
        for i in G:
            prod[i] = np.minimum(capacity[i], S[i]-EI[:, i])
            # 先行点の最小在庫割当量を計算
            for j in G.predecessors(i):
                prod[i] = np.minimum(I[:, j, t]*alpha[j, i]/phi[j, i], prod[i])
            #prod[i] = np.maximum(prod[i], 0.)
            #print("production=",i, prod[i],S[i],EI[:, i])

            # 生産量の微分値の計算
            for j in G:
                if i == j:
                    dProd[:, i, j, t % LT[i]] = 1. - dEI[:, i, j]
                else:
                    dProd[:, i, j, t % LT[i]] = - dEI[:, i, j]
                dProd[:, i, j, t % LT[i]] = np.where((prod[i] == 0.) | (
                    prod[i] == capacity[i]), 0., dProd[:, i, j, t % LT[i]])

                for k in G.predecessors(i):
                    dProd[:, i, j, t % LT[i]] = np.where(
                        (I[:, k, t]*alpha[k, i]/phi[k, i] == prod[i]), alpha[k, i]*dI[:, k, j, t], dProd[:, i, j, t % LT[i]])

        for i in G:
            T[:, i, t+1] = T[:, i, t] + prod[i] - \
                production[:, i, (t-LT[i]) % LT[i]]  # 輸送中在庫量の更新
        for i in G:
            if G.out_degree(i) == 0:
                I[:, i, t+1] = I[:, i, t] - demand[i][:, t] + \
                    production[:, i, (t-LT[i]) % LT[i]]   # 在庫量の更新(需要地点)
            else:
                dummy = np.zeros(n_samples)
                for j in G.successors(i):
                    dummy += prod[j]*phi[i, j]
                # print("dummy=",dummy)
                I[:, i, t+1] = I[:, i, t] - dummy + \
                    production[:, i, (t-LT[i]) % LT[i]]  # 在庫量の更新（その他の地点）

        for i in G:
            production[:, i, t % LT[i]] = prod[i]  # 生産量の更新

        #print(t, I[:, :, t],I[:, :, t+1], T[:, :, t+1], production)

        # 微分値の更新
        for i in range(n_stages):
            for j in range(n_stages):
                d_dummy = np.zeros(n_samples)
                for k in G.successors(i):
                    d_dummy += phi[i, k]*dProd[:, k, j, t % LT[i]]

                dI[:, i, j, t+1] = dI[:, i, j, t] - d_dummy + \
                    dProd[:, i, j, (t-LT[i]) % LT[i]]

                dT[:, i, j, t+1] = dT[:, i, j, t] + dProd[:, i, j, t %
                                                          LT[i]] - dProd[:, i, j, (t-LT[i]) % LT[i]]
    #最大リード時間を慣らし期間とする．
    total = 0.
    for i in G:
        total += -b[i]*I[:, i, maxLT:][I[:, i, maxLT:] < 0].sum() + h[i] * \
            I[:, i, maxLT:][I[:, i, maxLT:] > 0].sum() + h[i]*T[:, i, maxLT:].sum()
    total_cost = total/n_samples/max((n_periods-maxLT),1)
    #print("total cost=", total_cost)

    dC = np.zeros(n_stages)  # derivative
    for j in range(n_stages):  # compute dC/dSi^*
        total = 0.
        for i in range(n_stages):
            total += np.where(I[:, i, maxLT:] < 0, -b[i]*dI[:, i, j, maxLT:],
                              h[i]*dI[:, i, j, maxLT:]).sum()
            total += h[i]*(dT[:, i, j, maxLT:]).sum()
        dC[j] = total/n_samples/max((n_periods-maxLT),1)

    return dC, total_cost, I

# %% ../nbs/03inventory.ipynb 131
def initial_base_stock_level(G, LT, mu, z, sigma):
    '''
    初期基在庫レベルとエシェロンリード時間の計算
    '''
    ELT = np.zeros(len(G))
    for i in G.up_order():
        if G.out_degree(i) == 0:
            ELT[i] = LT[i]  #最終需要地点では，次の在庫地点のための在庫をもつ必要がない
        else:
            max_succ_LT = 0
            for j in G.successors(i):
                max_succ_LT = max(ELT[j], max_succ_LT)
            ELT[i] = max_succ_LT+LT[i]+1 # 下流の地点のために，サイクル時間分（1日）を加える
    S = ELT*mu + z*sigma * np.sqrt(ELT)
    return ELT, S

# %% ../nbs/03inventory.ipynb 145
#| include: false
#| include: false
# def base_stock_prophet(demand_df, agg_period="1d", forecast_periods=1):
#     try:
#         demand_df.reset_index(inplace=True)
#     except:
#         pass
#     demand_df["date"] = pd.to_datetime(demand_df["date"])
#     demand_df.set_index("date", inplace=True)
#     demand_grouped = demand_df.groupby(
#         ["cust", "prod"]).resample(agg_period)["demand"].sum()
#     n_periods = forecast_periods-1

#     LT = 1
#     z = 1.65
#     b, h = 100, 1
#     capacity = 1000000.
#     convergence = 1e-5

#     dic = {}
#     idx = 0
#     for c in set(demand_df["cust"]):
#         for p in set(demand_df["prod"]):
#             model = Prophet(interval_width=0.95, daily_seasonality=False,
#                             weekly_seasonality=False, yearly_seasonality=False)
#             model.uncertainty_samples = 1000  # サンプル数を設定
#             n_samples = model.uncertainty_samples
#             print(c, p)
#             try:
#                 df = pd.DataFrame(demand_grouped[c, p].cumsum())
#                 df.reset_index(inplace=True)
#                 df.rename(columns={"date": "ds", "demand": "y"}, inplace=True)
#                 model.fit(df)
#                 # future = model.make_future_dataframe(
#                 #    periods=forecast_periods, freq=agg_period)
#                 # forecast = model.predict(future)
#                 # 定常需要を仮定した場合の最大需要量
#                 dem = df.y.diff()
#                 mu, sigma = dem[1:].mean(), dem[1:].std()
#                 # 在庫最適化
#                 S = mu*LT + z*sigma*np.sqrt(LT)
#                 future = model.make_future_dataframe(periods=forecast_periods, freq=agg_period,include_history=False)
#                 sample = model.predictive_samples(future)  # サンプルを生成
#                 demand = np.maximum(
#                     sample["yhat"][1:, :]-sample["yhat"][:-1, :], 0.)
#             except:
#                 print("Prophet Error while computing for", c, p)
#                 continue

#             for iter_ in range(100):
#                 dC, cost, I = base_stock_simulation(
#                     n_samples, n_periods, demand.T, capacity, LT, b, h, S)
#                 S = S - 0.1*dC
#                 # print(f"{iter_}: {S:.2f} {dC:.3f} {cost:.2f}")
#                 if dC**2 <= convergence:
#                     break

#             # print(stationary_max_demand, max_demand)
#             dic[idx] = [c, p, mu, sigma, S, cost]
#             idx += 1


#     base_stock_df = pd.DataFrame.from_dict(dic, orient='index',
#                 columns=["cust", "prod", "mean", "std", "S", "cost"])
#     return base_stock_df

# %% ../nbs/03inventory.ipynb 156
def max_demand_compute(G, ProcTime, LTLB, LTUB, z, mu, sigma, h):
    '''
    computing the max demand for t days and the safety stock cost when the net reprenishment time is t (t=0,...,MaxNRT(i))
       This function is used in the safety stock allocation problem.
       Current verstion assumes that the demand has a normal distribution.
       retuen Lmax (maximum net reprenishment time +1), MaxDemand, SafetyCost
    '''
    mu = mu.reshape((-1, 1))
    sigma = sigma.reshape((-1, 1))
    h = h.reshape((-1, 1))

    MaxNRT = np.zeros(len(G))

    Lmax = 0
    for v in G.down_order():
        if G.in_degree(v) == 0:
            MaxNRT[v] = ProcTime[v]
        else:
            # compute the max inbound (guaranteed lead) time
            MaxGLT = 0
            for w in G.predecessors(v):
                tmp = min(MaxNRT[w], LTUB[w])  # +arc1.Time
                if tmp > MaxGLT:
                    MaxGLT = tmp
            MaxNRT[v] = MaxGLT+ProcTime[v]
            Lmax = max(Lmax, MaxNRT[v])

    Lmax = Lmax+1
    LmaxArray = np.arange(0,Lmax)
    LmaxArray = LmaxArray.reshape(1,-1)
    LTUB = np.minimum(LTUB, Lmax-1)
    MaxDemand = mu*LmaxArray + z*sigma*np.sqrt(LmaxArray)
    SafetyCost = h*z*sigma*np.sqrt(LmaxArray)

    return int(Lmax), MaxDemand, SafetyCost

# %% ../nbs/03inventory.ipynb 160
def dynamic_programming_for_SSA(G, ProcTime, LTLB, LTUB, z, mu, sigma, h):
    '''
    Solve the safety stock allocation problem by the dynamic programming algorithm.
        The network should be a tree.
        The algorithm is based on:

        @incollection{Graves2003,
        author={S. C. Graves and  S. Willems},
        title={Supply Chain Design: Safety Stock Placement and Supply Chain Configuratation},
        year={2003},
        volume={11},
        pages={95--132},
        editor={A. G. {de} Kok and S.C. Graves},
        publisher={Elsevier},
        series={Handbook in Operations Research and Management Science},
        chapter={3},
        booktitle={Supply Chain Management: {D}esign, Coordination and Operation},
        annote={ }
        }
    '''
    assert nx.is_tree(G.to_undirected())
    assert nx.is_directed_acyclic_graph(G)

    Infinity = 1.e10000
    Lmax, MaxDemand, SafetyCost = max_demand_compute(G, ProcTime, LTLB, LTUB, z, mu, sigma, h)

    f = defaultdict(lambda :Infinity)
    g = defaultdict(lambda :Infinity)
    fmin = defaultdict(lambda :Infinity)
    gmin = defaultdict(lambda :Infinity)
    c = defaultdict(lambda :Infinity)

    LIstar = defaultdict(lambda :0)
    Lstar = defaultdict(lambda :0)
    minL = defaultdict(lambda :0)
    minLI = defaultdict(lambda :0)
    NRT = defaultdict(lambda :0)

    Searched = set([])
    for k in G.dp_order():
        Searched.add(k)
        for L in range(LTLB[k], LTUB[k]+1):
            for LI in range(Lmax):
                if LI+ProcTime[k]-L >= 0 and LI+ProcTime[k]-L < Lmax:
                    sumCost = SafetyCost[k, LI+ProcTime[k]-L]
                    for i in G.predecessors(k):
                        if (i in Searched):
                            if LI >= 0:
                                sumCost += fmin[i, LI]
                            else:
                                sumCost = 999999.0
                                break
                    for j in G.successors(k):
                        if j in Searched:
                            if L < Lmax:
                                # sumCost+=gmin[j,L+arc1.Time]
                                sumCost += gmin[j, L]
                            else:
                                sumCost = 999999.0
                                break
                    c[k, L, LI] = sumCost

        for L in range(LTLB[k], LTUB[k]+1):
            minCost = 999999.0
            for LI in range(Lmax):
                if LI+ProcTime[k]-L >= 0 and LI+ProcTime[k]-L < Lmax:
                    if c[k, L, LI] < minCost:
                        minCost = c[k, L, LI]
                        minLI[k, L] = LI
            f[k, L] = minCost
        for L in range(LTLB[k], Lmax):
            minCost = f[k, L]
            for x in range(LTLB[k], L):
                if minLI[k, x]+ProcTime[k]-x >= 0:
                    if f[k, x] < minCost:
                        minCost = f[k, x]
                        minLI[k, L] = minLI[k, x]
            fmin[k, L] = minCost

        for LI in range(Lmax):
            minCost = 999999.0
            for L in range(LTLB[k], LTUB[k]+1):
                if LI+ProcTime[k]-L >= 0 and LI+ProcTime[k]-L < Lmax:
                    if c[k, L, LI] < minCost:
                        minCost = c[k, L, LI]
                        minL[k, LI] = L
            g[k, LI] = minCost
        for LI in range(Lmax):
            if g[k, LI] < 999999.0:
                minCost = 999999.0
                for x in range(LI, Lmax):
                    if x+ProcTime[k]-minL[k, x] >= 0:
                        if g[k, x] < minCost:
                            minCost = g[k, x]
                            minL[k, LI] = minL[k, x]
                gmin[k, LI] = minCost
            else:
                gmin[k, LI] = 999999.0

    # construct an optimal solution by traversing nodes in the reverse order of DP recursion
    reverse_order = []
    for k in G.dp_order():
        reverse_order.append(k)
    reverse_order.reverse()

    for i in G:
        Lstar[i] = -1
        LIstar[i] = -1

    Searched = set([])
    for i in reverse_order:
        Searched.add(i)
        if LIstar[i] >= 0:
            minCost = 999999.0
            LI = LIstar[i]
            for L in range(LTLB[i], LTUB[i]+1):
                if LI+ProcTime[i]-L >= 0 and LI+ProcTime[i]-L < Lmax:
                    if c[i, L, LI] < minCost:
                        minCost = c[i, L, LI]
                        Lstar[i] = L
            # print i,Lstar[i],LIstar[i],minCost
        elif Lstar[i] >= 0:
            L = Lstar[i]
            minCost = 999999.0
            for LI in range(Lmax):
                if LI+ProcTime[i]-L >= 0 and LI+ProcTime[i]-L < Lmax:
                    if c[i, L, LI] < minCost:
                        minCost = c[i, L, LI]
                        LIstar[i] = LI
            # print i,Lstar[i],LIstar[i],minCost
        else:
            minCost = 999999.0
            for LI in range(Lmax):
                for L in range(LTLB[i], LTUB[i]+1):
                    if LI+ProcTime[i]-L >= 0 and LI+ProcTime[i]-L < Lmax:
                        if c[i, L, LI] < minCost:
                            minCost = c[i, L, LI]
                            Lstar[i] = L
                            LIstar[i] = LI
            # print i,Lstar[i],LIstar[i],minCost

        # inform L and LI to the adjacent nodes
        for  k in G.successors(i):
            if (k not in Searched):
                LIstar[k] = Lstar[i]
        for k in G.predecessors(i):
            if (k not in Searched):
                Lstar[k] = LIstar[i]
    # cost and NRT caluculate

    # print Lstar,LIstar,LIstar+ProcTime-Lstar
    for i in G:
        NRT[i] = LIstar[i]+ProcTime[i]-Lstar[i]
    #print ("Net Reprenishment Time=", NRT )
    #print ("Lstar=", Lstar )
    #print "Proc Time=", ProcTime
    total_cost=0.0
    for i in G:
        total_cost+=SafetyCost[i,NRT[i]]
    #print ("Total Cost",total_cost)
    #CurrentCost, ZeroLTCost = self.CostEvaluate(SafetyCost, NRT, ProcTime)
    #print "Opt=", CurrentCost
    #print "Zero Lead Time Cost=", ZeroLTCost
    return total_cost, Lstar, NRT

# %% ../nbs/03inventory.ipynb 168
def tabu_search_for_SSA(G, ProcTime, LTUB, z, mu, sigma, h, max_iter = 100, TLLB =1, TLUB =10, seed = 1):
    """
    一般のネットワークの安全在庫配置モデルに対するタブー探索（mu未使用；NRT日の最大在庫量をシミュレーションもしくは畳み込みによって事前計算？もしくは正規分布で近似）
    """
    #max_iter = 10
    #TLLB, TLUB = 2,10  # tabu length is a random number between (TLLB, TLUB)

    assert nx.is_directed_acyclic_graph(G)

    #点のラベルの付け替え
    mapping ={i:idx for idx,i in enumerate(G)}
    G = nx.relabel_nodes(G, mapping=mapping, copy=True)

    n = len(G)

    np.random.seed(seed)
    b = np.random.randint(0,2,n)# random 0-1 vector

    candidate = []  #探索候補のリストを準備
    for i in G:
        if G.out_degree(i)==0:
            b[i] = 1  #demand point always has inventory
        else:
            candidate.append(i)

    m = len(candidate) #近傍解の個数

    NRT = np.zeros(n)
    MaxLI = np.zeros(n)
    MinLT =np.zeros(n)
    # 全ての近傍を同時に評価するための多次元配列
    vNRT = np.zeros((m,n))  #正味補充時間
    vMaxLI = np.zeros((m,n)) #最大入庫リード時間
    vMinLT = np.zeros((m,n)) #最小保証リード時間

    TabuList = np.zeros(m, int)

    # 初期解の評価
    for i in G.down_order():
        if G.in_degree(i) == 0:
            MaxLI[i] = ProcTime[i]  #LTLB + ProcTime[i]
        else:
            max_ = 0.
            for k in G.predecessors(i):
                max_ = max(max_, (1-b[k])*MaxLI[k])
            MaxLI[i] = ProcTime[i] + max_
    #print("MaxLI=",MaxLI)

    for i in G.up_order():
        if G.out_degree(i)==0:
            MinLT[i] = LTUB[i]  #需要地点のリード時間は０と仮定？
        else:
            min_ = np.inf
            for j in G.successors(i):
                min_ = min( min_, NRT[j]+MinLT[j] -ProcTime[j] )
            MinLT[i] = min_
        NRT[i] = max( MaxLI[i]-MinLT[i], 0)

    cost = (h*z*sigma*np.sqrt(NRT)).sum() #h * dist.ppt(ssr) に変更！
    print("cost=",cost,b)

    #最良解の保存
    best_cost = cost
    prev_cost = cost
    best_sol = b.copy()
    b_prev = b.copy() #直前の解を保存
    best_NRT = NRT.copy()
    best_MaxLI = MaxLI.copy()
    best_MinLT = MinLT.copy()

    # タブー探索
    ltm_factor = 0. #長期メモリの係数
    ltm_increase = cost/float(n*max_iter)/10.
    ltm = np.zeros(m, int) #移動に選ばれた回数（長期メモリ）

    #print("iter cost TLLB TLUB LTM")
    for iter_ in range(max_iter):

        #近傍解の構築
        B = [ ]
        for i in candidate:
            newb = b.copy()
            newb[i] = 1-b[i] #ビット反転
            B.append(newb)
        B = np.array(B)

        for i in G.down_order():
            if G.in_degree(i) == 0:
                vMaxLI[:,i] = ProcTime[i]  #LTLB + ProcTime[i]
            else:
                max_ = np.zeros(m)
                for k in G.predecessors(i):
                    max_ = np.maximum(max_, (1-B[:,k])*vMaxLI[:,k])
                vMaxLI[:,i] = ProcTime[i] + max_
        #print("MaxLI=",vMaxLI)

        for i in G.up_order():
            if G.out_degree(i)==0:
                vMinLT[:,i] = LTUB[i]
            else:
                min_ = np.full(m, np.inf )
                for j in G.successors(i):
                    min_ = np.minimum( min_, vNRT[:,j]+vMinLT[:,j] -ProcTime[j] )
                vMinLT[:,i] = min_
            vNRT[:,i] = np.maximum(vMaxLI[:,i]-vMinLT[:,i], 0)

        cost = (h*z*sigma*np.sqrt(vNRT[:,:])).sum(axis=1)

        #istar = cost.argmin()
        min_ = np.inf 
        istar = -1
        for i in range(m):
            if iter_ >= TabuList[i]:
                if cost[i] + ltm_factor*ltm[i] < min_ :
                    min_ = cost[i] + ltm_factor*ltm[i]
                    istar = i
            else:
                #tabu check the aspiration level
                if cost[i] < best_cost:
                    if cost[i] < min_ :
                        min_ = cost[i]
                        istar = i

        if istar==-1:
            #print("Tabu List Clear!")
            TLLB =max(TLLB -1, 1)
            TLUB =max(TLUB -1, 2)
            TabuList = np.zeros(m, int)
        else:
            b = B[istar]
            ltm[istar] +=1
            if np.all(b_prev == b): # same solution => increase Tabu Length
                #print("Tabu Length increase!")
                TLLB +=1
                TLUB +=1
            elif prev_cost==cost[istar]: #same solution value => plateau => increase long term memory
                ltm_factor += ltm_increase

            b_prev = b.copy()
            prev_cost = cost[istar]
            TabuList[istar] = iter_ + np.random.randint(TLLB,TLUB+1)
            if cost[istar] < best_cost:
                best_cost = cost[istar]
                best_sol = B[istar].copy()
                best_NRT = vNRT[istar].copy()
                best_MaxLI = vMaxLI[istar].copy()
                best_MinLT = vMinLT[istar].copy()
            #print(iter_, round(cost[istar],3), TLLB, TLUB, round(ltm_factor,4) )  #,B[istar])
    # 在庫のない（正味補充時間が0の）地点のビットを0にする．
    for i in range(n):
        if best_NRT[i]<=0.00001:
            best_sol[i] = 0

    return best_cost, best_sol, best_NRT, best_MaxLI, best_MinLT

# %% ../nbs/03inventory.ipynb 181
def read_willems(file_name):
    """
    Willemsのベンチマーク問題例の読み込み関数
    """
    G = SCMGraph()
    tree = ET.parse(file_name)
    root = tree.getroot()
    for child in root:
        if child.tag=="stages":
            for c in child:
                attr = c.attrib
                G.add_node(attr["stageName"], **attr)
        elif child.tag=="arcs":
            for c in child:
                attr = c.attrib
                G.add_edge(attr["from"], attr["to"], weight=1)
        else:
            print("Error")
    xpos = nx.get_node_attributes(G, "xPos")
    ypos = nx.get_node_attributes(G, "yPos")
    pos = {i:(int(xpos[i]),int(ypos[i])) for i in xpos }
    return G, pos

# %% ../nbs/03inventory.ipynb 188
def extract_data_for_SSA(G):
    """
    ベンチマークデータからタブー探索で必要なデータを抽出する関数
    """
    h_dict, mu_dict, sigma_dict, service_dict = {},{},{},{}
    for i in G.down_order():
        if G.in_degree(i)==0:
            h_dict[i] = float( G.nodes[i]["stageCost"] )
        else:
            h_dict[i] = float( G.nodes[i]["stageCost"] )
            for j in G.predecessors(i):
                h_dict[i] += h_dict[j]

    for i in G.up_order():
        if G.out_degree(i)==0:
            mu_dict[i] = float( G.nodes[i]["avgDemand"] )
            sigma_dict[i] = float( G.nodes[i]["stDevDemand"] )
            service_dict[i] = float( G.nodes[i]["serviceLevel"] )
        else:
            mu_dict[i] = 0.
            sigma_dict[i] = 0.
            service_dict[i] = 0.
            for j in G.successors(i):
                mu_dict[i] += mu_dict[j]
                sigma_dict[i] += sigma_dict[j]**2
                service_dict[i] += service_dict[j]
            sigma_dict[i] = math.sqrt( sigma_dict[i] )
            service_dict[i] = service_dict[i]/G.out_degree[i]
    n = len(G)
    h = np.zeros(n)
    mu = np.zeros(n)
    sigma = np.zeros(n)
    ProcTime = np.zeros(n)
    LTUB = np.zeros(n)
    z = np.zeros(n)

    for idx, i in enumerate(G):
        mu[idx] = mu_dict[i]
        sigma[idx] = sigma_dict[i]
        h[idx] = h_dict[i]
        z[idx] = norm.ppf(service_dict[i],loc=0,scale=1)
        ProcTime[idx] = float(G.nodes[i]["stageTime"])
        LTUB[idx] = float(G.nodes[i].get("maxServiceTime",0.) )

    return mu, sigma, h, z, ProcTime, LTUB

# %% ../nbs/03inventory.ipynb 194
def draw_graph_for_SSA(G, pos, best_NRT, best_MaxLI, best_MinLT):
    """
    安全在庫配置問題の結果をPlotlyで描画する関数
    """
    max_ = max( best_NRT.max(), 1.0)
    size_ = best_NRT/(max_) * 20. + 10.0

    x_, y_, text_= [],[],[]
    for idx, i in enumerate(G):
        x_.append( pos[i][0] )
        y_.append( pos[i][1] )
        text_.append( str(i)+ " NRT:" + str(best_NRT[idx])+ " MaxLI:"+ str(best_MaxLI[idx])+ " MinLI:"+str(best_MinLT[idx]) )

    node_trace = go.Scatter(
        x = x_,
        y = y_,
        mode = 'markers',
        text= text_,
        hoverinfo="text",
        marker= dict(size= size_,
            #'Greys' | 'YlGnBu' | 'Greens' | 'YlOrRd' | 'Bluered' | 'RdBu' |
            #'Reds' | 'Blues' | 'Picnic' | 'Rainbow' | 'Portland' | 'Jet' |
            #'Hot' | 'Blackbody' | 'Earth' | 'Electric' | 'Viridis' |
                colorscale="Greys",
                reversescale=True,
                color= best_MinLT,
                colorbar=dict(
                        thickness=15,
                        title='Minium Lead Time=Guaranteed Lead Time',
                        xanchor='left'
                        ),
                ),
         name = "nodes",
         showlegend=False
    )

    edge_x = []
    edge_y = []
    for edge in G.edges():
        x0, y0 = pos[edge[0]]
        x1, y1 = pos[edge[1]]
        edge_x.append(x0)
        edge_x.append(x1)
        edge_x.append(None)
        edge_y.append(y0)
        edge_y.append(y1)
        edge_y.append(None)

    edge_trace = go.Scatter(
        x=edge_x, y=edge_y,
        line=dict(width=0.5, color='#888'),
        hoverinfo='none',
        mode='lines',
        name = "edges",
        showlegend=False
        )

    layout=go.Layout(xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
                    yaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
                    title="Safety Stock, i.e., Net Replenishment Time (=node size) and Network")

    data = [node_trace, edge_trace]
    fig = go.Figure(data,layout)
    return fig

# %% ../nbs/03inventory.ipynb 198
def make_df_for_SSA(G, pos, ProcTime, LTUB, z, mu, sigma, h, best_NRT, best_MaxLI, best_MinLT):
    """
    点(stage)と枝(bom)を保管したデータフレームを返す関数
    """
    col_ = ["name", "net_replenishment_time", "max_guaranteed_LT", "processing_time", "replenishment_LT", "guaranteed_LT",
            "z", "average_demand", "sigma", "h", "b", "capacity", "x", "y"]
    dic = {i: [] for i in col_}
    p = 1-norm.pdf(z) #サービス率
    b = p*h/(1-p)
    for idx,i in enumerate(G):
        dic["name"].append(i)
        dic["net_replenishment_time"].append(best_NRT[idx])
        dic["max_guaranteed_LT"].append(LTUB[idx])
        dic["processing_time"].append(ProcTime[idx])
        dic["replenishment_LT"].append(best_MaxLI[idx])
        dic["guaranteed_LT"].append(best_MinLT[idx])
        dic["z"].append(z[idx])
        dic["average_demand"].append(mu[idx])
        dic["sigma"].append(sigma[idx])
        #dic["h"].append(h[idx]*ratio/365.) #在庫費用
        #dic["b"].append(h[idx])  #品切れ費用

        dic["h"].append(h[idx]) #在庫費用
        dic["b"].append(round(b[idx],1))  #品切れ費用
        dic["capacity"].append(mu[idx]*10.) #生産容量　
        dic["x"].append(pos[i][0])
        dic["y"].append(pos[i][1])

    stage_df = pd.DataFrame(dic, columns= col_)

    #nx.write_gml(G, folder_bom + "ssa02.gml")
    col_ = ["child", "parent", "units", "allocation"]
    dic = {i: [] for i in col_}
    for (i,j) in G.edges():
        dic["child"].append(i)
        dic["parent"].append(j)
        dic["units"].append(1)
    for i in G:
        for j in G.successors(i):
            dic["allocation"].append(1./G.out_degree(i))

    bom_df = pd.DataFrame(dic, columns= col_)

    return stage_df, bom_df

# %% ../nbs/03inventory.ipynb 203
def draw_graph_for_SSA_from_df(stage_df, bom_df):
    """
    データフレームを入れると、安全在庫配置問題のデータをPlotlyで描画する関数
    """
    G = SCMGraph()
    for row in bom_df.itertuples():
        G.add_edge(row.child, row.parent)

    pos = {}
    for row in stage_df.itertuples():
        pos[row.name] = int(row.x), int(row.y)
    #print(pos)

    max_ = max( stage_df.processing_time.max(), 1.0)
    size_ =stage_df.processing_time.values/(max_) * 20. + 10.0

    x_, y_, text_ = [],[],[]
    for row in stage_df.itertuples():
        x_.append( row.x )
        y_.append( row.y )
        text_.append( str(row.name) + " ProcTime:" + str(row.processing_time)+ " demand:"+ str(row.average_demand)+ " h:"+str(row.h) )

    node_trace = go.Scatter(
        x = x_,
        y = y_,
        mode = 'markers',
        text= text_,
        hoverinfo="text",
        marker= dict(size= size_,
            #'Greys' | 'YlGnBu' | 'Greens' | 'YlOrRd' | 'Bluered' | 'RdBu' |
            #'Reds' | 'Blues' | 'Picnic' | 'Rainbow' | 'Portland' | 'Jet' |
            #'Hot' | 'Blackbody' | 'Earth' | 'Electric' | 'Viridis' |
                colorscale="Greys",
                reversescale=True,
                color= stage_df.average_demand.values,
                colorbar=dict(
                        thickness=15,
                        title='Average Demand',
                        xanchor='left'
                        ),
                ),
         name = "nodes",
         showlegend=False
    )

    edge_x = []
    edge_y = []
    for edge in G.edges():
        x0, y0 = pos[edge[0]]
        x1, y1 = pos[edge[1]]
        edge_x.append(x0)
        edge_x.append(x1)
        edge_x.append(None)
        edge_y.append(y0)
        edge_y.append(y1)
        edge_y.append(None)

    edge_trace = go.Scatter(
        x=edge_x, y=edge_y,
        line=dict(width=0.5, color='#888'),
        hoverinfo='none',
        mode='lines',
        name = "edges",
        showlegend=False
        )

    layout=go.Layout(xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
                    yaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
                    title="Safety Stock Allocation Network (size=processing time)")

    data = [node_trace, edge_trace]
    fig = go.Figure(data,layout)

    return fig, G, pos

# %% ../nbs/03inventory.ipynb 209
def solve_SSA(stage_df, bom_df):
    """
    データフレームを入力とした一般のネットワークの安全在庫配置モデルに対するタブー探索
    """
    G = SCMGraph()
    n = len(stage_df)
    h = np.zeros(n)
    mu = np.zeros(n)
    sigma = np.zeros(n)
    ProcTime = np.zeros(n)
    LTUB = np.zeros(n)
    z = np.zeros(n)
    pos ={}
    for idx, row in enumerate(stage_df.itertuples()):
        G.add_node(row.name)
        ProcTime[idx] = row.processing_time
        LTUB[idx] = row.max_guaranteed_LT
        z[idx] = row.z
        mu[idx] = row.average_demand
        sigma[idx] = row.sigma
        h[idx] = row.h
        pos[row.name] =(row.x,row.y)

    for row in bom_df.itertuples():
        G.add_edge(row.child, row.parent)

    best_cost, best_sol, best_NRT, best_MaxLI, best_MinLT = \
         tabu_search_for_SSA(G, ProcTime, LTUB, z, mu, sigma, h, max_iter = len(G)*2,
                             TLLB =int(np.sqrt(len(G))/2), TLUB =int(np.sqrt(len(G))), seed = 1)

    #stage_df, bom_df = make_df_for_SSA(G, pos, ProcTime, LTUB, z, mu, sigma, h, best_NRT, best_MaxLI, best_MinLT)
    stage_df["net_replenishment_time"] = best_NRT
    stage_df["guaranteed_LT"] = best_MinLT
    stage_df["replenishment_LT"] =  best_MaxLI
    fig = draw_graph_for_SSA(G, pos, best_NRT, best_MaxLI, best_MinLT)

    return best_cost, stage_df, bom_df, fig

# %% ../nbs/03inventory.ipynb 214
def periodic_inv_opt(stage_df, bom_df, max_iter = 1, n_samples = 10, n_periods = 100, seed = 1):
    """
    データフレームを入力とした定期発注方策最適化
    """
    G = SCMGraph()
    n = len(stage_df)
    h = np.zeros(n)
    b = np.zeros(n)
    capacity = np.zeros(n)
    mu = np.zeros(n)
    sigma = np.zeros(n)
    z = np.zeros(n)
    # リード時間は０より大きい整数である必要がある
    LT = np.zeros(n,dtype=int)

    pos ={}
    for idx, row in enumerate(stage_df.itertuples()):
        G.add_node(row.name)
        mu[idx] = row.average_demand
        sigma[idx] = row.sigma
        h[idx] = row.h
        b[idx] = row.b
        z[idx] = row.z
        capacity[idx] = row.capacity
        pos[row.name] =(row.x,row.y)
        #LT[idx] = int(row.replenishment_LT)+1
        LT[idx] = int(row.net_replenishment_time)+1

    #z = norm.ppf(b/(b+h))
    #assert np.min(LT)>0
    for row in bom_df.itertuples():
        G.add_edge(row.child, row.parent, weight=(row.units, row.allocation))

    #点のラベルの付け替え:0から順になるようにする．この配列とNumPyの配列の番号が一致する．
    mapping ={i:idx for idx,i in enumerate(G)}
    G = nx.relabel_nodes(G, mapping=mapping, copy=True)
    phi, alpha ={}, {}
    for i,j in G.edges():
        phi[i,j] = G[i][j]["weight"][0]
        alpha[i,j] = G[i][j]["weight"][1]

    #標準偏差が大きいと在庫切れを起こす！ 本当の平均と標準偏差を計算する必要あり！
    np.random.seed(seed)
    demand ={} #需要量
    for i in G:
        if G.out_degree(i) == 0:
            # 打ち切り正規分布（0未満のときは0にする）
            demand[i] =np.random.normal(mu[i], sigma[i], (n_samples, n_periods))
            demand[i] = np.maximum(demand[i],0.)
   
    # エシェロンリード時間と初期基在庫レベルの設定
    ELT, S = initial_base_stock_level(G, LT, mu, z, sigma)
    print("ELT=", ELT)
    print("S=", S)
    print("t: Cost    |dC|      S ")
    #S=S*1.082828

    convergence = 1e-5
    alpha_ = 1.
    beta_1 = 0.9
    beta_2 = 0.999
    epsilon = 1e-8
    m_t = np.zeros(n)
    v_t = np.zeros(n)

    best_cost = np.inf 
    for t in range(max_iter):
        dC, cost, I = network_base_stock_simulation(G, n_samples, n_periods, demand, capacity, LT, ELT, b, h, S, phi, alpha)
        if cost < best_cost:
            best_cost = cost
            best_S = S.copy()    
            best_I = I.copy()
        g_t = dC  # 勾配
        # 移動平均の更新
        m_t = beta_1*m_t + (1-beta_1)*g_t
        # 勾配の二乗の移動平均の更新
        v_t = beta_2*v_t + (1-beta_2)*(g_t**2)
        m_cap = m_t/(1-beta_1**(t+1))
        v_cap = v_t/(1-beta_2**(t+1))
        S = S - (alpha_*m_cap)/(np.sqrt(v_cap)+epsilon)
        sum_ = np.dot(g_t, g_t)
        if t%50 ==0:
            print(f"{t}: {cost:.2f}, {sum_:.5f}", S)
        if sum_ <= convergence:
            break
    print(f"Best: {best_cost:.2f}, {sum_:.5f}", best_S)
    stage_df["S"] = best_S
    #ローカル基在庫レベルの計算
    #S = stage_df.S
    local_S = np.zeros(n)
    for i in G:
        local_S[i] = best_S[i]
        for j in G.successors(i):
            local_S[i] -= best_S[j]
    stage_df["local_base_stock_level"] = local_S

    return best_cost, stage_df, best_I

# %% ../nbs/03inventory.ipynb 218
def periodic_inv_opt_fit_one_cycle(stage_df, bom_df, max_iter = 1, n_samples = 10, n_periods = 100, seed = 1, lr_find=False, max_lr =1., moms=(0.85,0.95)):
    """
    データフレームを入力とした定期発注方策最適化にfit_one_cycle法を適用
    """
    if lr_find:
        report_iter = 1
    else:
        report_iter = 50

    half_iter = max_iter//2
    lrs = (max_lr/25., max_lr)
    lr_sche =  np.concatenate( [np.linspace(lrs[0],lrs[1],half_iter), lrs[1]/2 + (lrs[1]/2)*np.cos(np.linspace(0,np.pi,half_iter) )])  #cosine annealing
    mom_sche = np.concatenate( [np.linspace(moms[1],moms[0],half_iter), moms[1]-(moms[1]-moms[0])/2 -(moms[1]-moms[0])/2*np.cos(np.linspace(0,np.pi,half_iter))] )

    #stage_df = pd.read_csv(folder_bom + "ssa01.csv", index_col=0)
    #bom_df = pd.read_csv(folder_bom + "ssa_bom01.csv", index_col=0)
    #best_cost, stage_df, bom_df, fig = solve_SSA(stage_df, bom_df)

    G = SCMGraph()
    n = len(stage_df)
    h = np.zeros(n)
    b = np.zeros(n)
    capacity = np.zeros(n)
    mu = np.zeros(n)
    sigma = np.zeros(n)
    z = np.zeros(n)
    # リード時間は０より大きい整数である必要がある
    LT = np.zeros(n,dtype=int)

    pos ={}
    for idx, row in enumerate(stage_df.itertuples()):
        G.add_node(row.name)
        mu[idx] = row.average_demand
        sigma[idx] = row.sigma
        h[idx] = row.h
        b[idx] = row.b
        z[idx] = row.z
        capacity[idx] = row.capacity
        pos[row.name] =(row.x,row.y)
        LT[idx] = int(row.net_replenishment_time)+1 #最低でもリード時間は1日かかる

    for row in bom_df.itertuples():
        G.add_edge(row.child, row.parent, weight=(row.units, row.allocation))

    #点のラベルの付け替え:0から順になるようにする．この配列とNumPyの配列の番号が一致する．
    mapping ={i:idx for idx,i in enumerate(G)}
    G = nx.relabel_nodes(G, mapping=mapping, copy=True)
    phi, alpha ={}, {}
    for i,j in G.edges():
        phi[i,j] = G[i][j]["weight"][0]
        alpha[i,j] = G[i][j]["weight"][1]

    np.random.seed(seed)
    demand ={} #需要量
    for i in G:
        if G.out_degree(i) == 0:
            # 打ち切り正規分布（0未満のときは0にする）
            demand[i] =np.random.normal(mu[i], sigma[i], (n_samples, n_periods))
            demand[i] = np.maximum(demand[i],0.)

    # エシェロンリード時間と初期基在庫レベルの設定
    ELT, S = initial_base_stock_level(G, LT, mu, z, sigma)
    print("ELT=", ELT)
    print("S=", S)
    print("t: Cost    |dC|      S ")

    if lr_find:
        step_size = 1e-10

    convergence = 1e-1
    beta_1 = 0.9
    m_t = np.zeros(n)
    beta_2 = 0.999
    epsilon = 1e-8
    m_t = np.zeros(n)
    v_t = np.zeros(n)

    prev_cost = np.inf
    cost_list, ss_list = [], []
    
    best_cost = np.inf 
    for t in range(max_iter):
        dC, cost, I = network_base_stock_simulation(G, n_samples, n_periods, demand, capacity, LT, ELT, b, h, S, phi, alpha)
        if cost < best_cost:
            best_cost = cost
            best_S = S.copy()    
            best_I = I.copy()
            
        g_t = dC  # 勾配

        norm = np.dot(g_t, g_t)
        if t%report_iter ==0:
            print(f"{t}: {cost:.2f}, {norm:.5f}", S)
        if norm <= convergence:
            break

        if lr_find and cost > prev_cost:
            break
        prev_cost = cost

        if lr_find:
            step_size *= 2. 
            beta_1 = moms[1]
        else:
            #fit one cycle 
            step_size = lr_sche[t]
            beta_1 = mom_sche[t] 
            
        ss_list.append( step_size )
        cost_list.append( cost )

        # 移動平均の更新
        m_t = beta_1*m_t + (1-beta_1)*g_t
        # 勾配の二乗の移動平均の更新
        v_t = beta_2*v_t + (1-beta_2)*(g_t**2)
        m_cap = m_t/(1-beta_1**(t+1))
        v_cap = v_t/(1-beta_2**(t+1))
        S = S - (step_size*m_cap)/(np.sqrt(v_cap)+epsilon)

        #S = S - step_size*m_t
    print(f"Best: {best_cost:.2f}", best_S)
    stage_df["S"] = best_S
    #ローカル基在庫レベルの計算
    #S = stage_df.S
    local_S = np.zeros(n)
    for i in G:
        local_S[i] = best_S[i]
        for j in G.successors(i):
            local_S[i] -= best_S[j]
    stage_df["local_base_stock_level"] = local_S

    return best_cost, stage_df, best_I, cost_list, ss_list

# %% ../nbs/03inventory.ipynb 223
def plot_inv_opt_lr_find(cost_list, ss_list):
    """
    学習率探索の結果を可視化する関数 
    """
    fig = go.Figure()
    fig.add_trace(go.Scatter(
            x = ss_list, 
            y = cost_list,
            mode='markers+lines',
            name= "lb",
            marker=dict(
                size=10,
                color= "red")
    ))

    fig.update_xaxes(type="log")    
    fig.update_layout(title = "Stepsize finder",
                   xaxis_title='Step Size (log scale)',
                   yaxis_title='Cost')
    return fig

# %% ../nbs/03inventory.ipynb 226
def plot_inv_opt(cost_list):
    #plot subgradient method
    fig = go.Figure()
    xx = np.arange(len(cost_list))
    fig.add_trace(go.Scatter(
            x = xx, 
            y = cost_list,
            mode='markers+lines',
            name= "lb",
            marker=dict(
                size=1,
                color= "red")
    ))
    fig.update_layout(title = "Inventory Optimization",
                   xaxis_title='Iteration',
                   yaxis_title='Cost')
    return fig 

# %% ../nbs/03inventory.ipynb 229
def plot_simulation(stage_df, I, n_periods=1, samples=5, stage_id_list=None):
    
    if stage_id_list is None:
        stage_id_list = [i for i in range(len(stage_df))]
    m = samples
    n=len(stage_df)
    #fig = make_subplots(rows=n, cols=1, subplot_titles= ["Stage " + str(i) for i in range(n)] )
    fig = make_subplots(rows=len(stage_id_list), cols=1, subplot_titles= list(stage_df.name[stage_id_list]) )

    for i,j in enumerate(stage_id_list):
        for k in range(m):
            trace = go.Scatter(
                x= list(range(n_periods)),
                y= I[k,j,:],
                mode = 'markers + lines',
                marker= dict(size= 5,
                            line= dict(width=1),
                            opacity= 0.3
                            ),
                name ="Stage "+str(j)
            )

            fig.add_trace(
                trace,
                row=i+1, col=1
            )

    fig.update_layout(height=1500,title_text=f"Inventories for selected stages", showlegend=False)
    return fig

# %% ../nbs/03inventory.ipynb 235
#| include: false
#| include: false
# def make_table(id_name, df, column_type):
#     """
#     標準的なテーブルを返す関数。id名、データフレーム、列のタイプを入力する。
#     """
#     return [dash_table.DataTable(
#         id=id_name,
#         # exportするフォーマットを指定(csv or xlsx)
#         export_format='csv',
#         #columns=[{"name": i, "id": i} for i in df.columns],
#         columns=[{"name": i, "id": i, "type": j}
#                  for (i, j) in zip(df.columns, column_type)],
#         data=df.to_dict('records'),
#         editable=True,
#         # filter_action="native",
#         # dropdown ={},  #ドロップダウンボックス設定用
#         sort_action="native",
#         sort_mode="multi",
#         column_selectable="single",
#         row_selectable="multi",
#         row_deletable=True,
#         selected_columns=[],
#         selected_rows=[],
#         page_action="native",
#         page_current=0,
#         page_size=10,
#         style_header={'backgroundColor': 'rgb(30, 30, 30)'},
#         style_cell={
#                     'backgroundColor': 'rgb(50, 50, 50)',
#                     'color': 'white'},
#     ),
#         html.Div(id=id_name+'-container'),
#         # html.Button('Add Row', id=id_name+'-button', n_clicks=0), #列追加ボタン
#         # uploadコンポーネント
#         dcc.Upload(
#         id=id_name+'-upload',
#         children=html.Div([
#             'Drag and Drop or ',
#             html.A('Select Files')
#         ]),
#         style={
#             'width': '100%', 'height': '60px', 'lineHeight': '60px',
#             'borderWidth': '1px', 'borderStyle': 'dashed',
#             'borderRadius': '5px', 'textAlign': 'center', 'margin': '10px'
#         },
#     ),
#     ]
