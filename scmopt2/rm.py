"""動的価格付け理論に基づく収益管理システム MERMO (MEta Revenue Management Optimzer)"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/13rm.ipynb.

# %% auto 0
__all__ = ['folder', 'make_sample_data_for_rm', 'rm_deterministic', 'rm_sampling', 'rm_recourse', 'bid_price_control',
           'nested_booking_limit_control']

# %% ../nbs/13rm.ipynb 3
import matplotlib.pyplot as plt
#from gurobipy import Model, quicksum, GRB
from mypulp import Model, quicksum, GRB
from scipy.stats import poisson, expon

import copy
import pickle
import numpy as np
import plotly.graph_objs as go
import plotly.express as px
import plotly
import pandas as pd
import random
import string
import datetime
import math
from collections import OrderedDict, defaultdict
from sklearn.linear_model import LinearRegression, LogisticRegression, Ridge
from scipy.stats import norm
import networkx as nx
from IPython.display import Image, YouTubeVideo
import sys
sys.path.append('..')

folder = "./data/rm/"

# %% ../nbs/13rm.ipynb 20
def make_sample_data_for_rm(num_periods):
    """
    make a sample data for revenue management
    """
    ell = num_periods
    res = list(range(ell))
    j = 0
    # 3 types of demands whose duratios are 1,2,3 
    dem = {1:20., 2:6., 3:3. }
    rev = {1:1000., 2:3000., 3:5000.} 
    a, demand, revenue = {}, {}, {}
    for dur in range(1,4): #duration 
        for r in range(ell+1-dur):
            for i in range(r,r+dur):
                a[i,j] = 1
            demand[j]= dem[dur]
            revenue[j] = rev[dur]
            j+=1
    m = j # number of demands   

    capacity ={i: 10. for i in res}
    return demand, revenue, a, capacity

# %% ../nbs/13rm.ipynb 39
def rm_deterministic(demand, capacity, revenue, a):
    """
    deterministic revenue management model
    """
    m = len(demand)
    ell = len(capacity)
    res = range(ell)

    model = Model()
    y = {}
    for j in range(m):
        y[j] = model.addVar(name=f'y({j})', ub = float(demand[j]) )
    model.update()
    constr ={}

    for i in res:
        constr[i] = model.addConstr( quicksum(a[i,j]*y[j] for j in range(m) if (i,j) in a) <= capacity[i] )

    model.setObjective(quicksum(revenue[j]*y[j] for j in range(m)), GRB.MAXIMIZE)

    # print(model)
    #model.Params.OutputFlag = False
    model.optimize()
    dual = {}
    for i in constr:
        dual[i] = constr[i].Pi
    ystar = {}
    for j in range(m):
        ystar[j] = y[j].X
    return model.ObjVal, dual, ystar

# %% ../nbs/13rm.ipynb 43
def rm_sampling(demand, capacity, revenue, a, n_samples =100):
    """
    revenue management model using sampling
    """
    m = len(demand)
    ell = len(capacity)
    res = range(ell)

    dem = {}
    obj_list =[]
    dual = np.zeros(ell)
    ystar = np.zeros(m)

    for s in range(n_samples):
        for j in range(m):
            dem[j] = poisson.rvs(demand[j], size=1)

        model = Model()
        y = {}
        for j in range(m):
            y[j] = model.addVar(name=f'y({j})', ub = float(dem[j][0]) )
        model.update()
        constr ={}
        for i in res:
            constr[i] = model.addConstr( quicksum(a[i,j]*y[j] for j in range(m) if (i,j) in a) <= capacity[i] )
        model.setObjective(quicksum(revenue[j]*y[j] for j in range(m)), GRB.MAXIMIZE)
        # print(model)
        #model.Params.OutputFlag = False
        model.optimize()
        obj_list.append( model.ObjVal )
        for i in constr:
            dual[i] += constr[i].Pi

        for j in range(m):
            ystar[j] += y[j].X

    return sum(obj_list)/n_samples, dual/n_samples, ystar/n_samples

# %% ../nbs/13rm.ipynb 47
def rm_recourse(demand, capacity, revenue, a):
    """
    revenue management model using recourse
    """
    m = len(demand)
    ell = len(capacity)
    res = range(ell)

    Delta ={}
    for j in range(m):
        mu = int(demand[j])
        rv = poisson(mu)
        Delta[j,0] = 0.
        for k in range(1,mu*2):
            Delta[j,k] = rv.sf(k)

    model = Model()
    z = {}
    for j,k in Delta:
        if k!=0:
            z[j,k] = model.addVar(name=f'z({j},{k})', ub = 1. )
    model.update()
    constr ={}

    for i in res:
        constr[i] = model.addConstr( quicksum(a[i,j]*z[j,k] for j,k in Delta if k!=0 and (i,j) in a) <= capacity[i] )

    model.setObjective(quicksum(revenue[j]*Delta[j,k]*z[j,k] for j,k in Delta if k!=0), GRB.MAXIMIZE)

    # print(model)
    #model.Params.OutputFlag = False
    model.optimize()

    dual={}
    for i in constr:
        dual[i] = constr[i].Pi

    ystar ={}
    for j in range(m):
        ystar[j] = 0.
        for k in range(1,int(demand[j])*2):
            if z[j,k].X > 0.1:
                #print(j,k,z[j,k].X)
                ystar[j]+=1.0
                k+=1
    return model.ObjVal, dual, ystar

# %% ../nbs/13rm.ipynb 51
def bid_price_control(demand, revenue, a, capacity, n_samples=100, method=0):
    """
    bid price control simulation
    """
    np.random.seed(123)
    ell = len(capacity)
    m =len(demand)
    res = list(range(ell))

    # generate random demand using Poisson distribution
    demand_ = {}
    for j in range(m):
        demand_[j] = float(poisson.rvs(demand[j], size=1)[0])

    # prepare arrival process
    arrival =[]
    for j in demand_:
        for i in range(int(demand_[j])): #make demand[j] customers and store them into the list "arrival"
            arrival.append(j)
    arrival = np.array(arrival)
    np.random.shuffle(arrival)

    total_revenue = 0.
    for t,j in enumerate(arrival):
        if method==0:
            obj, dual, ystar = rm_deterministic(demand, capacity, revenue, a)
        elif method==1:
            obj, dual, ystar = rm_sampling(demand, capacity, revenue, a, n_samples)
        elif method==2:
            obj, dual, ystar = rm_recourse(demand, capacity, revenue, a)
        else:
            print("Method must be 0,1 or 2")
            return -1
        if revenue[j] >= sum(a[i,j]*dual[i] for i in range(ell) if (i,j) in a):
            for i in range(ell):
                if (i,j) in a:
                    if capacity[i]==0:
                        break
            else:
                total_revenue +=revenue[j]
                print(t,total_revenue, " accept", j, dual, capacity)
                for i in range(ell):
                    if (i,j) in a:
                        capacity[i] -=a[i,j]

        demand[j] = max(demand[j]-1, 0.)
    return total_revenue

# %% ../nbs/13rm.ipynb 55
def nested_booking_limit_control(demand, revenue, a, capacity, n_samples=100, method=0):
    """
    nested booking limit policy simulation
    """
    np.random.seed(123)
    ell = 5
    res = list(range(ell))
    j = 0
    # 3 types of demands whose duratios are 1,2,3
    dem = {1:20., 2:6., 3:3. }
    rev = {1:1000., 2:3000., 3:5000.}
    a, demand, revenue = {}, {}, {}
    for dur in range(1,4): #duration
        for r in range(ell+1-dur):
            for i in range(r,r+dur):
                a[i,j] = 1
            demand[j]= dem[dur]
            revenue[j] = rev[dur]
            j+=1
    m = j # number of demands
    print(demand)
    print(revenue)
    print(a)
    capacity ={i: 10. for i in res}

    demand_ = {}
    for j in range(m):
        demand_[j] = float(poisson.rvs(demand[j], size=1)[0])

    arrival =[]
    for j in demand_:
        for i in range(int(demand_[j])): #make demand[j] customers and store them into the list "arrival"
            arrival.append(j)
    arrival = np.array(arrival)
    np.random.shuffle(arrival)

    total_revenue = 0.
    for t,j in enumerate(arrival):
        if method==0:
            obj, dual, ystar = rm_deterministic(demand, capacity, revenue, a)
        elif method==1:
            obj, dual, ystar = rm_sampling(demand, capacity, revenue, a, n_samples)
        elif method==2:
            obj, dual, ystar = rm_recourse(demand, capacity, revenue, a)
        else:
            print("Method must be 0,1 or 2")
            return -1

        rbar={}
        order = []
        for j_ in range(m):
            rbar[j_] = revenue[j_]-sum(a[i,j_]*dual[i] for i in range(ell) if (i,j_) in a)
            order.append( (rbar[j_],j_) )
        order.sort(reverse=True)

        capacity_ = copy.copy(capacity)
        S = {}
        for (r,j_) in order:
            for i in range(ell):
                if (i,j_) in a:
                    S[i,j_] = capacity_[i]
                    capacity_[i] -= ystar[j_]

        for i in range(ell):
            if (i,j) in a:
                if capacity[i]==0:
                    break
                if S[i,j]==0:
                    break
        else:
            total_revenue +=revenue[j]
            print(t,total_revenue, " accept", j, capacity)
            for i in range(ell):
                if (i,j) in a:
                    S[i,j] -=a[i,j]
                    capacity[i] -=a[i,j]

        demand[j] = max(demand[j]-1, 0.)
    return total_revenue
