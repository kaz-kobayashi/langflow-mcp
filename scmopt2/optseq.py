"""Scheduling Solver OptSeq"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/07optseq.ipynb.

# %% auto 0
__all__ = ['Parameters', 'State', 'Mode', 'Activity', 'Resource', 'Temporal', 'Model', 'visualize', 'plot_optseq',
           'time_convert_long', 'make_gannt', 'make_resource_usage', 'make_resource_graph', 'compute_horizon',
           'transform_to_cp', 'data_visualize', 'Job', 'Jobshop', 'Shift', 'shifting_bottleneck',
           'make_gannt_for_notion', 'optseq_project_excel', 'optseq_production_excel', 'optseq_resource_excel',
           'time_delta', 'prepare_df_for_optseq', 'prepare_capacity', 'make_model_for_optseq_production',
           'extract_fix_optseq', 'make_gannt_for_production']

# %% ../nbs/07optseq.ipynb 4
import sys
import pathlib
import os
import re
import copy
import platform
import string
import datetime as dt
import ast
import pickle
from collections import Counter, defaultdict

_trans = str.maketrans(":-+*/'(){}^=<>$ |#?,\¥", "_" * 22)  # 文字列変換用
# 以下非標準ファイル
import pandas as pd
import numpy as np
import plotly.graph_objs as go
import plotly

# import plotly.figure_factory as ff
import plotly.express as px
from plotly.subplots import make_subplots

# Pydantic
from typing import List, Optional, Union, Tuple, Dict, Set, Any, DefaultDict, ClassVar
from pydantic import (
    BaseModel,
    Field,
    ValidationError,
    validator,
    confloat,
    conint,
    constr,
    Json,
    PositiveInt,
    NonNegativeInt,
)
from pydantic.tools import parse_obj_as
from datetime import datetime, date, time
import graphviz

from openpyxl import Workbook, load_workbook
from openpyxl.worksheet.table import Table, TableStyleInfo
from openpyxl.chart import ScatterChart, Reference, Series
from openpyxl.worksheet.datavalidation import DataValidation
from openpyxl.formatting.rule import ColorScaleRule, CellIsRule, FormulaRule
from openpyxl.styles import Color, PatternFill, Font, Border, Alignment
from openpyxl.styles.borders import Border, Side
from openpyxl.comments import Comment

from intervaltree import Interval, IntervalTree

from ortools.sat.python.cp_model import CpModel, CpSolver
from ortools.sat.python import cp_model

import networkx as nx

# %% ../nbs/07optseq.ipynb 11
class Parameters(BaseModel):
    """
    OptSeq parameter class to control the operation of OptSeq.

    - param  TimeLimit: Limits the total time expended (in seconds). Positive integer. Default=600.

    - param  OutputFlag: Controls the output log. Integer. Default=1.

    - param  RandomSeed: Sets the random seed number. Integer. Default=1.

    - param  ReportInterval: Controls the frequency at which log lines are printed (iteration number). Default=1073741823.

    - param  Backtruck: Controls the maximum backtrucks. Default=1000.

    - param  MaxIteration: Sets the maximum numbers of iterations. Default=1073741823.

    - param  Initial: =True if the user wants to set an initial activity list. Default = False.

            Note that the file name of the activity list must be "optseq_best_act_data.txt."

    - param  Tenure: Controls a parameter of tabu search (initial tabu tenure). Default=1.
    - param  Neighborhood: Controls a parameter of tabu search (neighborhood size). Default=20.
    - param  Makespan: Sets the objective function.

            Makespan is True if the objective is to minimize the makespan (maximum completion time),
            is False otherwise, i.e., to minimize the total weighted tardiness of activities.
            Default=False.
    """

    TimeLimit: PositiveInt = 600
    OutputFlag: int = 1  # ON
    RandomSeed: int = 1
    ReportInterval: PositiveInt = 1073741823
    Backtruck: PositiveInt = 1000
    MaxIteration: PositiveInt = 1073741823
    Initial: bool = False
    Tenure: PositiveInt = 1
    Neighborhood: PositiveInt = 20
    Makespan: bool = False

    def __str__(self) -> str:
        return f""" 
 TimeLimit = {self.TimeLimit} \n OutputFlag = {self.OutputFlag}
 RandomSeed = {self.RandomSeed} \n ReportInterval = {self.ReportInterval} \n Backtruck = {self.Backtruck}
 Initial = {self.Initial} \n Tenure = {self.Tenure}
 Neighborhood = {self.Neighborhood} \n makespan = {self.Makespan} """

# %% ../nbs/07optseq.ipynb 15
class State(BaseModel):
    """
    OptSeq state class.

    You can create a state object by adding a state to a model (using Model.addState)
    instead of by using a State constructor.

        - Arguments:
            - name: Name of state. Remark that strings in OptSeq are restricted to a-z, A-Z, 0-9,[],_ and @.

    """

    ID: ClassVar[int] = 0
    name: Optional[str] = ""
    Value: Optional[Dict[NonNegativeInt, NonNegativeInt]] = {}

    def __init__(self, name: str = "") -> None:
        super().__init__(name=name)

        if name == "" or name == None:
            name = "__s{0}".format(State.ID)
            State.ID += 1
        if type(name) != str:
            raise ValueError("State name must be a string")

        # convert illegal characters into _ (underscore)
        self.name = str(name).translate(_trans)

    def __str__(self) -> str:
        ret = ["state {0} ".format(self.name)]
        for v in self.Value:
            ret.append("time {0} value {1} ".format(v, self.Value[v]))
        return " ".join(ret)

    def addValue(self, time: NonNegativeInt = 0, value: NonNegativeInt = 0) -> None:
        """
        Adds a value to the state
            - Arguments:
                - time: the time at which the state changes.
                - value: the value that the state changbes to

            - Example usage:

            >>> state.addValue(time=5,value=1)
        """
        if type(time) == type(1) and type(value) == type(1):
            self.Value[time] = value
        else:
            print("time and value of the state {0} must be integer".format(self.name))
            raise TypeError

# %% ../nbs/07optseq.ipynb 19
class Mode(BaseModel):
    """
    OptSeq mode class.

        - Arguments:
            - name: Name of mode (sub-activity).
                    Remark that strings in OptSeq are restricted to a-z, A-Z, 0-9,[],_ and @.
                    Also you cannot use "dummy" for the name of a mode.
                    - duration(optional): Processing time of mode. Default=0.

        - Attbibutes:
            - requirement: Dictionary that maps a pair of resource name and resource type (rtype) to requirement dictionary.
                    Requirement dictionary maps intervals (pairs of start time and finish time) to amounts of requirement.
                    Resource type (rtype) is None (standard resource type), "break" or "max."
            - breakable: Dictionary that maps breakable intervals to maximum brek times.
            - paralel:  Dictionary that maps parallelable intervals to maximum parallel numbers.
            - state: Dictionary that maps states to the tuples of values.
    """

    ID: ClassVar[int] = 0
    name: Optional[str] = ""
    duration: Optional[PositiveInt] = 1
    requirement: Optional[
        Dict[
            Tuple[str, Optional[str]],
            Dict[Tuple[NonNegativeInt, NonNegativeInt], NonNegativeInt],
        ]
    ] = None
    breakable: Optional[Dict[Tuple[NonNegativeInt, NonNegativeInt], PositiveInt]] = None
    parallel: Optional[Dict[Tuple[PositiveInt, PositiveInt], PositiveInt]] = None
    state: Optional[Dict[State, Tuple[int, int]]] = None

    def __init__(
        self,
        name: str = "",
        duration: PositiveInt = 1,
        requirement: Optional[
            Dict[
                Tuple[str, Optional[str]],
                Dict[Tuple[NonNegativeInt, NonNegativeInt], NonNegativeInt],
            ]
        ] = None,
        breakable: Optional[
            Dict[Tuple[NonNegativeInt, NonNegativeInt], PositiveInt]
        ] = None,
        parallel: Optional[Dict[Tuple[PositiveInt, PositiveInt], PositiveInt]] = None,
        state: Optional[Dict[State, Tuple[int, int]]] = None,
    ):
        super().__init__(
            name=name,
            duration=duration,
            requirement=requirement,
            breakable=breakable,
            parallel=parallel,
            state=state,
        )
        if name is None or name == "":
            name = "__m{0}".format(Mode.ID)
            Mode.ID += 1
        if name == "dummy":
            print("'dummy' cannnot be used as a mode name")
            raise NameError("'dummy' cannnot be used as a mode name")
        if type(name) != str:
            raise ValueError("Mode name must be a string")

        self.name = str(name).translate(_trans)
        # self.duration = duration

    def __str__(self) -> str:
        ret = [" duration {0} ".format(self.duration)]

        if self.requirement:
            for r, rtype in self.requirement:
                for interval, cap in self.requirement[(r, rtype)].items():
                    (s, t) = interval
                    if rtype == "max":
                        ret.append(
                            " {0} max interval {1} {2} requirement {3} ".format(
                                r, s, t, cap
                            )
                        )
                    elif rtype == "break":
                        ret.append(
                            " {0} interval break {1} {2} requirement {3} ".format(
                                r, s, t, cap
                            )
                        )
                    elif rtype == None:
                        ret.append(
                            " {0} interval {1} {2} requirement {3} ".format(
                                r, s, t, cap
                            )
                        )
                    else:
                        print("resource type error")
                        raise TypeError("resource type error")

        # break
        if self.breakable:
            for interval, cap in self.breakable.items():
                (s, t) = interval
                if cap == "inf":
                    ret.append(" break interval {0} {1} ".format(s, t))
                else:
                    ret.append(" break interval {0} {1} max {2} ".format(s, t, cap))

        # parallel
        if self.parallel:
            for interval, cap in self.parallel.items():
                (s, t) = interval
                if cap == "inf":
                    ret.append(" parallel interval {0} {1} ".format(s, t))
                else:
                    ret.append(" parallel interval {0} {1} max {2} ".format(s, t, cap))

        # state
        if self.state:
            for s in self.state:
                for f, t in self.state[s]:
                    ret.append(" {0} from {1} to {2} ".format(s, f, t))

        return " \n".join(ret)

    def addState(self, state: "State", fromValue: int = 0, toValue: int = 0) -> None:
        """
        Adds a state change information to the mode.

            - Arguments:
                - state: State object to be added to the mode.
                - fromValue: the value from which the state changes by the mode
                - toValue:  the value to which the state changes by the mode

            - Example usage:

            >>> mode.addState(state1,0,1)

            defines that state1 is changed from 0 to 1.

        """
        if self.state is None:
            self.state = {}
        if type(fromValue) != type(1) or type(toValue) != type(1):
            print("time and value of the state {0} must be integer".format(self.name))
            raise TypeError(
                "time and value of the state {0} must be integer".format(self.name)
            )
        else:
            if state.name not in self.state:
                self.state[state.name] = [(fromValue, toValue)]
            else:
                self.state[state.name].append((fromValue, toValue))

    def addResource(
        self,
        resource: "Resource",
        requirement: Union[
            int, Dict[Tuple[NonNegativeInt, Union[NonNegativeInt, str]], NonNegativeInt]
        ] = None,
        rtype: Optional[str] = None,
    ):
        """
        Adds a resource to the mode.

            - Arguments:
                - resurce: Resource object to be added to the mode.
                - requirement: Dictionary that maps intervals (pairs of start time and finish time) to amounts of requirement.
                               It may be an integer; in this case, requirement is converted into the dictionary {(0,"inf"):requirement}.
                - rtype (optional): Type of resource to be added to the mode.
                None (standard resource type; default), "break" or "max."

            - Example usage:

            >>> mode.addResource(worker,{(0,10):1})

            defines worker resource that uses 1 unit for 10 periods.

            >>> mode.addResource(machine,{(0,"inf"):1},"break")

            defines machine resource that uses 1 unit during break periods.

            >>> mode.addResource(machine,{(0,"inf"):1},"max")

            defines machine resource that uses 1 unit during parallel execution.
        """

        if self.requirement is None:  # 辞書を準備
            self.requirement = {}

        if type(requirement) == type(1):  # 引数を辞書に変換
            requirement = {(0, "inf"): requirement}

        if type(resource.name) != type("") or type(requirement) != type({}):
            print(
                f"type error in adding a resource {resource.name} to activity's mode {self.name}: requirement type is {type(requirement)}"
            )
            raise TypeError(
                "type error in adding a resource {0} to activity {1}".format(
                    resource.name, self.name
                )
            )
        elif rtype == None or rtype == "break" or rtype == "max":
            if (resource.name, rtype) not in self.requirement:
                # generate an empty dic.
                self.requirement[(resource.name, rtype)] = {}
            data = copy.deepcopy(self.requirement[(resource.name, rtype)])
            data.update(requirement)
            self.requirement[(resource.name, rtype)] = data
        else:
            print("rtype must be None or break or max")
            raise NameError("rtype must be None or break or max")

    def addBreak(
        self,
        start: NonNegativeInt = 0,
        finish: NonNegativeInt = 0,
        maxtime: Union[NonNegativeInt, str] = "inf",
    ) -> None:
        """
        Sets breakable information to the mode.

            - Arguments:
                - start(optional): Earliest break time. Non-negative integer. Default=0.
                - finish(optional): Latest break time.  Non-negative integer or "inf." Default=0.
                    Interval (start,finish) defines a possible break interval.
                - maxtime(optional): Maximum break time. Non-negative integer or "inf." Default="inf."

            - Example usage:

            >>> mode.addBreak(0,10,1)

            defines a break between (0,10) for one period.
        """
        if self.breakable is None:
            self.breakable = {}
        data = copy.deepcopy(self.breakable)
        data.update({(start, finish): maxtime})
        self.breakable = data

    def addParallel(
        self,
        start: PositiveInt = 1,
        finish: PositiveInt = 1,
        maxparallel: Union[NonNegativeInt, str] = "inf",
    ):
        """
        Sets parallel information to the mode.

            - Arguments:
                - start(optional): Smallest job index executable in parallel. Positive integer. Default=1.
                - finish(optional): Largest job index executable in parallel. Positive integer or "inf." Default=1.
                - maxparallel(optional): Maximum job numbers executable in parallel. Non-negative integer or "inf." Default="inf."

            - Example usage:

            >>> mode.addParallel(1,1,2)
        """
        if self.parallel is None:
            self.parallel = {}
        data = copy.deepcopy(self.parallel)
        data.update({(start, finish): maxparallel})
        self.parallel = data

# %% ../nbs/07optseq.ipynb 23
class Activity(BaseModel):
    """
    OptSeq activity class.

        You can create an activity object by adding an activity to a model (using Model.addActivity)
        instead of by using an Activity constructor.

        - Arguments:
                - name: Name of activity. Remark that strings in OptSeq are restricted to a-z, A-Z, 0-9,[],_ and @.
                        Also you cannot use "source" and "sink" for the name of an activity.
                - duedate(optional): Duedate of activity. A non-nagative integer or string "inf."
                - backward(optional): True if activity is distached backwardly, False (default) otherwise.
                - weight(optional): Panalty of one unit of tardiness. Positive integer.
                - autoselect(optional): True or False flag that indicates the activity selects the mode automatically or not.
    """

    ID: ClassVar[int] = 0
    name: Optional[str] = ""
    duedate: Optional[Union[NonNegativeInt, str]] = "inf"
    backward: Optional[bool] = False  # 後ろ詰め
    weight: Optional[PositiveInt] = 1
    autoselect: Optional[bool] = False
    quadratic: Optional[bool] = False
    modes: Optional[List[Mode]] = []  # list of mode objects
    start: Optional[NonNegativeInt] = 0
    completion: Optional[NonNegativeInt] = 0
    execute: Optional[Dict[Tuple[NonNegativeInt, NonNegativeInt], NonNegativeInt]] = {}
    selected: Optional[Mode] = None

    def __init__(
        self,
        name="",
        duedate="inf",
        backward=False,
        weight=1,
        autoselect=False,
        quadratic=False,
    ):
        super().__init__(
            name=name,
            duedate=duedate,
            backward=backward,
            weight=weight,
            autoselect=autoselect,
            quadratic=quadratic,
        )

        if name == "source" or name == "sink":
            print(" 'source' and 'sink' cannnot be used as an activity name")
            raise NameError

        if type(name) != str:
            raise ValueError("Activity name must be a string")

        if name == "" or name == None:
            name = "__a{0}".format(Activity.ID)
            Activity.ID += 1

        # convert illegal characters into _ (underscore)
        self.name = str(name).translate(_trans)

    def __str__(self) -> str:
        ret = ["activity {0}".format(self.name)]
        if self.duedate != "inf":
            if self.backward == True:
                ret.append(" backward duedate {0} ".format(self.duedate))
            else:
                ret.append(" duedate {0} ".format(self.duedate))
            ret.append(" weight {0} ".format(self.weight))
            if self.quadratic:
                ret.append(" quad ")

        # １つのモードと２つ以上を区別しない実装
        if self.autoselect == True:
            ret.append(" autoselect ")
        for m in self.modes:  # multiple modes
            ret.append(" {0} ".format(m.name))  # print mode names

        return " \n".join(ret)

    def addModes(self, *modes: List[Mode]) -> None:
        """
        Adds a mode or modes to the activity.

            - Arguments:
                - modes: One or more mode objects.

            - Example usage:

            >>> activity.addModes(mode1,mode2)
        """
        for mode in modes:
            self.modes.append(mode)

# %% ../nbs/07optseq.ipynb 27
class Resource(BaseModel):
    """
    OptSeq resource class.

         - Arguments:
             - name: Name of resource.
                     Remark that strings in OptSeq are restricted to a-z, A-Z, 0-9,[],_ and @.
             - capacity (optional): Capacity dictionary of the renewable (standard) resource.
                         Capacity dictionary maps intervals (pairs of start time and finish time) to amounts of capacity.
                         If it is given by a positive integer, it is converted into the dictionay {(0,"inf"):capacity}.
             - rhs (optional): Right-hand-side constant of nonrenewable resource constraint.
             - direction (optional): Rirection (or sense) of nonrenewable resource constraint; "<=" (default) or ">=".
             - weight (optional): Weight of nonrenewable resource to compute the penalty for violating the constraint.
                                  Non-negative integer or "inf" (default).

         - Attbibutes:
             - capacity: Capacity dictionary of the renewable (standard) resource.
             - rhs: Right-hand-side constant of nonrenewable resource constraint.
             - direction: Rirection (or sense) of nonrenewable resource constraint; "<=" (default) or "=" or ">=".
             - terms: List of terms in left-hand-side of nonrenewable resource.
                        Each term is a tuple of coeffcient, activity and mode.
             - weight: Weight of nonrenewable resource to compute the penalty for violating the constraint.
                       Non-negative integer or "inf" (default).
             - residual: Residual dictionary of the renewable (standard) resource.

    """

    ID: ClassVar[int] = 0
    name: Optional[str] = ""
    capacity: Optional[
        Union[int, Dict[Tuple[NonNegativeInt, NonNegativeInt], PositiveInt]]
    ] = None
    rhs: Optional[int] = 0
    direction: Optional[str] = "<="
    weight: Optional[Union[NonNegativeInt, str]] = "inf"
    terms: Optional[List[Tuple[int, Activity, Mode]]] = []
    residual: Optional[Dict[Tuple[NonNegativeInt, NonNegativeInt], NonNegativeInt]] = {}

    def __init__(
        self,
        name="",
        capacity: Optional[
            Union[int, Dict[Tuple[NonNegativeInt, NonNegativeInt], PositiveInt]]
        ] = None,
        rhs: int = 0,
        direction: str = "<=",
        weight: Union[NonNegativeInt, str] = "inf",
    ):
        super().__init__(capacity=capacity, rhs=rhs, direction=direction, weight=weight)

        if capacity is None:
            capacity = {}
        if name is None or name == "":
            name = "__r{0}".format(Resource.ID)
            Resource.ID += 1
        if type(name) != str:
            raise ValueError("Resource name must be a string")

        # convert illegal characters into _ (underscore)
        self.name = str(name).translate(_trans)
        if type(capacity) == type(1):
            self.capacity = {(0, "inf"): capacity}
        # else:
        #     self.capacity = capacity
        # self.rhs = rhs
        # self.direction = direction
        # self.weight = weight

    def __str__(self) -> str:
        ret = []
        if self.capacity:
            ret.append("resource {0} ".format(self.name))
            capList = []
            for interval, cap in self.capacity.items():
                (s, t) = interval
                capList.append((s, t, cap))
            # capList.sort()
            for s, t, cap in capList:
                ret.append(" interval {0} {1} capacity {2} ".format(s, t, cap))
            # ret.append("\n")
        return " \n".join(ret)

    def addCapacity(
        self,
        start: NonNegativeInt = 0,
        finish: NonNegativeInt = 0,
        amount: PositiveInt = 1,
    ) -> None:
        """
        Adds a capacity to the resource.

            - Arguments:
                - start(optional): Start time. Non-negative integer. Default=0.
                - finish(optional): Finish time. Non-negative integer. Default=0.
                 Interval (start,finish) defines the interval during which the capacity is added.
                - amount(optional): The amount to be added to the capacity. Positive integer. Default=1.

            - Example usage:

            >>> manpower.addCapacity(0,5,2)
        """

        data = copy.deepcopy(self.capacity)
        data.update({(start, finish): amount})
        self.capacity = data

    def printConstraint(self) -> str:
        """
        Returns the information of the linear constraint.

        The constraint is expanded and is shown in a readable format.
        """

        f = ["nonrenewable weight {0} ".format(self.weight)]
        if self.direction == ">=" or self.direction == ">":
            for coeff, var, value in self.terms:
                f.append("{0}({1},{2}) ".format(-coeff, var.name, value.name))
            f.append("<={0} \n".format(-self.rhs))
        elif self.direction == "==" or self.direction == "=":
            for coeff, var, value in self.terms:
                f.append("{0}({1},{2}) ".format(coeff, var.name, value.name))
            f.append("<={0} \n".format(self.rhs))
            f.append("nonrenewable weight {0} ".format(self.weight))
            for coeff, var, value in self.terms:
                f.append("{0}({1},{2}) ".format(-coeff, var.name, value.name))
            f.append("<={0} \n".format(-self.rhs))
        else:
            for coeff, var, value in self.terms:
                f.append("{0}({1},{2}) ".format(coeff, var.name, value.name))
            f.append("<={0} \n".format(self.rhs))

        return "".join(f)

    def addTerms(
        self,
        coeffs: Union[int, List[int]],
        vars: Union[Activity, List[Activity]],
        values: Union[Mode, List[Mode]],
    ) -> None:
        """
        Add new terms into left-hand-side of nonrenewable resource constraint.

            - Arguments:
                - coeffs: Coefficients for new terms; either a list of coefficients or a single coefficient.
                The three arguments must have the same size.
                - vars: Activity objects for new terms; either a list of activity objects or a single activity object.
                The three arguments must have the same size.
                - values: Mode objects for new terms; either a list of mode objects or a single mode object.
                The three arguments must have the same size.

            - Example usage:

            >>> budget.addTerms(1,act,express)

            adds one unit of nonrenewable resource (budget) if activity "act" is executed in mode "express."

        """
        if type(coeffs) != type([]):
            self.terms.append((coeffs, vars, values))
        elif (
            type(coeffs) != type([])
            or type(vars) != type([])
            or type(values) != type([])
        ):
            print("coeffs, vars, values must be lists")
            raise TypeError("coeffs, vars, values must be lists")
        elif (
            len(coeffs) != len(vars)
            or len(coeffs) != len(values)
            or len(values) != len(vars)
        ):
            print("length of coeffs, vars, values must be identical")
            raise TypeError("length of coeffs, vars, values must be identical")
        else:
            for i in range(len(coeffs)):
                self.terms.append((coeffs[i], vars[i], values[i]))

    def setRhs(self, rhs: int = 0) -> None:
        """
        Sets the right-hand-side of linear constraint.

            - Argument:
                - rhs: Right-hand-side of linear constraint.

            - Example usage:

            >>> L.setRhs(10)

        """
        self.rhs = rhs

    def setDirection(self, direction: str = "<=") -> None:
        if direction in ["<=", ">=", "="]:
            self.direction = direction
        else:
            print(
                "direction setting error; direction should be one of '<=' or '>=' or '='"
            )
            raise NameError(
                "direction setting error; direction should be one of '<=' or '>=' or '='"
            )

# %% ../nbs/07optseq.ipynb 31
class Temporal(BaseModel):
    """
    OptSeq temporal class.

    A temporal constraint has the following form::

        predecessor's completion (start) time +delay <=
                        successor's start (completion) time.

    Parameter "delay" can be negative.

        - Arguments:
            - pred: Predecessor (an activity object) or string "source."
                    Here, "source" specifies a dummy activity that precedes all other activities and starts at time 0.
            - succ: Successor (an activity object) or string "source."
                    Here, "source" specifies a dummy activity that precedes all other activities and starts at time 0.
            - tempType (optional): String that differentiates the temporal type.
                "CS" (default)=Completion-Start, "SS"=Start-Start,
                "SC"= Start-Completion, "CC"=Completion-Completion.
            - delay (optional): Time lag between the completion (start) times of two activities.
            - pred_mode (optional): Predecessor's mode
            - succ_mode (optional): Successor's mode

        - Attributes:
            - pred: Predecessor (an activity object) or string "source."
            - succ: Successor (an activity object) or string "source."
            - type: String that differentiates the temporal type.
                "CS" (default)=Completion-Start, "SS"=Start-Start,
                "SC"= Start-Completion, "CC"=Completion-Completion.
            - delay: Time lag between the completion (start) times of two activities. default=0.

    """

    pred: Union[Activity, str]  # activity or "source" or "sink"
    succ: Union[Activity, str]
    type: Optional[str] = "CS"
    delay: Optional[int] = 0
    pred_mode: Optional[Mode] = None
    succ_mode: Optional[Mode] = None

    def __init__(
        self,
        pred: Union[Activity, str],
        succ: Union[Activity, str],
        tempType: str = "CS",
        delay: int = 0,
        pred_mode: Optional[Mode] = None,
        succ_mode: Optional[Mode] = None,
    ) -> None:
        super().__init__(
            pred=pred,
            succ=succ,
            tempType=tempType,
            delay=delay,
            pred_mode=pred_mode,
            succ_mode=succ_mode,
        )

        if pred_mode is not None and pred_mode not in pred.modes:
            raise ValueError(f"Mode {pred_mode.name} is not in activity {pred.name}")
        if succ_mode is not None and succ_mode not in succ.modes:
            raise ValueError(f"Mode {succ_mode.name} is not in activity {succ.name}")

    def __str__(self) -> str:
        if self.pred == "source":
            pred = "source"
        elif self.pred == "sink":
            pred = "sink"
        else:
            pred = str(self.pred.name)

        if self.succ == "source":
            succ = "source"
        elif self.succ == "sink":
            succ = "sink"
        else:
            succ = str(self.succ.name)

        if self.pred_mode is None and self.succ_mode is None:
            # モードに依存しない時間制約
            ret = ["temporal {0} {1}".format(pred, succ)]
            ret.append(" type {0} delay {1} ".format(self.type, self.delay))
        else:
            # source,sink以外の場合で， 片方だけモード指定して，複数モードがある場合にはエラー
            if self.pred != "source" and self.succ != "sink":
                if self.pred_mode is None and self.succ_mode is not None:
                    raise ValueError(
                        f"The mode of activity {self.pred.name} is not specified!"
                    )
                if self.pred_mode is not None and self.succ_mode is None:
                    raise ValueError(
                        f"The mode of activity {self.succ.name} is not specified!"
                    )

            if self.pred == "source" or self.pred == "sink":
                pred_mode = "dummy"
            else:
                pred_mode = self.pred_mode.name

            if self.succ == "source" or self.succ == "sink":
                succ_mode = "dummy"
            else:
                succ_mode = self.succ_mode.name

            ret = [f"temporal {pred} mode {pred_mode} {succ} mode {succ_mode}"]
            ret.append(" type {0} delay {1} ".format(self.type, self.delay))

        # print(self.pred_mode, self.succ_mode, ret)
        return " ".join(ret)

# %% ../nbs/07optseq.ipynb 35
class Model(BaseModel):
    """
    OptSeq model class.
        - Attributes:
            - activities: Dictionary that maps activity names to activity objects in the model.
            - modes: Dictionary that maps mode names to mode objects in the model.
            - resources:  Dictionary that maps resource names to resource objects in the model.
            - temporals: Dictionary that maps pairs of activity names to temporal constraint objects in the model.
            - Params: Object including all the parameters of the model.

            - act: List of all the activity objects in the model.
            - res: List of all the resource objects in the model.
            - tempo: List of all the tamporal constraint objects in the model.
    """

    name: Optional[str] = ""
    activities: Optional[
        Dict[str, Activity]
    ] = {}  # set of activities maintained by a dictionary
    modes: Optional[Dict[str, Mode]] = {}  # set of modes maintained by a dictionary
    resources: Optional[
        Dict[str, Resource]
    ] = {}  # set of resources maintained by a dictionary
    temporals: Optional[
        Dict[str, Temporal]
    ] = {}  # set of temporal constraints maintained by a dictionary
    states: Optional[Dict[str, State]] = {}  # set of states maintained by a dictionary

    act: Optional[List[Activity]] = []  # list of activity objects
    res: Optional[List[Resource]] = []  # list of resource objects
    tempo: Optional[List[Temporal]] = []  # list of temporal constraint's objects
    state: Optional[List[State]] = []  # list of state objects

    Params: Optional[Parameters] = Parameters()  # controal parameters' class
    Status: Optional[int] = 10  # unsolved
    ObjVal: Optional[NonNegativeInt] = None  # best solution value

    def __init__(self, name: Optional[str] = ""):
        super().__init__(name=name)

    def __str__(self):
        ret = ["Model:{0}".format(self.name)]
        ret.append("number of activities= {0}".format(len(self.act)))
        ret.append("number of resources= {0}".format(len(self.res)))

        if len(self.res):
            ret.append("\nResource Information")
            for res in self.res:
                ret.append(str(res))
                if len(res.terms) > 0:
                    ret.append(res.printConstraint())

        for a in self.act:
            # if len(a.modes) >= 2:
            for m in a.modes:
                self.modes[m.name] = m

        if len(self.modes):
            ret.append("\nMode Information")
            for i in self.modes:
                # ret.append("{0}\n{1}".format(i,self.modes[i]))
                ret.append(str(i))
                ret.append(str(self.modes[i]))

        if len(self.act):
            ret.append("\nActivity Information")
            for act in self.act:
                ret.append(str(act))

        if len(self.tempo):
            ret.append("\nTemporal Constraint Information")
            for t in self.tempo:
                ret.append(str(t))

        if len(self.state):
            ret.append("\nState Information")
            for s in self.state:
                ret.append(str(s))

        return "\n".join(ret)

    def addActivity(
        self,
        name="",
        duedate="inf",
        backward=False,
        weight=1,
        autoselect=False,
        quadratic=False,
    ):
        """
        Add an activity to the model.

            - Arguments:
                - name: Name for new activity. A string object except "source" and "sink." Remark that strings in OptSeq are restricted to a-z, A-Z, 0-9,[],_ and @.
                - duedate(optional): Duedate of activity. A non-nagative integer or string "inf."
                - backward(optional): True if activity is distached backwardly, False (default) otherwise.
                - weight(optional): Panalty of one unit of tardiness. Positive integer.
                - autoselect(optional): True or False flag that indicates the activity selects the mode automatically or not.

            - Return value: New activity object.

            - Example usage:

            >>> a = model.addActivity("act1")

            >>> a = model.addActivity(name="act1",duedate=20,weight=100)

            >>> a = model.addActivity("act1",20,100)
        """
        activity = Activity(name, duedate, backward, weight, autoselect, quadratic)
        self.act.append(activity)
        # self.activities[activity.name]=activity
        return activity

    def addResource(self, name="", capacity=None, rhs=0, direction="<=", weight="inf"):
        """
        Add a resource to the model.

            - Arguments:
                - name: Name for new resource. Remark that strings in OptSeq are restricted to a-z, A-Z, 0-9,[],_ and @.
                - capacity (optional): Capacity dictionary of the renewable (standard) resource.
                - Capacity dictionary maps intervals (pairs of start time and finish time) to amounts of capacity.
                - rhs (optional): Right-hand-side constant of nonrenewable resource constraint.
                - direction (optional): Rirection (or sense) of nonrenewable resource constraint; "<=" (default) or ">=" or "=".
                - weight (optional): Weight of resource. Non-negative integer or "inf" (default).

            - Return value: New resource object.

            - Example usage:

            >>> r=model.addResource("res1")

            >>> r=model.addResource("res1", {(0,10):1,(12,100):2} )

            >>> r=model.addResource("res2",rhs=10,direction=">=")

        """
        if capacity is None:
            capacity = {}
        res = Resource(
            name=name, capacity=capacity, rhs=rhs, direction=direction, weight=weight
        )
        self.res.append(res)
        # self.resources[res.name]=res
        return res

    def addTemporal(
        self, pred, succ, tempType="CS", delay=0, pred_mode=None, succ_mode=None
    ):
        """
        Add a temporal constraint to the model.

        A temporal constraint has the following form::

            predecessor's completion (start) time +delay <=
                            successor's start (completion) time.

        Parameter "delay" can be negative.

            - Arguments:
                - pred: Predecessor (an activity object) or string "source."
                        Here, "source" specifies a dummy activity that precedes all other activities and starts at time 0.
                - succ: Successor (an activity object) or string "source."
                        Here, "source" specifies a dummy activity that precedes all other activities and starts at time 0.
                - tempType (optional): String that differentiates the temporal type.
                    "CS" (default)=Completion-Start, "SS"=Start-Start,
                    "SC"= Start-Completion, "CC"=Completion-Completion.
                - delay (optional): Time lag between the completion (start) times of two activities.
                - pred_mode (optional): Predecessor's mode
                - succ_mode (optional): Successor's mode

            - Return value: New temporal object.

            - Example usage:

            >>> t=model.addTemporal(act1,act2)

            >>> t=model.addTemporal(act1,act2,type="SS",delay=-10)

            To specify the start time of activity act is exactly 50, we use two temporal constraints:

            >>> t=model.addTemporal("source",act,type="SS",delay=50)

            >>> t=model.addTemporal(act,"source",type="SS",delay=50)
        """
        # t = Temporal(pred, succ, tempType, delay)
        t = Temporal(pred, succ, tempType, delay, pred_mode, succ_mode)
        self.tempo.append(t)
        # self.temporals[pred.name,succ.name]=None
        return t

    def addState(self, name=""):
        """
        Add a state to the model.

            - Arguments:
                - name: Name for new state. Remark that strings in OptSeq are restricted to a-z, A-Z, 0-9,[],_ and @.

            - Return value: New state object.

            - Example usage:

            >>> a = model.addState("state1")

        """
        s = State(name)
        self.state.append(s)
        # self.states[name]=s
        return s

    def update(self):
        """
        prepare a string representing the current model in the OptSeq input format
        """
        makespan = self.Params.Makespan

        f = []

        self.resources = {}  # dictionary of resources that maps res-name to res-object
        for r in self.res:
            self.resources[r.name] = r
            f.append(str(r))

        self.states = (
            {}
        )  # dictionary of activities that maps state-name to state-object
        for s in self.state:
            self.states[s.name] = s
            f.append(str(s))

        self.modes = {}  # dictionary of modes that maps mode-name to mode-object
        for a in self.act:
            #             if len(a.modes) >= 2:
            #                 for m in a.modes:
            #                     self.modes[m.name] = m

            # １つのモードと2つ以上を区別しない実装
            for m in a.modes:
                self.modes[m.name] = m

        for m in self.modes:  # print mode information
            f.append("mode {0} ".format(m))
            f.append(str(self.modes[m]))

        self.activities = (
            {}
        )  # dictionary of activities that maps activity-name to activity-object
        for a in self.act:
            self.activities[a.name] = a
            f.append(str(a))

        # dictionary of temporal constraints that maps activity name pair to temporal-object
        self.temporals = {}
        for t in self.tempo:
            if t.pred == "source":
                pred = "source"
            elif t.pred == "sink":
                pred = "sink"
            else:
                pred = t.pred.name

            if t.succ == "source":
                succ = "source"
            elif t.succ == "sink":
                succ = "sink"
            else:
                succ = t.succ.name

            self.temporals[(pred, succ)] = t
            f.append(str(t))

        # non-renewable constraint
        for r in self.res:
            self.resources[r.name] = r
            if len(r.terms) > 0:
                f.append(r.printConstraint())

        if makespan:
            f.append("activity sink duedate 0 \n")
        return " \n".join(f)

    def optimize(
        self,
        cloud=False,
        init_fn="optseq_best_act_data.txt",
        best_fn="optseq_best_act_data.txt",
    ):
        """
        Optimize the model using optseq.exe in the same directory.

            - Example usage:

            >>> model.optimize()
        """
        LOG = self.Params.OutputFlag
        f = self.update()
        if cloud:
            input_file_name = f"optseq_input{dt.datetime.now().timestamp()}.txt"
            f2 = open(input_file_name, "w")
            p = pathlib.Path(".")  # 現在のフォルダ
            script = p / "scripts/optseq"
        else:
            f2 = open("optseq_input.txt", "w")
            script = "./optseq"

        f2.write(f)
        f2.close()

        import subprocess

        if platform.system() == "Windows":
            cmd = f"optseq "
        elif platform.system() == "Darwin":
            if platform.mac_ver()[2] == "arm64":  # model
                cmd = f"{script}-m1 "
            else:
                cmd = f"{script}-mac "
        elif platform.system() == "Linux":
            cmd = f"{script}-linux "

            p = pathlib.Path(".")  # 現在のフォルダ
            # github action でエラーするため消しておく
            # exe_file = p / "scripts/optseq-linux"
            # os.chmod(exe_file, 0o775)
        else:
            print(platform.system(), "may not be supported.")
        cmd += (
            "-time "
            + str(self.Params.TimeLimit)
            + " -backtrack  "
            + str(self.Params.Backtruck)
            + " -iteration  "
            + str(self.Params.MaxIteration)
            + " -report     "
            + str(self.Params.ReportInterval)
            + " -seed      "
            + str(self.Params.RandomSeed)
            + " -tenure    "
            + str(self.Params.Tenure)
            + " -neighborhood   "
            + str(self.Params.Neighborhood)
        )

        if self.Params.Initial:
            cmd += f" -initial {init_fn}"
        # print ("cmd=",cmd)
        try:
            if platform.system() == "Windows":
                pipe = subprocess.Popen(
                    cmd.split(),
                    stdout=subprocess.PIPE,
                    stdin=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    shell=True,
                )
            else:
                pipe = subprocess.Popen(
                    cmd,
                    stdout=subprocess.PIPE,
                    stdin=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    shell=True,
                )
            if LOG:
                print("\n ================ Now solving the problem ================ \n")
            out, err = pipe.communicate(f.encode())  # get the result

            if out == b"":
                print("error: could not execute command")
                print("please check that the solver is in the path")
                f2 = open("optseq_error.txt", "w")
                f2.write("error: could not execute command")
                f2.close()
                self.Status = 7  # execution falied
                # exit(0)
                return

        except OSError:
            print("error: could not execute command")
            print("please check that the solver is in the path")
            f2 = open("optseq_error.txt", "w")
            f2.write("error: could not execute command")
            f2.close()
            self.Status = 7  # execution falied
            # exit(0)
            return

        if cloud:
            os.remove(input_file_name)

        # for Python 3
        if int(sys.version_info[0]) >= 3:
            out = str(out, encoding="utf-8")

        if LOG==2:
            print("\noutput:")
            print(out)
        if LOG:
            print("\nSolutions:")

        """
        optseq output file
        """
        if cloud:
            pass
        else:
            f3 = open("optseq_output.txt", "w")
            f3.write(out)
            f3.close()

        # OptSeq didn't implenent the return number
        # check the return code
        # self.Status = pipe.returncode
        # if self.Status !=0: #if the return code is not "optimal", then return
        #    print("Status=",self.Status)
        #    print("Output=",out)
        #    return

        # search strings
        infeasible = out.find("no feasible schedule found")
        if infeasible > 0:
            print("infeasible solution")
            self.Status = -1  # infeasible
            return
        self.Status = 0  # optimized
        s0 = "--- best solution ---"
        s1 = "--- tardy activity ---"
        s2 = "--- resource residuals ---"
        s3 = "--- best activity list ---"  # added for optseq 3.0
        s4 = "objective value ="
        pos0 = out.find(s0) + len(s0)  # job data start position
        pos1 = out.find(s1, pos0)  # data end position
        pos2 = out.find(s2, pos1)
        pos3 = out.find(s3, pos2)
        pos4 = out.find(s4, pos3)
        # print("data positions",pos0,pos1,pos2,pos3,pos4)
        data = out[pos0:pos1]
        resdata = out[pos2 + len(s2) : pos3]
        data = data.splitlines()
        reslines = resdata.splitlines()
        # 目的関数値を得る
        remain_data = out[pos4:].split()
        self.ObjVal = int(remain_data[3])

        # save the best activity list
        bestactdata = out[pos3 + len(s3) : pos4]
        if cloud:
            pass
        else:
            f3 = open(best_fn, "w")
            f3.write(bestactdata.lstrip())
            f3.close()

        for line in reslines:
            if len(line) <= 1:
                continue
            current = line.split()
            resname = current[0][:-1]
            residual = current[1:]
            count = 0
            resDic = {}  # residual capacity
            while count < len(residual):
                interval = residual[count].split(",")
                int1 = int(interval[0][1:])
                int2 = int(interval[1][:-1])
                count += 1
                num = int(residual[count])
                count += 1
                resDic[(int1, int2)] = num
            # print(resname,residual)
            self.resources[resname].residual = resDic

        # job data conversion
        execute = []
        for i in range(len(data)):
            replaced = data[i].replace(",", " ")
            current = replaced.split()  # split by space
            # print(current)
            if len(current) > 1:
                execute.append(current)
        for line in execute:
            # print("line=",line)
            actname = line[0]
            mode = line[1]
            try:
                start = line[2]
            except:
                print("Problem is infeasible")
                # exit(0)
                self.Status = -1
                return

            execute = line[3:-1]  # list for breakable activity
            completion = line[-1]
            if LOG:
                print(
                    "{0:>10} {1:>5} {2:>5} {3:>5}".format(actname, mode, start, completion)
                )
            # print("execute=",execute)
            if actname == "source":
                pass
            elif actname == "sink":
                pass
            else:
                self.activities[actname].start = int(start)
                self.activities[actname].completion = int(completion)
                if mode != "---":
                    self.activities[actname].selected = self.modes[mode]
                else:
                    self.activities[actname].selected = self.activities[actname].modes[
                        0
                    ]
                exeDic = {}
                for exe in execute:
                    exedata = exe.split("--")
                    start = exedata[0]
                    completion = exedata[1]
                    idx = completion.find("[")
                    # for parallel execution
                    if idx > 0:
                        parallel = completion[idx + 1 : -1]
                        completion = completion[:idx]
                        # print(completion,idx,parallel)
                    else:
                        parallel = 1
                    exeDic[(int(start), int(completion))] = int(parallel)
                self.activities[actname].execute = exeDic
        return

    def write(self, filename="optseq_chart.txt"):
        """
        Output the gantt's chart as a text file.

            - Argument:
                - filename: Output file name. Default="optseq_chart.txt."

            - Example usage:

            >>> model.write("sample.txt")

        """
        f = open(filename, "w")

        horizon = 0
        actList = []
        for a in self.activities:
            actList.append(a)
            act = self.activities[a]
            horizon = max(act.completion, horizon)
        # print("planning horizon=",horizon)
        actList.sort()
        title = " activity    mode".center(20) + " duration "

        width = len(str(horizon))  # period width =largest index of time
        for t in range(horizon):
            num = str(t + 1)
            title += num.rjust(width) + ""
        # print(title)
        f.write(title + "\n")
        f.write("-" * (30 + (width + 1) * horizon) + "\n")
        for a in actList:  # sorted order
            act = self.activities[a]  # act: activity object
            actstring = act.name.center(10)[:10]
            if len(act.modes) >= 2 and act.selected.name is not None:
                actstring += str(act.selected.name).center(10)
                actstring += str(self.modes[act.selected.name].duration).center(10)
                # print(" executed on resource:")
                # print(self.modes[act.selected.name].requirement,model.modes[act.selected.name].rtype)
            else:
                # print("executed on resource:")
                # print(act.modes[0].requirement,act.modes[0].rtype)
                actstring += str(act.modes[0].name).center(10)[:10]
                actstring += str(act.modes[0].duration).center(10)
            execute = [0 for t in range(horizon)]
            for s, c in act.execute:
                para = act.execute[s, c]
                for t in range(s, c):
                    execute[t] = int(para)

            for t in range(horizon):
                if execute[t] >= 2:
                    # for res_name in self.modes[act.selected.name].requirement:
                    # print(res_name)
                    # print(model.modes[act.selected.name].rtype)
                    # print(self.modes[act.selected.name])
                    actstring += "*" + str(execute[t]).rjust(width - 1)
                elif execute[t] == 1:
                    actstring += "" + "=" * (width)
                elif t >= act.start and t < act.completion:
                    actstring += "" + "." * (width)
                else:
                    actstring += "" + " " * width
            actstring += ""
            # print(actstring)
            f.write(actstring + "\n")
        # print(act.name +"  starts at "+str(act.start)+" and finish at " +str(act.completion))
        # print("  and is executed :"+str(act.execute)])

        f.write("-" * (30 + (width + 1) * horizon) + "\n")
        f.write("resource usage/capacity".center(30) + " \n")
        f.write("-" * (30 + (width + 1) * horizon) + "\n")
        resList = []
        for r in self.resources:
            resList.append(r)
        resList.sort()
        for r in resList:
            res = self.resources[r]
            if len(res.terms) == 0:  # output residual and capacity
                rstring = res.name.center(30)
                cap = [0 for t in range(horizon)]
                residual = [0 for t in range(horizon)]
                for s, c in res.residual:
                    amount = res.residual[(s, c)]
                    if c == "inf":
                        c = horizon
                    s = min(s, horizon)
                    c = min(c, horizon)
                    for t in range(s, c):
                        residual[t] += amount

                for s, c in res.capacity:
                    amount = res.capacity[(s, c)]
                    if c == "inf":
                        c = horizon
                    s = min(s, horizon)
                    c = min(c, horizon)
                    for t in range(s, c):
                        cap[t] += amount

                for t in range(horizon):
                    num = str(cap[t] - residual[t])
                    rstring += "" + num.rjust(width)
                f.write(rstring + "\n")

                rstring = str(" ").center(30)

                for t in range(horizon):
                    num = str(cap[t])
                    rstring += "" + num.rjust(width)
                f.write(rstring + "\n")
                f.write("-" * (30 + (width + 1) * horizon) + "\n")
        f.close()

    def writeExcel(self, filename="optseq_chart.csv", scale=1):
        """
        Output the gantt's chart as a csv file for printing using Excel.

            - Argument:
                - filename: Output file name. Default="optseq_chart.csv."

            - Example usage:

            >>> model.writeExcel("sample.csv")

        """
        f = open(filename, "w")
        horizon = 0
        actList = []
        for a in self.activities:
            actList.append(a)
            act = self.activities[a]
            horizon = max(act.completion, horizon)
        # print("planning horizon=",horizon)
        if scale <= 0:
            print("optseq write scale error")
            exit(0)
        original_horizon = horizon
        horizon = int(horizon / scale) + 1
        actList.sort()
        title = " activity ,   mode,".center(20) + " duration,"
        width = len(str(horizon))  # period width =largest index of time
        for t in range(horizon):
            num = str(t + 1)
            title += num.rjust(width) + ","
        f.write(title + "\n")
        for a in actList:  # sorted order
            act = self.activities[a]  # act: activity object
            actstring = act.name.center(10)[:10] + ","
            if len(act.modes) >= 2:
                actstring += str(act.selected.name).center(10) + ","
                actstring += (
                    str(self.modes[act.selected.name].duration).center(10) + ","
                )
            else:
                actstring += str(act.modes[0].name).center(10)[:10] + ","
                actstring += str(act.modes[0].duration).center(10) + ","
            execute = [0 for t in range(horizon)]
            for s, c in act.execute:
                para = act.execute[s, c]
                for t in range(s, c):
                    t2 = int(t / scale)
                    execute[t2] = int(para)
            for t in range(horizon):
                if execute[t] >= 2:
                    actstring += "*" + str(execute[t]).rjust(width - 1) + ","
                elif execute[t] == 1:
                    actstring += "" + "=" * (width) + ","
                elif t >= int(act.start / scale) and t < int(act.completion / scale):
                    actstring += "" + "." * (width) + ","
                else:
                    actstring += "" + " " * width + ","
            f.write(actstring + "\n")
        resList = []
        for r in self.resources:
            resList.append(r)
        resList.sort()

        for r in resList:
            res = self.resources[r]
            if len(res.terms) == 0:  # output residual and capacity
                rstring = res.name.center(30) + ", , ,"
                cap = [0 for t in range(horizon)]
                residual = [0 for t in range(horizon)]
                for s, c in res.residual:
                    amount = res.residual[(s, c)]
                    if c == "inf":
                        c = horizon
                    s = min(s, original_horizon)
                    c = min(c, original_horizon)
                    s2 = int(s / scale)
                    c2 = int(c / scale)
                    for t in range(s2, c2):
                        residual[t] += amount

                for s, c in res.capacity:
                    amount = res.capacity[(s, c)]
                    if c == "inf":
                        c = horizon
                    s = min(s, original_horizon)
                    c = min(c, original_horizon)
                    s2 = int(s / scale)
                    c2 = int(c / scale)
                    for t in range(s2, c2):
                        cap[t] += amount

                for t in range(horizon):
                    # num=str(cap[t]-residual[t])
                    rstring += str(residual[t]) + ","
                f.write(rstring + "\n")

                # rstring= str(" ").center(30)+", , ,"
                #
                # for t in range(horizon):
                #    num=str(cap[t])
                #    rstring+=""+num.rjust(width) +","
                # f.write(rstring+"\n")
        f.close()

# %% ../nbs/07optseq.ipynb 40
def visualize(model):
    g = graphviz.Digraph("G", filename="optseq.gv")
    g.graph_attr["rankdir"] = "LR"

    for r, res in model.resources.items():
        g.node(name=r, shape="trapezium", color="green")

    for a, act in model.activities.items():
        with g.subgraph(name=f"cluster[{a}]") as c:
            c.attr(style="filled", color="lightgrey")
            c.node(name=a, shape="rectangle", color="red")
            for mode in act.modes:
                c.node(name=mode.name, shape="box3d", color="blue")
                c.edge(a, mode.name, arrowhead="tee", style="dotted", color="blue")
                for rname, rtype in mode.requirement:
                    g.edge(
                        mode.name,
                        rname,
                        arrowhead="box",
                        label=rtype,
                        style="dashed",
                        color="green",
                    )

    for t, temp in model.temporals.items():
        if temp.pred == "source":
            pred = "source"
        elif temp.pred == "sink":
            pred = "sink"
        else:
            pred = temp.pred.name
        if temp.succ == "source":
            succ = "source"
        elif temp.succ == "sink":
            succ = "sink"
        else:
            succ = temp.succ.name
        if pred == "source" or pred == "sink":
            g.node(name=pred, shape="oval", color="red")
        if succ == "source" or succ == "sink":
            g.node(name=succ, shape="oval", color="red")
        if temp.type != "CS":
            label = temp.type
        else:
            label = ""
        if temp.delay > 0:
            label += f"({temp.delay})"

        g.edge(pred, succ, arrowhead="open", label=label)
    return g

# %% ../nbs/07optseq.ipynb 42
def plot_optseq(file_name: str = "optseq_output.txt"):
    with open(file_name) as f:
        out = f.readlines()
    x, y = [], []
    for l in out[7:]:
        sep = re.split("[=()/]", l)
        # print(sep)
        if sep[0] == "--- best solution ---\n":
            break
        if sep[0] == "objective value ":
            val, cpu = map(float, [sep[1], sep[3]])
            x.append(cpu)
            y.append(val)
    fig = go.Figure()
    fig.add_trace(
        go.Scatter(
            x=x,
            y=y,
            mode="markers+lines",
            name="value",
            marker=dict(size=10, color="black"),
        )
    )
    fig.update_layout(
        title="OptSeq performance", xaxis_title="CPU time", yaxis_title="Value"
    )
    return fig

# %% ../nbs/07optseq.ipynb 46
def time_convert_long(periods, start="2019/1/1", period="days"):
    start = pd.to_datetime(start)
    if period == "days":
        time_ = start + dt.timedelta(days=float(periods))
    elif period == "hours":
        time_ = start + dt.timedelta(hours=float(periods))
    elif period == "minutes":
        time_ = start + dt.timedelta(minutes=float(periods))
    elif period == "seconds":
        time_ = start + dt.timedelta(seconds=float(periods))
    else:
        raise TypeError("pariod must be 'days' or 'seconds' or minutes' or 'days'")
    return time_.strftime("%Y-%m-%d %H:%M:%S")

# %% ../nbs/07optseq.ipynb 47
def make_gannt(
    model: Model,
    start: str = "2024/1/1",
    period: str = "days",
    begin: int = 0,
    end: Union[int, str] = "inf",
    resources: Optional[Set] = None,
) -> plotly.graph_objs._figure.Figure: 
    """
    ガントチャートを生成する関数
    """
    if resources is None:  # 制限なし
        resources = []
        for res in model.res:
            resources.append(res.name)
        resources = set(resources)

    if end == "inf":
        end = 0
        for a in model.act:
            end = max(a.completion, end)

    # 資源ごとに区間木を準備する
    interval_tree = {}
    for r in resources:
        # res = model.resources[r]
        interval_tree[r] = IntervalTree()

    for i in model.activities:
        a = model.activities[i]
        if a.selected is not None:
            m = a.selected  # mode selected
            for r, _ in m.requirement:
                if r in resources:
                    interval_tree[r][a.start : a.completion] = a

    L = []
    for r in resources:
        res = model.resources[r]
        for interval in interval_tree[r][begin:end]:  # 資源ごとの区間木 => 区間オブジェクトを返す
            act = interval.data
            st = time_convert_long(interval.begin, start=start, period=period)
            fi = time_convert_long(interval.end, start=start, period=period)
            L.append(dict(Task=act.name, Start=st, Finish=fi, Resource=r))

    df = pd.DataFrame(L)
    fig = px.timeline(
        df, x_start="Start", x_end="Finish", y="Resource", color="Task", opacity=0.5
    )
    return fig

# %% ../nbs/07optseq.ipynb 52
def make_resource_usage(
    model: Model,
    # start: str = "2024/1/1",
    # period: str = "days",
    begin: int = 0,
    end: Union[int, str] = "inf",
    width: int = 1000, 
    resources: Optional[Set] = None
) -> Tuple[plotly.graph_objs._figure.Figure, pd.DataFrame]: 
    # begin = 0
    # end = "inf"
    # width = 10000 #占有率を計算する幅
    # resources = None 
    
    if resources is None:  # 制限なし
        resources = []
        for res in model.res:
            resources.append(res.name)
        resources = set(resources)
    
    if end == "inf":
        end = 0
        for a in model.act:
            end = max(a.completion, end)
    
    # 資源ごとに作業と容量を表す区間木を準備する
    interval_tree, interval_tree_rest = {}, {}
    for r in resources:
        # res = model.resources[r]
        interval_tree[r] = IntervalTree()
        interval_tree_rest[r] = IntervalTree()
    
    #資源ごとの区間木に作業の開始と終了の区間を入れる
    for i in model.activities:
        a = model.activities[i]
        if a.selected is not None:
            m = a.selected  # mode selected
            for r, _ in m.requirement:
                if r in resources:
                    interval_tree[r][a.start : a.completion] = a
    
    #容量の情報を区間木にいれる
    for r in resources:
        t = 0
        #model.resources[r].capacity = {(0,100):1, (120,"inf"):2} #テスト用
        for (st,fi) in model.resources[r].capacity:
            cap = model.resources[r].capacity[st, fi]
            if fi == "inf":
                fi = end
            interval_tree_rest[r][st:fi] =  cap
    
    #各start, finish間の稼働時間と容量を計算
    
    total_duration = defaultdict(int)
    total_capacity = defaultdict(int)
    
    start = begin
    finish = start + width
    while finish < end:         
        for r in resources:
            for interval in interval_tree[r][start:finish]:  
                act = interval.data
                total_duration[r,start,finish] +=  act.completion-act.start
                total_duration[r,start,finish] -= max(0, act.completion-finish)
                total_duration[r,start,finish] -= max(0, start-act.start)
                
            for interval in interval_tree_rest[r][start:finish]:  
                cap = interval.data
                total_capacity[r,start,finish] +=  (interval.end - interval.begin)*cap
                total_capacity[r,start,finish] -= max(0, (interval.end-finish)*cap)
                total_capacity[r,start,finish] -= max(0, (start-interval.begin)*cap)
        start += width
        finish = start + width
        
    idx, ratio, resource = [], [], []
    for r, start,finish in total_capacity:
        #print(r, start, finish, total_duration[r,start,finish]/total_capacity[r,start,finish])
        ratio.append(total_duration[r,start,finish]/total_capacity[r,start,finish])
        resource.append(r)
        idx.append(start)
    df = pd.DataFrame({"idx":idx, "ratio":ratio, "resource":resource})
    fig = px.line(df, x= "idx", y = "ratio", color ="resource" )
    return fig, df

# %% ../nbs/07optseq.ipynb 56
def make_resource_graph(
    model: Model,
    start: str = "2024/1/1",
    period: str = "days",
    scale: int = 1,
    begin: int = 0,
    end: Union[int, str] = "inf",
    resources: Optional[Set] = None,
):
    """
    資源の使用量と残差（容量-使用量）を図示する関数
    """

    if resources is None:  # 制限なし
        resources = []
        for res in model.res:
            resources.append(res.name)
        resources = set(resources)

    if end == "inf":
        end = 0
        for a in model.act:
            end = max(a.completion, end)

    horizon = end - begin

    count = 0
    resource_list = []
    for r in resources:
        res = model.resources[r]
        if len(res.terms) == 0:  # 左辺がないので再生可能資源
            count += 1
            resource_list.append(res.name)

    if count >= 1:  # Plotlyのサブプロットを準備
        fig = make_subplots(rows=count, cols=1, subplot_titles=resource_list)
    else:
        fig = {}
        # return fig #空の図を返す

    for count, r in enumerate(resource_list):
        res = model.resources[r]

        cap = defaultdict(int)
        residual = defaultdict(int)
        usage = defaultdict(int)

        # compute residual
        for s, c in res.residual:
            amount = res.residual[(s, c)]
            if c == "inf":
                c = end
            if c <= begin:
                continue
            if end <= s:
                break

            s = min(s, end)
            c = min(c, end)
            for t in range(s, c):
                residual[t] += amount
        # compute capacity
        for s, c in res.capacity:
            amount = res.capacity[(s, c)]
            if c == "inf":
                c = end
            if c <= begin:
                continue
            if end <= s:
                break

            s = min(s, end)
            c = min(c, end)
            for t in range(s, c):
                cap[t] += amount
        # compute usage
        for t in range(begin, end):
            usage[t] = cap[t] - residual[t]

        # リストに格納
        usage_list, residual_list = [], []
        for t in range(begin, end):
            usage_list.append(usage[t])
            residual_list.append(residual[t])

        # スケーリング
        horizon2 = int(horizon / scale)
        t = 0
        usage2 = []
        residual2 = []
        for i in range(horizon2):
            average_usage = 0
            average_residual = 0
            for j in range(scale):
                average_usage += usage_list[t]
                average_residual += residual_list[t]
                t += 1
            usage2.append(average_usage / scale)
            residual2.append(average_residual / scale)
        t = 0
        x = []
        for i in range(horizon2):
            x.append(time_convert_long(t, start=start, period=period))
            t += scale

        fig.add_trace(
            go.Bar(name="Usage", x=x, y=usage2, marker_color="crimson"),
            row=count + 1,
            col=1,
        )
        fig.add_trace(
            go.Bar(name="Residual", x=x, y=residual2, marker_color="lightslategrey"),
            row=count + 1,
            col=1,
        )
    fig.update_layout(barmode="stack", title_text=f"Capacity/Usage", showlegend=False)
    return fig

# %% ../nbs/07optseq.ipynb 64
def compute_horizon(model: Model) -> int:
    horizon = 0
    for a in model.act:
        max_duration = 0
        for m in a.modes:
            max_duration = max(max_duration, m.duration)
        horizon +=max_duration

    for r in model.res:
        t = 0
        for (st,fi) in r.capacity:
            if t < st: #以前の終了から開始までの期間が休み
                horizon += st-t
            t = fi
    return horizon

# %% ../nbs/07optseq.ipynb 65
def transform_to_cp(model: Model, horizon:int):

    model.update()

    #容量１の資源は機械として別処理をする． termsがあるものは再生不能資源（絶対制約とする）
    machines = set([])
    resources = set([])
    nonrenewable = set([])
    
    #資源の分類
    for r in model.res:
        if len(r.terms) > 0: #再生不能資源
            nonrenewable.add(r.name)
        elif r.capacity == 1: #機械
            machines.add(r.name)
        else: #一般の資源
            max_cap = 0
            for (st,fi), cap in r.capacity.items():
                #print(st,fi, cap)
                max_cap = max(max_cap, cap)
            if max_cap==1:
                machines.add(r.name)
            else:
                resources.add(r.name)
            
    cpmodel = CpModel()
    
    start, end, act = {}, {}, {}
    selected = {} #複数モード用
    activities_on_machine = defaultdict(list)
    modes_for_act = defaultdict(list)

    all_ends = set([]) #メイクスパン計算用
    for a in model.act:
        start[a.name] = cpmodel.new_int_var(0, horizon, f'start({a.name})')
        end[a.name] = cpmodel.new_int_var(0, horizon, f'end({a.name})')
    
        for m in a.modes:
            duration = m.duration
            #複数モードの optional_interval_var
            selected[a.name,m.name] = cpmodel.new_bool_var(f'selected({a.name,m.name})') #モードの選択を表すブール変数
            act[a.name,m.name] = cpmodel.new_optional_interval_var(
                                  start[a.name], duration, end[a.name], selected[a.name,m.name],
                                  f'act({a.name,m.name})')
            modes_for_act[a.name].append( selected[a.name,m.name] )
    
            all_ends.add(end[a.name])
    
            if m.requirement is not None:
                for (r, _), req in m.requirement.items():
                    if r in machines: #機械 (add_no_overlap)
                        activities_on_machine[r].append( act[a.name,m.name] )
                    else:
                        #容量2以上の資源 (add_cumulative) 
                        activities_on_machine[r].append( (act[a.name,m.name], req) )
                        
        cpmodel.add_exactly_one( modes_for_act[a.name] ) #１つのモードを選択
    
    #資源量上限が1の機械に対する制約
    for r in machines:
        #使用不能な時間帯にダミーの作業を配置
        t = 0
        dummy_acts = []
        for (st,fi) in model.resources[r].capacity:
            if t < st: #以前の終了から開始までの期間が休み
                dummy_acts.append( cpmodel.NewIntervalVar(t, st-t, st, f'machine_stop({r}_{st}_{fi})') )
            t = fi
        cpmodel.add_no_overlap( activities_on_machine[r]+dummy_acts )
    
    #機械以外の資源制約
    for r in resources:
        demand =[]
        for (_, req)  in activities_on_machine[r]:
            for (st,fi), dem in req.items():
                demand.append(dem)
                continue
        capacity = 0 
        for (st,fi), cap in model.resources[r].capacity.items():
            capacity = max(capacity, cap)
        #使用不能な時間帯にダミーの作業を配置
        t = 0
        dummy_acts, dummy_demands = [], []
        for (st,fi), cap in model.resources[r].capacity.items():
            if t < st: #最初の期間が休み
                dummy_acts.append( cpmodel.NewIntervalVar(t, st-t, st, f'machine_stop({r}_{st}_{fi})') )
                dummy_demands.append(capacity)
            if capacity -cap > 0: #不足分をダミーで配置
                dummy_acts.append( cpmodel.NewIntervalVar(st, fi-st, fi, f'machine_stop({r}_{st}_{fi})') )
                dummy_demands.append(capacity - cap)
            t = fi
                
        cpmodel.add_cumulative(intervals =[activity for (activity,_ )  in activities_on_machine[r]],
                               demands = demand, capacity = capacity)
    #再生不能資源
    constraint ={}
    for r in nonrenewable:
        res = model.resources[r]
        if res.direction == "<" or res.direction == "<=":
            constraint[r] = cpmodel.add(
                sum( coeff* selected[a.name,m.name] for (coeff, a, m) in res.terms ) <= int(res.rhs) )
        elif res.direction == "=" or res.direction == "==":
            constraint[r] = cpmodel.add(
                sum( coeff* selected[a.name,m.name] for (coeff, a, m) in res.terms ) == int(res.rhs) )
        elif res.direction == "=" or res.direction == ">=":
            constraint[r] = cpmodel.add(
                sum( coeff* selected[a.name,m.name] for (coeff, a, m) in res.terms ) >= int(res.rhs) )
        else:
            raise TypeError("constraint direction musr be <=, =, or >=")
            
    #時間制約（source,sink間の時間制約は考慮していない） => sourceは0, sinkはmakespanを追加すればできる
    #リリース時刻は開始時刻の範囲を限定した方が効率的なので，sourceとの時間制約ではなく，　別途処理する！
    for temp in model.tempo:
        if temp.pred_mode is None and temp.succ_mode is None: #モードに依存しない時間遅れをもつ時間制約
            if temp.type =="CS":
                cpmodel.add(end[temp.pred.name] + temp.delay <=start[temp.succ.name])
            elif temp.type =="CC":
                cpmodel.add(end[temp.pred.name] + temp.delay <=end[temp.succ.name])
            elif temp.type =="SS":
                cpmodel.add(start[temp.pred.name] + temp.delay <=start[temp.succ.name])
            elif temp.type =="SC":
                cpmodel.add(start[temp.pred.name] + temp.delay <=end[temp.succ.name])
        else: #モードに依存する時間遅れをもつ時間制約
            if temp.pred_mode is not None and temp.succ_mode is None: #先行ジョブのみモード依存
                if temp.type =="CS":
                    cpmodel.add(end[temp.pred.name] + temp.delay <=start[temp.succ.name]).OnlyEnforceIf(
                        selected[temp.pred.name,temp.pred_mode.name])
                elif temp.type =="CC":
                    cpmodel.add(end[temp.pred.name] + temp.delay <=end[temp.succ.name]).OnlyEnforceIf(
                        selected[temp.pred.name,temp.pred_mode.name])
                elif temp.type =="SS":
                    cpmodel.add(start[temp.pred.name] + temp.delay <=start[temp.succ.name]).OnlyEnforceIf(
                        selected[temp.pred.name,temp.pred_mode.name])
                elif temp.type =="SC":
                    cpmodel.add(start[temp.pred.name] + temp.delay <=end[temp.succ.name]).OnlyEnforceIf(
                        selected[temp.pred.name,temp.pred_mode.name])
            elif temp.pred_mode is None and temp.succ_mode is not None: #後続ジョブのみモード依存
                if temp.type =="CS":
                    cpmodel.add(end[temp.pred.name] + temp.delay <=start[temp.succ.name]).OnlyEnforceIf(
                        selected[temp.succ.name,temp.succ_mode.name])
                elif temp.type =="CC":
                    cpmodel.add(end[temp.pred.name] + temp.delay <=end[temp.succ.name]).OnlyEnforceIf(
                        selected[temp.succ.name,temp.succ_mode.name])
                elif temp.type =="SS":
                    cpmodel.add(start[temp.pred.name] + temp.delay <=start[temp.succ.name]).OnlyEnforceIf(
                        selected[temp.succ.name,temp.succ_mode.name])
                elif temp.type =="SC":
                    cpmodel.add(start[temp.pred.name] + temp.delay <=end[temp.succ.name]).OnlyEnforceIf(
                        selected[temp.succ.name,temp.succ_mode.name])
            else: #先行ジョブ，後続ジョブともにモード依存
                if temp.type =="CS":
                    cpmodel.add(end[temp.pred.name] + temp.delay <=start[temp.succ.name]).OnlyEnforceIf(
                        [selected[temp.pred.name,temp.pred_mode.name], selected[temp.succ.name,temp.succ_mode.name]] )
                elif temp.type =="CC":
                    cpmodel.add(end[temp.pred.name] + temp.delay <=end[temp.succ.name]).OnlyEnforceIf(
                        [selected[temp.pred.name,temp.pred_mode.name], selected[temp.succ.name,temp.succ_mode.name]] )
                elif temp.type =="SS":
                    cpmodel.add(start[temp.pred.name] + temp.delay <=start[temp.succ.name]).OnlyEnforceIf(
                        [selected[temp.pred.name,temp.pred_mode.name], selected[temp.succ.name,temp.succ_mode.name]] )
                elif temp.type =="SC":
                    cpmodel.add(start[temp.pred.name] + temp.delay <=end[temp.succ.name]).OnlyEnforceIf(
                        [selected[temp.pred.name,temp.pred_mode.name], selected[temp.succ.name,temp.succ_mode.name]] )
        
    if model.Params.Makespan: #メイクスパン
        obj = cpmodel.new_int_var(0, horizon, 'makespan')
        cpmodel.add_max_equality(obj, list(all_ends) )
        cpmodel.minimize(obj)
    else: #納期遅れ最小化
        delay = {}
        for a in model.act:
            delay[a.name] = cpmodel.new_int_var(0, horizon, f'delay({a.name})')
            if a.duedate=="inf":
                a.duedate = horizon
            cpmodel.add( delay[a.name] >= end[a.name]-a.duedate )
        cpmodel.minimize( sum( a.weight*delay[a.name] for a in model.act)  )

    # Solve model
    solver = CpSolver()
    solver.parameters.max_time_in_seconds = model.Params.TimeLimit 
    solver.parameters.log_search_progress = model.Params.OutputFlag
    
    status = solver.Solve(cpmodel)

    if status == cp_model.OPTIMAL or status == cp_model.FEASIBLE: 
        model.ObjVal = int(solver.ObjectiveValue())
        model.Status = status
        for a_name, a in model.activities.items():
            for m in a.modes:
                if solver.value(selected[a_name,m.name]):
                    a.selected = m
        for a_name, a in model.activities.items():
            a.start = solver.value(start[a_name])
            a.completion = solver.value(end[a_name])
            a.execute = {(a.start, a.completion): 1}
    elif status == cp_model.INFEASIBLE:
        model.Status = -1
    else:
        model.Status = status 
    
    return cpmodel

# %% ../nbs/07optseq.ipynb 85
def data_visualize(model: Model):
    model.update()
    scale = 10
    duration = []
    duedate = []
    for a_name, a in model.activities.items():
        duedate.append(a.duedate)
        for m in a.modes:
            duration.append(m.duration)
                
    df = pd.DataFrame({"duration": duration})
    df2 = pd.DataFrame({"duedate": duedate})
    fig = px.histogram(df, x="duration") 
    fig2 = px.histogram(df2, x="duedate")  
    return fig, fig2

# %% ../nbs/07optseq.ipynb 88
class Job(object):
    """
    A class that creates jobs.

    Parameters
    ----------
    r: list - 機械の順序を表すリスト
    p: list - 作業時間のリスト
    """

    def __init__(self, Id, r, p):
        self.Id = Id
        self.r = r  # machine number 
        self.p = p  # processing time

class Jobshop(nx.DiGraph):
    """
    A class that creates a directed graph of a jobshop.

    We formulate the tasks of the jobshop as nodes in a directed graph, add the processing 
    times of the tasks as attributes to the task nodes. A flag "dirty" was added so when 
    some topological changes are carried the method "_update" is called first to update 
    the makespan and critical path values. Once the update is finished, the updated 
    makespan is returned.

    Methods
    -------
    handleJobRoutings(jobs)
        Creates the edges of the graph that represents the given route and also adds 
        the origin and finishing nodes.

    handleJobProcessingTimes(jobs)
        Creates the nodes of the graph that represent the tasks of a job.

    makeMachineSubgraphs()
        For every given machine creates a subgraph.

    addJobs(jobs)
        Handles the routine to add a jobs to the graph and the subgraphs.

    output()
        Prints the output. 
    
    _forward

    _backward

    _computeCriticalPath

    _update

    Properties
    ----------
    makespan

    criticalPath

    """

    def __init__(self):
        super().__init__()
        #a dictionary to store machine's id of a subgraph with its jobs and routing
        self.machines = {}
        #start node
        self.add_node("U", p=0)
        #finish node
        self.add_node("V", p=0)
        #set dirty flag
        self._dirty = True
        #set initial makespan
        self._makespan = -1
        #define criticla path
        self._criticalPath = None

    def add_node(self, *args, **kwargs):
        #adds dirty flag so the the _update subroutine is called 
        self._dirty = True
        super().add_node(*args, **kwargs)

    def add_nodes_from(self, *args, **kwargs):
        #adds dirty flag so the the _update subroutine is called 
        self._dirty = True
        super().add_nodes_from(*args, **kwargs)

    def add_edge(self, *args):
        #adds dirty flag so the the _update subroutine is called 
        self._dirty = True
        super().add_edge(*args)

    def add_edges_from(self, *args, **kwargs):
        #adds dirty flag so the the _update subroutine is called 
        self._dirty = True
        super().add_edges_from(*args, **kwargs)

    def remove_node(self, *args, **kwargs):
        #adds dirty flag so the the _update subroutine is called 
        self._dirty = True
        super().remove_node(*args, **kwargs)

    def remove_nodes_from(self, *args, **kwargs):
        #adds dirty flag so the the _update subroutine is called 
        self._dirty = True
        super().remove_nodes_from(*args, **kwargs)

    def remove_edge(self, *args):
        #adds dirty flag so the the _update subroutine is called 
        self._dirty = True
        super().remove_edge(*args)

    def remove_edges_from(self, *args, **kwargs):
        #adds dirty flag so the the _update subroutine is called 
        self._dirty = True
        super().remove_edges_from(*args, **kwargs)

    def handleJobRoutings(self, jobs):
        for j in jobs.values():
            #add start edge
            self.add_edge("U", (j.r[0], j.Id))
            #add the edges (processing order) routing the nodes (tasks)
            for m, n in zip(j.r[:-1], j.r[1:]):
                self.add_edge((m, j.Id), (n, j.Id))
            #add finishing edge
            self.add_edge((j.r[-1], j.Id), "V")

    def handleJobProcessingTimes(self, jobs):
        for j in jobs.values():
            #add every task and its corresponding processing time to the graph
            for m, p in zip(j.r, j.p):
                self.add_node((m, j.Id), p=p)

    def makeMachineSubgraphs(self):
        #creates a set with machines' ids
        machineIds = set(ij[0] for ij in self if ij[0] not in ("U", "V"))
        #for every machine in the digraph creates a subgraph linked to the id with the corresponfing nodes
        for m in machineIds:
            self.machines[m] = self.subgraph(ij for ij in self if ij[0] == m not in ("U", "V"))
            #self.machines[m].remove_nodes_from(["U", "V"])

    def addJobs(self, jobs):
        #every time a job is inserted: add the jobs' edges (routing), jobs' nodes (tasks), 
        # and creates a subgraph for every machine
        self.handleJobRoutings(jobs)
        self.handleJobProcessingTimes(jobs)
        self.makeMachineSubgraphs()

    def output(self):
        #neatly outputs the jobshop digraph
        for m in sorted(self.machines):
            for j in sorted(self.machines[m]):
                print("{}: {}".format(j, self.node[j]['C']))

    def _forward(self):
        for n in nx.topological_sort(self):
            S = max([self.nodes[j]['C'] for j in self.predecessors(n)], default = 0)
            self.add_node(n, S = S, C = S + self.nodes[n]['p'])

    def _backward(self):
        for n in list(reversed(list(nx.topological_sort(self)))):
            Cp = min([self.nodes[j]['Sp'] for j in self.successors(n)], default = self._makespan)
            self.add_node(n, Sp = Cp - self.nodes[n]['p'], Cp = Cp)

    def _computeCriticalPath(self):
        G = set()
        for n in self:
            if self.nodes[n]['C'] == self.nodes[n]['Cp']:
                G.add(n)
        self._criticalPath = self.subgraph(G)

    @property
    def makespan(self):
        if self._dirty:
            self._update()
        return self._makespan

    @property
    def criticalPath(self):
        if self._dirty:
            self._update()
        return self._criticalPath

    def _update(self):
        self._forward()
        self._makespan = max(nx.get_node_attributes(self, 'C').values())
        self._backward()
        self._computeCriticalPath()
        self._dirty = False

class Shift(Jobshop):
    def output(self):
        print("makespan: ", self.makespan)
        for i in self.machines:
            print("Machine: "+str(i))
            s = "{0:<7s}".format("jobs:")
            for ij in sorted(self.machines[i]):
                if ij in ("U", "V"):
                    continue
                s += "{0:>5d}".format(ij[1])
            print(s)
            s = "{0:<7s}".format("p:")
            for ij in sorted(self.machines[i]):
                if ij in ("U", "V"):
                    continue
                s += "{0:>5d}".format(self.nodes[ij]['p'])
            print(s)
            s = "{0:<7s}".format("r:")
            for ij in sorted(self.machines[i]):
                if ij in ("U", "V"):
                    continue
                s += "{0:>5d}".format(self.nodes[ij]['S'])
            print(s)
            s = "{0:<7s}".format("d:")
            for ij in sorted(self.machines[i]):
                if ij in ("U", "V"):
                    continue
                s += "{0:>5d}".format(self.nodes[ij]['Cp'])
            print(s)
            print("\n")

    def computeLmax2(self, remain:list, horizon:int, precedence:List = []):
        
        result = [] #機械ごとのLmaxの計算結果
        for m in remain:
            #print("machine=", m)            
            cpmodel = CpModel()
            
            jobs = list(self.machines[m])
            start, end, act, late ={},{},{},{}
            activities_on_machine =[]
            all_lates = []
            #horizon = max(self.nodes[j]['S'] for j in jobs ) + sum( self.nodes[j]['p'] for j in jobs 
            
            for j in jobs:
                start[j] = cpmodel.new_int_var(self.nodes[j]['S'] , horizon, f'start({j})')
                end[j] = cpmodel.new_int_var(self.nodes[j]['S']+self.nodes[j]['p'], horizon, f'end({j})')
                late[j] = cpmodel.new_int_var(0, horizon-self.nodes[j]['Cp'], f'late({j})')
                all_lates.append( late[j] )
                act[j] = cpmodel.new_interval_var(start[j], self.nodes[j]['p'], end[j], f'act({j})')
                activities_on_machine.append( act[j] )

                cpmodel.add( late[j] >= end[j] - self.nodes[j]['Cp'] )
            
            cpmodel.add_no_overlap( activities_on_machine )
            obj = cpmodel.new_int_var(0, horizon, 'max_lateness')
            cpmodel.add_max_equality(obj, all_lates )
            cpmodel.minimize(obj)

            #先行制約
            if len(precedence)>0:
                for (st,fi,delay) in precedence:
                    cpmodel.add( start[st] + delay <= start[fi] )

            # Solve model
            solver = CpSolver()
            solver.parameters.max_time_in_seconds = 1000 #model.Params.TimeLimit 
            solver.parameters.log_search_progress = False #model.Params.OutputFlag
            
            status = solver.Solve(cpmodel)
            #print("status=", status)
            
            if status == cp_model.OPTIMAL or status == cp_model.FEASIBLE : 
                seq = [ (solver.value(start[j]), j) for j in jobs]
                seq.sort()
                s = [ j for (_,j) in seq]
                result.append( (m,int(solver.ObjectiveValue()),s) )

                #データを保存しておき，機械学習
                # for j in jobs:
                #     self.nodes[j]['S']
                #     self.nodes[j]['p']
                #     self.nodes[j]['Cp']
                    
            else:
                print("Solver stopped with status", status)
            
        return result

def shifting_bottleneck(js: Shift, horizon:int = 1000000, LOG: bool = False):
    
    remain = set(js.machines.keys()) #残りの機械
    count = 0
    while len(remain) > 0:
        js.criticalPath
        #if LOG: js.output()
        
        result = js.computeLmax2(remain, horizon) #use cp-sat
        #print("result=", result) #machine, obj, seq
        max_lmax = -1
        max_machine = -1
        best_seq = None
        for idx, lmax, seq in result:
            if lmax > max_lmax:
                max_lmax = lmax
                max_machine = idx
                best_seq = seq
        print(max_lmax, max_machine) #, best_seq)
    
        if count ==1:
            best_seq =[(2, 3), (2, 2), (2, 1)]
    
        #閉路がある場合には切除平面を追加
        pred = best_seq[0]
        edges = []
        for succ in best_seq[1:]:
            edges.append( (pred, succ) )
            pred = succ
        #print("edges=", edges)   

        while True:
            G = js.copy()
            G.add_edges_from(edges)
        
            if nx.is_directed_acyclic_graph(G)==True: #閉路がないのでbreak
                break
                
            #閉路があるならカットを追加して再求解
            S = set(js.machines[max_machine])
            G.remove_nodes_from(['U', 'V'])
            #print("before preprocessing", len(G.edges()))
            remove_zero_indegree_nodes(G)
            remove_zero_outdegree_nodes(G)
        
            label, prev = {}, {}
            precedence =[]
            for i in S:
                if i not in G:
                    continue
                #print("search from", i)
                label[i] = 0
                for (k,j) in nx.dfs_edges(G, source=i):
                    label[j] = label[k] + G.nodes[k]['p']
                    prev[j] = k
                    if i in G[j] and j in S:
                        #if label[j] <=100000:
                        print("found a short cycle", i,j, label[j])
                        precedence.append( (i,j,label[j]) )
                        
            if len(precedence)>0:
                #カットの追加して再求解
                result = js.computeLmax2([max_machine], horizon, precedence) #use cp-sat
                idx, lmax, best_seq = result[0]
                #print("best_seq=", best_seq)
                pred = best_seq[0]
                edges = []
                for succ in best_seq[1:]:
                    edges.append( (pred, succ) )
                    pred = succ
                break
                #print("edges=", edges)
        
        
        count +=1
        # if count ==2:
        #     break
        js.add_edges_from(edges) #
        remain.remove(max_machine)

# %% ../nbs/07optseq.ipynb 101
def make_gannt_for_notion(model, start="2020/1/1 00:00:00", period="days"):
    """
    notionのガントチャートを生成する関数
    """
    start = pd.to_datetime(start)

    def time_convert_long(periods):
        if period =="days":
            time_ = start + dt.timedelta(days=float(periods))
        elif period == "hours":
            time_ = start + dt.timedelta(hours=float(periods))
        elif period == "minutes":
            time_ = start + dt.timedelta(minutes=float(periods))
        elif period == "seconds":
            time_ = start + dt.timedelta(seconds=float(periods))
        else:
            raise TypeError("pariod must be 'days' or 'seconds' or minutes' or 'days'")
        return time_.strftime("%Y年%m月%d日 %H:%M" ) #"%B %d, %Y %I:%M %p")

    L = []
    Name,Assign,Blocked_by,Blocking,Date,Property,Property_1,Status = [],[],[],[],[],[],[],[]
    #Name, Assign, Date, Property,Property_1,Status =[],[],[],[],[],[]
    for i in model.activities:
        a = model.activities[i]
        st = time_convert_long(a.start)
        fi = time_convert_long(a.completion-1)  #Notionのガントチャートは終了時刻を含むので， １単位時間前まで使用するように変更

        Name.append(a.name)

        Assign.append( a.selected.name )     #選択されたモード
        Date.append( str(st)+" → "+ str(fi)) #開始・終了
        Property.append( f"duedate: {a.duedate}  weight:{a.weight}" )
        Property_1.append(f"execute: {a.execute}" )
        Blocked_by.append(" ")
        Blocking.append(" ")
        Status.append( "Not started"  ) 
        

    df = pd.DataFrame( {"Name":Name, "Assign":Assign, "Blocked by":Blocked_by, "Blocking": Blocking, 
                        "日付":Date, "Property": Property, "Property 1": Property_1, "Status": Status} )
    return df

# %% ../nbs/07optseq.ipynb 109
def optseq_project_excel(res_list):

    R = []
    for i,r in enumerate(res_list):
        R.append(r["resource_name"])

    wb = Workbook()
    ws = wb.active
    wb.remove(ws)
    ws = wb.create_sheet(title="作業")
    ws.append(["作業ID", "作業名", "納期(年-月-日　時:分)", "後詰め(0,1)","遅れ重み（正数）", "後続作業ID（カンマ区切り）",
               "作業時間（分；整数）", "分割(0,1)", "並列(0,1)" ]+R 
              )
    #時間フォーマット
    for i in range(1000):
        ws.cell(2+i, 3).number_format = 'yyyy/m/d\\ h:mm;@'

    # #日付・時刻バリデーション
    dv = DataValidation(type="time") 
    ws.add_data_validation(dv)
    dv.add('C2:C1048576')   

    
    dv_list = DataValidation(type="list", formula1='"0,1"', allow_blank=True)
    ws.add_data_validation(dv_list)
    dv_list.add('D2:D1048576')
    
    
    dv = DataValidation(type="whole",
                        operator="greaterThanOrEqual",
                        formula1=0)
    dv.add('E2:E1048576') 
    ws.add_data_validation(dv)
    

    dv = DataValidation(type="whole",
                        operator="greaterThanOrEqual",
                        formula1=0)
    dv.add('G2:G1048576') 
    ws.add_data_validation(dv)
    
    
    dv_list = DataValidation(type="list", formula1='"0,1"', allow_blank=True)
    ws.add_data_validation(dv_list)
    dv_list.add('H2:I1048576')
    
    dv = DataValidation(type="whole",
                        operator="greaterThanOrEqual",
                        formula1=0)
    dv.add('J2:K1048576') 
    ws.add_data_validation(dv)   
      
    
    #コメント
    ws.cell(1,1).comment = Comment("作業ごとに異なる番号を入力", "logopt")
    ws.cell(1,2).comment = Comment("作業名", "logopt")
    ws.cell(1,3).comment = Comment("納期（時刻日付型）；ない場合は空白", "logopt")
    ws.cell(1,4).comment = Comment("作業をなるべく遅く実行するとき1", "logopt")
    ws.cell(1,5).comment = Comment("納期遅れペナルティ（1分あたりの費用）", "logopt")
    ws.cell(1,6).comment = Comment("後続作業のIDを半角カンマ区切りで入力", "logopt")
    #ws.cell(1,6).comment = Comment("作業を行う方法（モード）；作業関連は空白で必要数を行に追加", "logopt")
    ws.cell(1,7).comment = Comment("作業時間（分単位で非負の整数値）", "logopt")
    ws.cell(1,8).comment = Comment("作業の分割が可能なとき1", "logopt")
    ws.cell(1,9).comment = Comment("作業の並列実行が可能なとき1", "logopt")
    for i in range(len(res_list)):
        ws.cell(1,10+i).comment = Comment("対応する資源の量を非負整数で入力", "logopt")
    
    return wb

# %% ../nbs/07optseq.ipynb 112
def optseq_production_excel():

    wb = Workbook()
    ws = wb.active
    wb.remove(ws)
    ws = wb.create_sheet(title="作業モード")
    ws.append(["作業名(ID)", "最早開始(年-月-日　時:分)","納期(年-月-日　時:分)", "後詰め(0,1)：1のときには必ず納期を設定","遅れ重み（正数）", "モード名（複数行も可）",
               "作業時間（分；非負整数）", "分割可(0,1)", "並列可(0,1)" ]
              )
    #時間フォーマット
    for i in range(10000):
        ws.cell(2+i, 2).number_format = 'yyyy/m/d\\ h:mm;@'
        ws.cell(2+i, 3).number_format = 'yyyy/m/d\\ h:mm;@'

    # #日付・時刻バリデーション
    dv = DataValidation(type="time") 
    ws.add_data_validation(dv)
    dv.add('B2:C1048576')   

    #コメント
    ws.cell(1,1).comment = Comment("作業名；固有の名称を入力", "logopt")
    ws.cell(1,2).comment = Comment("最早開始時刻（時刻日付型）；ない場合は空白", "logopt")
    ws.cell(1,3).comment = Comment("納期（時刻日付型）；ない場合は空白", "logopt")
    ws.cell(1,4).comment = Comment("作業をなるべく遅く実行するとき1（後詰めの作業の後続作業も後詰めになる）", "logopt")
    ws.cell(1,5).comment = Comment("納期遅れペナルティ（遅れ1分あたりの費用）", "logopt")
    ws.cell(1,6).comment = Comment("作業を行う方法（モード）；複数の場合は作業関連の列は空白で行を追加", "logopt")
    ws.cell(1,7).comment = Comment("作業時間（分単位で非負の整数値）", "logopt")
    ws.cell(1,8).comment = Comment("作業の分割が可能なとき1", "logopt")
    ws.cell(1,9).comment = Comment("作業の並列実行が可能なとき1", "logopt")

    
    #データバリデーション(TODO)

    
    dv_list = DataValidation(type="list", formula1='"0,1"', allow_blank=True)
    ws.add_data_validation(dv_list)
    dv_list.add('D2:D1048576')
    
    
    dv = DataValidation(type="whole",
                        operator="greaterThanOrEqual",
                        formula1=0)
    dv.add('E2:E1048576') 
    ws.add_data_validation(dv)
    

    dv = DataValidation(type="whole",
                        operator="greaterThanOrEqual",
                        formula1=0)
    dv.add('G2:G1048576') 
    ws.add_data_validation(dv)
    
    
    dv_list = DataValidation(type="list", formula1='"0,1"', allow_blank=True)
    ws.add_data_validation(dv_list)
    dv_list.add('H2:I1048576')
    
    #資源マスタ
    ws = wb.create_sheet(title="資源")
    ws.append(["資源名(ID)", "資源使用可能量上限（基準値）"])
    ws.cell(1,1).comment = Comment("資源名；固有の名称を入力", "logopt")
    ws.cell(1,2).comment = Comment("資源量上限の基準値を入力；日別・時間帯別の上限は後で変更可能", "logopt")
    
    #データバリデーション(TODO)
    dv = DataValidation(type="whole",
                        operator="greaterThanOrEqual",
                        formula1=1)
    dv.add('B2:B1048576') 
    ws.add_data_validation(dv)
    
    #時間制約
    ws = wb.create_sheet(title="時間制約")
    ws.append(["先行作業名", "後続作業名", "時間制約タイプ", "遅れ（分）" ])
    #コメント
    ws.cell(1,1).comment = Comment("先行作業名を作業モードシートの作業名から選択", "logopt")
    ws.cell(1,2).comment = Comment("後続作業名を作業モードシートの作業名から選択", "logopt")
    ws.cell(1,3).comment = Comment("完了・開始(CS)，開始・開始(SS)，完了・完了(CC)，開始・完了(SC)から選択", "logopt")
    ws.cell(1,4).comment = Comment("先行作業と後続作業の時間差を入力（負も可）", "logopt")
    
    dv_list = DataValidation(type="list", formula1='"CS,CC,SS,SC"', allow_blank=True)
    ws.add_data_validation(dv_list)
    dv_list.add('C2:C1048576')
 
    dv = DataValidation(type="whole")
    dv.add('D2:D1048576') 
    ws.add_data_validation(dv)
    
    
    #モード・資源制約
    ws = wb.create_sheet(title="資源使用量")
    ws.append(["モード名(ID)", "資源名(ID)", "開始時間", "終了時間", "使用量"])
    #コメント
    ws.cell(1,1).comment = Comment("モードの名称(ID)を入力", "logopt")
    ws.cell(1,2).comment = Comment("資源の名称(ID)を入力；複数の場合はモード名は空白で必要数を行に追加", "logopt")
    ws.cell(1,3).comment = Comment("作業開始時から資源使用開始時までの経過時間（分）;空白ならすべて", "logopt")
    ws.cell(1,4).comment = Comment("作業開始時から資源使用終了時までの経過時間（分）;空白ならすべて", "logopt")
    ws.cell(1,5).comment = Comment("資源の使用量を正数値で入力", "logopt")

 
    #データバリデーション(TODO)
    dv = DataValidation(type="whole",
                        operator="greaterThanOrEqual",
                        formula1=1)
    dv.add('C2:E1048576') 
    ws.add_data_validation(dv)   
    
    return wb

# %% ../nbs/07optseq.ipynb 116
def optseq_resource_excel(wb, start, finish, period=1, period_unit="時"):
    try:
        data = wb["資源"].values
        cols = next(data)[:]
        data = list(data)
        resource_df = pd.DataFrame(data, columns=cols).dropna(how="all") 
    except:
        raise KeyError("資源シートなし")
        
    res_list = list(resource_df.iloc[:,0])
    ub = list(resource_df.iloc[:,1])
    
    trans = {"秒":"S","分":"min","時":"h"}
    freq = f"{period}{trans[period_unit]}"
    
    #終了が同時か早い場合には１日加える
    start = pd.to_datetime(start)
    finish = pd.to_datetime(finish)
    if start>=finish:
        finish = finish + dt.timedelta(days=1)
    
    period_df = pd.DataFrame(pd.date_range(start, finish, freq=freq),columns=["description"])
    period_df["description"] = period_df.description.dt.strftime("%H:%M:%S")
    period_df["id"] = [t for t in range(len(period_df))]
    period_df = period_df.reindex(columns = ["id", "description"])

    T = len(period_df)-1
    day_type_list =['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun', 'Holiday']+[ f"Special{i}" for i in range(1,4)]
    wb = Workbook()
    ws = wb.active
    wb.remove(ws)
    for d in day_type_list:
        ws = wb.create_sheet(d)
        ws.append( ["資源名"]+list(period_df.description[:-1]) )
        for i, res in enumerate(res_list):
            ws.append([res] +[ub[i] for t in range(T)])
        #コメント
        ws.cell(1,1).comment = Comment("資源の名称(ID)を　入力", "logopt")
        ws.cell(1,2).comment = Comment("時刻ごとの資源使用可能量上限", "logopt")
    return wb

# %% ../nbs/07optseq.ipynb 120
def time_delta(finish, start):
    """
    日付時刻もしくは時刻型の差を計算して，秒を返す関数
    """
    try: #datetime型
        return int((finish-start).total_seconds())
    except TypeError: #time型
        td = (dt.datetime.combine(dt.date(2000,1,1), finish) - dt.datetime.combine(dt.date(2000,1,1), start) )
        return td.days*60*60*24 + td.seconds
 
def prepare_df_for_optseq(wb, resource_wb, day_wb): 
    #基本wbのシートの読み込みとデータフレームの準備
    data = wb["作業モード"].values
    cols = next(data)[:]
    data = list(data)
    act_df = pd.DataFrame(data, columns=cols).dropna(how="all") 
    data = wb["資源"].values
    cols = next(data)[:]
    data = list(data)
    resource_df = pd.DataFrame(data, columns=cols).dropna(how="all") 
    data = wb["時間制約"].values
    cols = next(data)[:]
    data = list(data)
    time_df = pd.DataFrame(data, columns=cols).dropna(how="all") 
    data = wb["資源使用量"].values
    cols = next(data)[:]
    data = list(data)
    usage_df = pd.DataFrame(data, columns=cols).dropna(how="all")

    #日タイプ別の資源データの準備
    day_type_list =['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun', 'Holiday']+[ f"Special{i}" for i in range(1,4)]
    res_df_dic ={}
    for d in day_type_list:
        data = resource_wb[d].values
        cols = next(data)[:]
        data = list(data)

        res_df_dic[d] = pd.DataFrame(data, columns=cols).dropna(how="all") 

    #各日の資源データの準備
    data = day_wb.active.values
    cols = next(data)[:]
    data = list(data)
    day_df = pd.DataFrame(data, columns=cols).dropna(how="all") 
    
    return  act_df, resource_df, time_df, usage_df, res_df_dic, day_df

# %% ../nbs/07optseq.ipynb 124
def prepare_capacity(res_df_dic, day_df, start):
    capacity = defaultdict(dict) #資源使用可能量上限
    for row in day_df.itertuples():
        day = str(row[1])
        day_type = str(row[2])
        #print(day, day_type)
        time_list = [ ]
        for i in res_df_dic[day_type].columns[1:]:
            t = pd.to_datetime(f"{day} {i}")
            time_list.append( time_delta(t,start)//60 )
        #print(time_list)
        T = len(time_list)
        for row2 in res_df_dic[day_type].itertuples():
            res_name = str(row2[1]) #TODO check resource! 
            st_time = time_list[0] #開始時刻
            usage = list( row2[2:])
            #print(usage)
            current = usage[0]
            for t in range(1,T):
                if usage[t] != current: #資源量上限が変化
                    capacity[res_name].update({(st_time,time_list[t]):current})
                    st_time = time_list[t]
                    current = usage[t]
            capacity[res_name].update({(st_time,time_list[T-1]+60):current})  #最後の時刻+60分が終了時刻
    return capacity

# %% ../nbs/07optseq.ipynb 128
def make_model_for_optseq_production(act_df, resource_df, time_df, usage_df, capacity, start, fix_start=None, fix_finish=None):
    #モデル構築
    model = Model()
    act, mode, res ={},{},{}
    #作業
    mode_id = 0 #ダミーのモードの番号
    for row in act_df.itertuples():
        if pd.isnull(row[1])==False: #作業名が空白でない
            act_name = str(row[1])
            if pd.isnull(row[2])==False: #リリース時刻
                release = time_delta(row[2],start)//60
                if release<0:
                    raise ValueError(f"作業名 {act_name} の開始時刻が早すぎます．基準時刻を再設定してください．")
            else:
                release = 0
            if pd.isnull(row[3])==False: #納期
                duedate = time_delta(row[3],start)//60
                if duedate<0:
                    raise ValueError(f"作業名 {act_name} の開始時刻が早すぎます．基準時刻を再設定してください．")
            else:
                duedate = "inf"
            if pd.isnull(row[4])==False: #後詰
                backward = int(row[4])
            else:
                backward = False
            if pd.isnull(row[5])==False: #重み
                weight = int(row[5])
            else:
                weight = 1 #既定値  
            act[act_name] = model.addActivity(name=act_name,duedate=duedate, backward=backward, weight=weight)
            if release > 0: #最早開始時刻の追加
                model.addTemporal("source",  act[act_name], delay=release)
        if pd.isnull(row[6])==False: #モードが空白でない
            mode_name = str(row[6])
        else:
            mode_name = f"Dummy{mode_id}"
            mode_id+=1
        if pd.isnull(row[7])==False: #作業時間
            duration = int(row[7])
        else:
            duration = 0        
        mode[ mode_name ] = Mode(name=mode_name, duration=duration)
        if pd.isnull(row[8])==False: #分割
            if int(row[8]) > 0:
                mode[ mode_name ].addBreak(0,"inf")
        if pd.isnull(row[9])==False: #並列作業
            if int(row[9]) > 0:
                mode[ mode_name ].addParallel(1,"inf")

        act[act_name].addModes( mode[mode_name] )
    # 作業開始と終了時刻の固定   
    if fix_start is not None:
        for act_name in fix_start:
            if fix_start[act_name]<0:
                raise ValueError(f"作業名 {act_name} の開始時刻が早すぎます．基準時刻を再設定してください．")
            if act_name not in act:
                raise KeyError(f"固定すべき作業名 {act_name} がデータに含まれていません．")
            model.addTemporal("source",act[act_name],tempType="SS",delay=fix_start[act_name])
            model.addTemporal(act[act_name],"source",tempType="SS",delay=-fix_start[act_name])
    if fix_finish is not None:
        for act_name in fix_finish:
            if fix_start[act_name]<0:
                raise ValueError(f"作業名 {act_name} の終了時刻が早すぎます．基準時刻を再設定してください．")
            model.addTemporal("source",act[act_name],tempType="SC",delay=fix_finish[act_name])
            model.addTemporal(act[act_name],"source",tempType="CS",delay=-fix_finish[act_name])
        
    # 資源： 時刻依存の上限の設定
    for row in resource_df.itertuples():
        res_name = str(row[1])
        #res[ res_name ] = model.addResource(name=res_name, capacity=int(row[2]))
        res[ res_name ] = model.addResource(name=res_name, capacity=capacity[res_name])
        
    #時間制約
    for row in time_df.itertuples():
        pred, succ = str(row[1]), str(row[2])
        if pred not in act or succ not in act:
            raise KeyError(f"作業名 {pred} or {succ} が作業モードシートにありません")
        if pd.isnull(row[3])==False: #制約タイプ
            _type = str(row[3])
            if _type not in {"CS", "CC", "SS", "SC"}:
                raise ValueError("制約タイプが未定です．")
        else:
            _type ="CS" #既定値
        if pd.isnull(row[4]): #遅れ
            delay = 0
        else:
            delay = int(row[4])
        #print(type(act[pred]), type(act[succ]))
        model.addTemporal(pred= act[pred], succ=act[succ], tempType=_type, delay=delay)
    #資源使用量
    for row in usage_df.itertuples():
        mode_name = str(row[1])
        if mode_name not in mode:
            raise KeyError(f"モード名 {mode_name} が作業モードシートにありません")
        res_name = str(row[2])  
        if res_name not in res:
            raise KeyError(f"資源名 {res_name} が資源シートにありません")
        if pd.isnull(row[3])==False: #開始時間
            st_time = int(row[3])
        else:
            st_time = 0 
        if pd.isnull(row[4])==False: #終了時間
            fi = int(row[4])
        else:
            fi = "inf" 
        if pd.isnull(row[5])==False: #使用量
            usage = int(row[5])
        else:
            raise ValueError("資源使用量が未定義です") 
        mode[mode_name].addResource(res[res_name],{(st_time,fi):usage})
    
    return model

# %% ../nbs/07optseq.ipynb 132
def extract_fix_optseq(wb, start):
    ws = wb.active
    fix_start, fix_finish = {}, {}
    for row in ws.iter_rows(min_row=3, min_col=1, max_col=3):
        if row[0] is None:
            break
        cell = row[1]
        if cell.fill.fgColor.rgb != "00000000": #白以外の色の行を抽出
            val = time_delta(cell.value, start)//60 #分
            fix_start[str(row[0].value)] = val
        cell = row[2]
        if cell.fill.fgColor.rgb != "00000000": #白以外の色の行を抽出
            val = time_delta(cell.value, start)//60
            fix_finish[str(row[0].value)] = val
    return fix_start, fix_finish

# %% ../nbs/07optseq.ipynb 136
def make_gannt_for_production(model, capacity, start="2020/1/1 00:00:00"):
    """
    Excelのガントチャートを生成する関数
    """
    MIN_COL = 8 #ガントチャート（期データ）が始まる数
    
    def prepare_res_idx():
        count = 0
        name_list = []
        for res in model.res:
            if len(res.terms) == 0:  # 左辺がないので再生可能資源
                count+=1
                name_list.append( res.name )
        n_res = len(name_list)
        if n_res >0:
            name_dic ={}
            for i, name in enumerate(name_list):
                name_dic[name] = i+1 #資源の番号（１から開始）を返す辞書
            res_idx_list = [ ]
            for idx, i in enumerate(model.activities):
                a = model.activities[i]
                try:
                    res_name = list(a.selected.requirement.keys())[0][0]
                    res_idx = name_dic[res_name]
                except IndexError:
                    res_idx = n_res + 1 #ダミーの資源を割り当てる
                #print(a.name, res_idx)
                res_idx_list.append(res_idx)
        return res_idx_list, name_list

    def time_convert_long(periods, period ="minutes"):
        if period =="days":
            time_ = start + dt.timedelta(days=float(periods))
        elif period == "hours":
            time_ = start + dt.timedelta(hours=float(periods))
        elif period == "minutes":
            time_ = start + dt.timedelta(minutes=float(periods))
        elif period == "seconds":
            time_ = start + dt.timedelta(seconds=float(periods))
        else:
            raise TypeError("pariod must be 'days' or 'seconds' or minutes' or 'days'")
        return time_.strftime("%Y/%m/%d %H:%M") #時間まで表示する

    start = pd.to_datetime(start)
    n_job = len(model.activities)

    wb = Workbook() #WorkBookの準備
    ws = wb.active  #Sheetの準備

    max_time = 0
    for i in model.activities:
        a = model.activities[i]
        max_time =max(max_time, int(a.completion) ) 
        if a.duedate != "inf":
            max_time = max(max_time, int(a.duedate) )
    max_time = max_time//60 #時間単位

    ws.append(["基準日", start, " ", "  ", " " , "    ", "    "])
    for j in range(max_time): #最大時刻
        cell = ws.cell(1,j+8)
        col = cell.column_letter 
        cell.value = f'=LEFT(TEXT({col}2,"aaaa"),1)'    #f"=LEFT(TEXT({col}2,'aaaa'),1)"        
    ws.append(["名称", "開始", "終了", "モード", "作業時間", "納期", "遅れ重み"] + list(pd.date_range(start=start, periods=max_time, freq ="h")) )

    #作業情報書き込み
    for idx, i in enumerate(model.activities):
        L =[]
        a = model.activities[i]
        st = time_convert_long(a.start)
        fi = time_convert_long(a.completion)  
        if a.duedate != "inf":
            due = time_convert_long(a.duedate) 
        else:
            due = None 
        L = [a.name, pd.to_datetime(st), pd.to_datetime(fi), a.selected.name, a.selected.duration, due, a.weight]
        ws.append(L)
    #納期を描画
    for idx, i in enumerate(model.activities):
        a = model.activities[i]
        if a.duedate != "inf":
            side =Side(style="thick", color="00FF0000")
            ws.cell(idx+3,7+int(a.duedate//60)).border = Border(right=side)

    #日付フォーマット: 最大時刻まで
    _format = 'yyyy/m/d\\ h:mm;@'  #'mm-dd-yy'
    ws.cell(1,2).number_format = _format 
    for j in range(max_time):
        ws.cell(2, MIN_COL+j).number_format = _format 
    for i in range(n_job):
        ws.cell(i+3,2).number_format = _format 
        ws.cell(i+3,3).number_format = _format 

    #資源
    res_idx_list, name_list = prepare_res_idx()  
    ws.append(["", "", "", "", " ", "資源ID", "資源名/期"] + list(range(max_time)))  
    for j, res in enumerate(name_list):
        ws.append(["", "", "","","",j+1, res+"（使用量）"] )

    for j, res in enumerate(name_list):
        for t in range(max_time):
            cell = ws.cell(n_job+4+j,  MIN_COL+t)
            col = cell.column_letter #列名を抽出
            cell.value = f"=COUNTIF({col}3:{col}{n_job+2},{j+1})"  #集計

    #資源容量
    ws.append(["", "", "","" ,"", "資源ID", "資源名"])      
    for j, m in enumerate(capacity):
        L = [0 for t in range(max_time)]
        for (st,fi) in capacity[m]:
            s = st//60
            f = min(fi//60, max_time)
            for i in range(s,f):
                L[i] += capacity[m][st,fi]
        ws.append(["", "", "", "" ,"",j+1, str(m)+"(上限）"] + L) 

    #関数（ガントチャート描画）    
    for i in range(n_job): #作業数
        for j in range(max_time): #最大時刻
            cell = ws.cell(i+3, MIN_COL+j)
            col = cell.column_letter 
            cell.value = f"=IF(AND({col}2<C{i+3},{col}2>=B{i+3}),{res_idx_list[i]},0)"  
    #色
    redFill = PatternFill(start_color="0099CC", end_color="0099CC",fill_type='solid')
    cell = ws.cell(3, MIN_COL+max_time)
    col = cell.column_letter 
    #列の開始列 H も MIN_COL にあわせて変更
    #start_cell = ws.cell(3, MIN_COL)
    #start_col = start_cell.column_letter 
    ws.conditional_formatting.add(f'H3:{col}{2+n_job}', FormulaRule(formula=['H3>=1'], fill=redFill))

    #時刻の列を回転
    for j in range(max_time): 
        cell = ws.cell(2, MIN_COL+j)
        cell.alignment = Alignment(horizontal = "center", vertical = "center", textRotation = 90, wrap_text = False)

    #幅の調整
    ws.row_dimensions[2].height = 100
    ws.column_dimensions["B"].width = 15
    ws.column_dimensions["C"].width = 15
    ws.column_dimensions["F"].width = 15
    ws.column_dimensions["G"].width = 15
    
    for j in range(max_time): #最大時刻
        cell = ws.cell(1, MIN_COL+j)
        col = cell.column_letter 
        ws.column_dimensions[col].width = 3

    #チャートの描画
    for j, res in enumerate(name_list):
        c1 = ScatterChart()
        c1.title = f"{j+1}. 資源 {res}"
        c1.style = 13
        c1.y_axis.title = '資源量'
        c1.x_axis.title = '期'
        xvalues = Reference(ws, min_col= MIN_COL-1, min_row=n_job+3, max_col=7 + max_time)
        yvalues1 = Reference(ws, min_col= MIN_COL-1, min_row=n_job+4+j, max_col=7 + max_time)
        series1 = Series(yvalues1, xvalues, title_from_data=True)
        series1.marker.symbol = "triangle"
        series1.marker.graphicalProperties.solidFill = "FF0000" # Marker filling
        series1.marker.graphicalProperties.line.solidFill = "FF0000" # Marker outline
        series1.graphicalProperties.line.noFill = True
        c1.series.append(series1)

        yvalues2 = Reference(ws, min_col= MIN_COL-1, min_row=n_job+5+len(name_list)+j, max_col= 7+max_time)
        series2 = Series(yvalues2, xvalues, title_from_data=True)
        series2.graphicalProperties.line.solidFill = "00AAAA"
        series2.graphicalProperties.line.dashStyle = "sysDot"
        series2.graphicalProperties.line.width = 100050 # width in EMUs
        #series2.smooth = True # Make the line smooth
        c1.series.append(series2)

        ws.add_chart(c1, f"A{7 + n_job + len(name_list)*2 + j*20}")
    return wb
