"""Lotsizing Optimzation System"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/11lotsize.ipynb.

# %% auto 0
__all__ = ['folder', 'lotsizing', 'show_result_for_lotsizing', 'generate_item_master', 'generate_process_master',
           'generate_lotsize_master', 'add_bom_resource_sheets', 'add_detailed_resource_sheet', 'generate_order_master',
           'read_dfs_from_excel_lot', 'generate_demand_from_order', 'get_resource_ub', 'extract_fix_info',
           'multi_mode_lotsizing', 'make_cost_df', 'lot_output_excel', 'show_result_for_multimode_lotsizing']

# %% ../nbs/11lotsize.ipynb 2
import pandas as pd
import random
import numpy as np

import sys
sys.path.append('..')

from pulp import PULP_CBC_CMD, SCIP
from .mypulp import GRB, quicksum, Model
from .core import *
#from gurobipy import GRB, quicksum, Model

import scmopt2.optseq as optseq

from sklearn.cluster import AgglomerativeClustering
import plotly.express as px
import plotly.graph_objs as go
import plotly.express as px
import plotly
from plotly.subplots import make_subplots

import pathlib
import statistics

from collections import defaultdict

from openpyxl import Workbook, load_workbook
from openpyxl.worksheet.table import Table, TableStyleInfo
from openpyxl.chart import ScatterChart, Reference, Series
from openpyxl.worksheet.datavalidation import DataValidation
from openpyxl.formatting.rule import ColorScaleRule, CellIsRule, FormulaRule
from openpyxl.styles import Color, PatternFill, Font, Border, Alignment
from openpyxl.styles.borders import Border, Side
from openpyxl.utils.dataframe import dataframe_to_rows
from openpyxl.comments import Comment

folder ="./data/"

# %% ../nbs/11lotsize.ipynb 36
def lotsizing(prod_df, production_df, bom_df, demand, resource_df, max_cpu = 10, solver = "CBC"):
    """
    ロットサイズ決定問題を解く関数
    """
    
    #原材料と完成品の抽出
    if bom_df is not None:
        raw_materials = set(bom_df["child"])
        products = set(bom_df["parent"])
        items = list(raw_materials | products)
    else:
        prod_df.reset_index(inplace=True)
        products = set(prod_df.name)
        items = list(products)
        prod_df.set_index("name", inplace=True)
    #計画期間の数の抽出
    _, T = demand.shape
    #print("T=", T)

    #資源の容量の抽出
    M = {}
    for row in resource_df.itertuples():
        M[row.name, row.period] = row.capacity

    #親子関係の辞書を作成
    parent = defaultdict(set)
    phi = defaultdict(float) #qを１単位生産するために必要なpのunit数
    if bom_df is not None:
        for row in bom_df.itertuples():
            parent[row.child].add( row.parent )
            phi[row.child,row.parent] = row.units

    model = Model()
    x, I, y = {}, {}, {}
    slack, surplus = {}, {}
    Ts = range(0, T)
    
    if bom_df is not None:
        for i, p in enumerate(raw_materials):
            for t in Ts:
                x[t, p] = model.addVar(name=f"x[{p},{t}]")
                I[t, p] = model.addVar(name=f"I[{p},{t}]", ub=float(prod_df.target_inventory[p]))
                y[t, p] = model.addVar(name=f"y[{p},{t}]", vtype="B")
                slack[t, p] = model.addVar(name=f"slack[{p},{t}]")
                surplus[t, p] = model.addVar(name=f"surplus[{p},{t}]")
            I[-1, p] =   float(prod_df.initial_inventory[p]) #初期在庫
            I[T-1,p] =   float(prod_df.safety_inventory[p])  #最終期の在庫量

    for i, p in enumerate(products):
        for t in Ts:
            # print(demand[i][t])
            x[t, p] = model.addVar(name=f"x[{p},{t}]")
            I[t, p] = model.addVar(name=f"I[{p},{t}]", lb=float(
                prod_df.safety_inventory[p]), ub=float(prod_df.target_inventory[p]))
            y[t, p] = model.addVar(name=f"y[{p},{t}]", vtype="B")
            slack[t, p] = model.addVar(name=f"slack[{p},{t}]")
            surplus[t, p] = model.addVar(name=f"surplus[{p},{t}]")
        I[-1, p] = float(prod_df.initial_inventory[p])
        I[T-1, p] = float(prod_df.safety_inventory[p])
    model.update()

    for t in Ts:
        # raw material time capacity constraints
        if bom_df is not None:
            model.addConstr(quicksum(production_df.loc[p, "ProdTime"]*x[t, p] +
                                 production_df.loc[p, "SetupTime"]*y[t, p] for i, p in enumerate(raw_materials)) <= M["Res0",t],
                        f"TimeConstraint0({t})")

            for i, p in enumerate(raw_materials):
                # flow conservation constraints
                model.addConstr(I[t-1, p] + x[t, p] + slack[t, p] - surplus[t, p] == I[t, p]
                            + quicksum(  phi[p,q]*x[t, q] for q in parent[p]), "FlowCons(%s,%s)" % (t, p))

                # capacity connection constraints
                model.addConstr(production_df.loc[p, "ProdTime"]*x[t, p]
                            <=  (M["Res0",t]-production_df.loc[p, "SetupTime"])*y[t, p], "ConstrUB(%s,%s)" % (t, p))

                # minimum lot constraints
                model.addConstr(x[t, p] >= 0.*y[t, p], "ConstrLB(%s,%s)" % (t, p))

                # tighten constraints
                #model.addConstr(x[1,t,p] <= demand[i,t]*y[1,t,p] + I[1,t,p], "Tighten(%s,%s)"%(t,p))

        # time capacity constraints
        model.addConstr(quicksum(production_df.loc[p, "ProdTime"]*x[t, p] +
                             production_df.loc[p, "SetupTime"]*y[t, p]
                             for i, p in enumerate(prod_df.index)) <= M["Res1",t], f"TimeConstraint1({t})")

        for i, p in enumerate(products):
            # flow conservation constraints
            model.addConstr(I[t-1, p] + x[t, p] + slack[t, p] - surplus[t, p] ==
                        I[t, p] + demand[i, t], "FlowCons(%s,%s)" % (t, p))

            # capacity connection constraints
            model.addConstr(production_df.loc[p, "ProdTime"]*x[t, p] <=
                        (M["Res1",t]-production_df.loc[p, "SetupTime"])*y[t, p],
                        "ConstrUB(%s,%s)" % (t, p))

            # minimum lot constraints
            model.addConstr(x[t, p] >= 0.*y[t, p], "ConstrLB(%s,%s)" % (t, p))

            # tighten constraints
            model.addConstr(x[t, p] <= demand[i, t]*y[t, p] + I[t, p], "Tighten(%s,%s)" % (t, p))
    if bom_df is not None:
        model.setObjective(
            quicksum(99999999.*slack[t, p]+9999999.*surplus[t, p] +
                     production_df.loc[p, "SetupCost"]*y[t, p] + production_df.loc[p, "ProdCost"]*x[t, p] for t in Ts for p in items)
            + quicksum(prod_df.loc[p, "inv_cost"]*I[t, p]
                       for t in Ts for p in products)
            + quicksum(99999.*I[t, p]
                       for t in Ts for p in raw_materials),
            GRB.MINIMIZE)
    else:
        model.setObjective(
            quicksum(99999999.*slack[t, p]+9999999.*surplus[t, p] +
                     production_df.loc[p, "SetupCost"]*y[t, p] + production_df.loc[p, "ProdCost"]*x[t, p] for t in Ts for p in items)
            + quicksum(prod_df.loc[p, "inv_cost"]*I[t, p]
                       for t in Ts for p in products),
            GRB.MINIMIZE)

    model.__data = x, I, y, slack, surplus

    if solver =="GRB":
        model.Params.TimeLimit = max_cpu
        model.optimize()
    elif solver =="CBC":
        solver = PULP_CBC_CMD(timeLimit=max_cpu, presolve=True) 
        model.optimize(solver)
    elif solver == "SCIP":
        solver =SCIP(timeLimit=max_cpu)
        model.optimize(solver)
    else:
        raise ValueError 

    return model, T

# %% ../nbs/11lotsize.ipynb 40
def show_result_for_lotsizing(model, T, prod_df, production_df, bom_df, resource_df):
    """
    最適化結果から図とデータフレームを生成する関数
    """
    if bom_df is not None:
        raw_materials = set(bom_df["child"])
        products = set(bom_df["parent"])
        items = list(raw_materials | products)
    else:
        prod_df.reset_index(inplace=True)
        products = set(prod_df.name)
        items = list(products)
        prod_df.set_index("name", inplace=True)

    num_item =  len(items) #len(production_df)
    #items = production_df.index
    prod_array = np.zeros(shape=(num_item, T))
    inv_array = np.zeros(shape=(num_item, T))
    x, I, y, slack, surplus = model.__data

    slack_, surplus_, period_, prod_ = [], [], [], []
    for i, p in enumerate(items):
        for t in range(T):
            if slack[t, p].X > 0.001:
                #print(t, p, slack[t, p].X)
                period_.append(t)
                prod_.append(p)
                slack_.append(slack[t, p].X)
                surplus_.append( 0. )
            if surplus[t, p].X > 0.001:
                #print(t, p, surplus[t, p].X)
                period_.append(t)
                prod_.append(p)
                slack_.append( 0. )
                surplus_.append( surplus[t,p].X )
    violated = pd.DataFrame({"prod": prod_, "period":period_, "slack": slack_, "surplus": surplus_ })

    for i, p in enumerate(items):
        for t in range(T):
            prod_array[i, t] = production_df.loc[p, "ProdTime"] * \
                x[t, p].X + production_df.loc[p, "SetupTime"]*y[t, p].X
            try:
                inv_array[i, t] = I[t, p].X
            except AttributeError:
                inv_array[i, t] = I[t, p]

    production = pd.DataFrame(prod_array, index=items)
    inventory = pd.DataFrame(inv_array, index=items)

    # 在庫の推移の図
    data =[]
    for i in inventory.index:
        trace = go.Scatter( x= list(range(T)), y = inventory.loc[i], name=str(i) )
        data.append( trace)
    layout = go.Layout(
        autosize = True,
        title = "Inventory",
        xaxis=dict(
                title='期'
              ),
        yaxis=dict(
                title='在庫量'
              ),
    )
    fig_inv = go.Figure(data=data, layout=layout)

    # 容量制約の図
    if bom_df is not None:
        raw_materials = set(bom_df["child"])
        products = set(bom_df["parent"])
        fig = make_subplots(rows=2, cols=1,
                            subplot_titles=["Raw Matreial", "Product"])
        M = {}
        for row in resource_df.itertuples():
            M[row.name, row.period] = row.capacity

        for i in raw_materials:
            trace = go.Bar( x= list(range(T)), y = production.loc[i], name=str(i) )
            fig.add_trace(trace, row=1, col=1)
        fig.add_trace( go.Scatter( x= list(range(T)), y = [M["Res0",t] for t in range(T)], name="Raw Material Capacity") , row=1, col=1)        
        for i in products:
            trace = go.Bar( x= list(range(T)), y = production.loc[i], name=str(i) )
            fig.add_trace(trace, row=2, col=1)
        fig.add_trace( go.Scatter( x= list(range(T)), y = [M["Res1",t] for i in range(T)], name="Product Capacity") , row=2, col=1)
        
        fig.update_layout(
            barmode='stack',
            autosize = True,
            title = "Production",
            yaxis=dict(
                    title='生産量'
                  ),
        )
    else:
        M = {}
        for row in resource_df.itertuples():
            M[row.name, row.period] = row.capacity
            
        data = [go.Scatter( x= list(range(T)), y = [M["Res1",t] for i in range(T)], name="Product Capacity") ]
        for i in products:
            trace = go.Bar( x= list(range(T)), y = production.loc[i], name=str(i) )
            data.append( trace)

        layout =  go.Layout(
            barmode='stack',
            autosize = True,
            title = "Production",
            yaxis=dict(
                    title='生産量'
                  ),
        )
        fig = go.Figure(data=data, layout=layout)

    return violated, production, inventory, fig_inv, fig

# %% ../nbs/11lotsize.ipynb 49
def generate_item_master(wb):
    ws = wb.create_sheet(title="品目")
    ws.append(["品目名称", "在庫費用（円/期/unit)","在庫量下限","在庫量上限","初期在庫量","最終在庫量"])
    #初期在庫は別途Excelファイルでアップロード
    ws.cell(1,1).comment = Comment("品目の個別名称（ID)", "logopt")
    ws.cell(1,2).comment = Comment("１期あたりの在庫費用(円/unit/期）", "logopt")
    ws.cell(1,3).comment = Comment("在庫量の下限値；安全在庫量", "logopt")
    ws.cell(1,4).comment = Comment("在庫量の上限値；目標在庫量", "logopt")
    #初期と最終在庫量
    ws.cell(1,5).comment = Comment("計画期間の直前の期の期末在庫量", "logopt")
    ws.cell(1,6).comment = Comment("計画期間の終わり（最終期）の目標在庫量", "logopt")

    #データ検証
    dv = DataValidation(type="decimal",
                        operator="greaterThanOrEqual",
                        formula1=0.)
    dv.add('B2:F1048576') 
    ws.add_data_validation(dv)
    
    return wb

# %% ../nbs/11lotsize.ipynb 52
def generate_process_master(wb):
    ws = wb.create_sheet(title="工程")
    ws.append(["品目", "モード（複数可）", "段取り費用(円)", "生産費用(円/unit)", "子品目（原材料）数", "資源数"])
    #コメント
    ws.cell(1,1).comment = Comment("品目の名称（ID)（モードが複数の場合には空白も可）", "logopt")
    ws.cell(1,2).comment = Comment("生産モードの名称", "logopt")
    ws.cell(1,3).comment = Comment("段取り費用(円)", "logopt")
    ws.cell(1,4).comment = Comment("品目を1単位製造するために必要な費用(円)", "logopt")           
    ws.cell(1,5).comment = Comment("子品目（原材料）の数; ない場合には空白", "logopt")
    ws.cell(1,6).comment = Comment("生産に必要な資源数； 最低でも1つは登録", "logopt")                
    #データ検証（Noneは避けられない！）
    dv = DataValidation(type="decimal",
                        operator="greaterThanOrEqual",
                        formula1=0.)
    dv.add('C2:D1048576') 
    ws.add_data_validation(dv)
    #最低でも1のデータ検証
    dv2 = DataValidation(type="whole",
                        operator="greaterThanOrEqual",
                        formula1=1)
    dv2.add('E2:F1048576') 
    ws.add_data_validation(dv2)
    return wb

# %% ../nbs/11lotsize.ipynb 54
def generate_lotsize_master():
    wb = Workbook()
    ws = wb.active
    wb.remove(ws)
    wb = generate_item_master(wb) 
    wb = generate_process_master(wb)
    ws = wb.create_sheet(title="資源")
    ws.append(["資源名", "稼働時間上限（基準値）(h)"])
    #コメント
    ws.cell(1,1).comment = Comment("資源の個別名称（ID)", "logopt")
    ws.cell(1,2).comment = Comment("期ごとの稼働時間上限の基準値を入力（後で期別に変更可）", "logopt")
    
    #データ検証
    dv = DataValidation(type="decimal",
                        operator="greaterThanOrEqual",
                        formula1=0.)
    dv.add('B2:B1048576') 
    ws.add_data_validation(dv)
    
    return wb

# %% ../nbs/11lotsize.ipynb 57
def add_bom_resource_sheets(wb):
    #BOMとresource_reqの生成

    try:
        if wb["部品展開表"] is not None:
            wb.remove(wb["部品展開表"])
        if wb["資源必要量"] is not None:
            wb.remove(wb["資源必要量"])
    except:
        pass

    ws_bom = wb.create_sheet(title="部品展開表")
    ws_resource = wb.create_sheet(title="資源必要量")
 
    ws_bom.append(["品目", "モード", "子品目","必要量(units)"])
    ws_resource.append(["品目", "モード", "資源名", "段取り時間(分)", "生産時間(分/unit)"]) 

    #工程シートからデータ読み取り
    data = wb["工程"].values
    cols = next(data)[:]
    data = list(data)
    process_df = pd.DataFrame(data, columns=cols).dropna(how="all") 

    for row in process_df.itertuples():
        if row[1] is not None and not(np.isnan(row[0])):
            p = row[1] #parent
        else:
            p = "" #品目が空白
        m = row[2] #mode
        n_child = row[5]
        if n_child is not None and not(np.isnan(n_child)): #子品目数
            for i in range(int(n_child)):
                if i==0:
                    ws_bom.append([p, m, f"子品目{i+1}", 1] )
                else:
                    ws_bom.append(["","", f"子品目{i+1}", 1] )
        n_res = row[6]
        if n_res is not None and not(np.isnan(n_res)): #資源数
            for i in range(int(n_res)):
                if i==0:
                    ws_resource.append([p, m, f"資源{i+1}", 0.0, 0.0 ])
                else:
                    ws_resource.append(["","", f"資源{i+1}", 0.0, 0.0 ])

    #データ検証
    dv = DataValidation(type="decimal",
                        operator="greaterThanOrEqual",
                        formula1=0.)
    dv.add('D2:D1048576') 
    ws_bom.add_data_validation(dv)
    
    dv2 = DataValidation(type="decimal",
                        operator="greaterThanOrEqual",
                        formula1=0.)
    dv2.add('D2:E1048576') 
    ws_resource.add_data_validation(dv2)

    ws_bom.cell(1,3).comment = Comment("子品目の名称を品目シートから選んで変更してください．", "logopt")
    ws_bom.cell(1,4).comment = Comment("親品目を1単位製造するために必要な子品目の数量", "logopt")
    ws_resource.cell(1,3).comment = Comment("資源の名称を資源シートから選んで変更してください．", "logopt")
    ws_resource.cell(1,4).comment = Comment("資源の段取り時間(分)", "logopt")
    ws_resource.cell(1,5).comment = Comment("品目を1単位生産するための資源の使用時間(分)", "logopt")
    
    return wb

# %% ../nbs/11lotsize.ipynb 60
def add_detailed_resource_sheet(wb, start, finish, period=1, period_unit="日"):
                                
    trans = {"時":"h", "日":"d", "週":"w", "月":"M"}
    freq = f"{period}{trans[period_unit]}"
                                
    ws = wb.create_sheet(title=f"期別上限 {start} {finish}")
    time_index = pd.date_range(start, finish, freq= freq)
    ws.append(["資源名"]+list(time_index.strftime('%Y-%m-%d')))
    #資源シートからデータ読み取り
    res_master = wb["資源"]
    for row in res_master.iter_rows(min_row=2, min_col=1):
        ws.append([row[0].value]+[row[1].value]*len(time_index))

    #コメント
    ws.cell(2,1).comment = Comment("資源の個別名称（ID)", "logopt")
    ws.cell(2,2).comment = Comment("期ごとの稼働時間上限の基準値を入力", "logopt")

    #日付の列を回転
    for j in range(len(time_index)): 
        cell = ws.cell(1,j+2)
        cell.alignment = Alignment(horizontal = "center", vertical = "center", textRotation = 90, wrap_text = False)
    return wb

# %% ../nbs/11lotsize.ipynb 64
def generate_order_master():
    wb = Workbook()
    ws = wb.active
    wb.remove(ws)
    ws = wb.create_sheet(title="注文")
    ws.append(["品目(ID)", "納期", "数量"])

    #時間フォーマット
    for i in range(1000):
        ws.cell(2+i, 2).number_format = 'yyyy/m/d\\ h:mm;@'

    # #日付・時刻バリデーション
    dv = DataValidation(type="time") 
    ws.add_data_validation(dv)
    dv.add('B2:B1048576')   

    #コメント
    ws.cell(1,1).comment = Comment("品目の名称（ID)", "logopt")
    ws.cell(1,2).comment = Comment("納期を日付時刻型で入力", "logopt")
    ws.cell(1,3).comment = Comment("注文数量", "logopt")
    
    return wb

# %% ../nbs/11lotsize.ipynb 67
def read_dfs_from_excel_lot(wb):
    #item 
    data = wb["品目"].values
    cols = next(data)[:]
    data = list(data)
    item_df = pd.DataFrame(data, columns=cols).dropna(how="all") 

    #process
    data = wb["工程"].values
    cols = next(data)[:]
    data = list(data)
    process_df = pd.DataFrame(data, columns=cols).dropna(how="all") 

    #resource
    data = wb["資源"].values
    cols = next(data)[:]
    data = list(data)
    resource_df = pd.DataFrame(data, columns=cols).dropna(how="all") 
    
    data = wb["部品展開表"].values
    cols = next(data)[:]
    data = list(data)
    bom_df = pd.DataFrame(data, columns=cols).dropna(how="all") 

    data = wb["資源必要量"].values
    cols = next(data)[:]
    data = list(data)
    usage_df = pd.DataFrame(data, columns=cols).dropna(how="all") 
    
    return item_df, process_df, resource_df, bom_df, usage_df

# %% ../nbs/11lotsize.ipynb 71
def generate_demand_from_order(wb, start, finish, period=1, period_unit="日"):
    
    trans = {"時":"h", "日":"d", "週":"w", "月":"M"}
    
    if period_unit=="週":
        weekday = pd.to_datetime(start).strftime('%a')
        freq = f"{period}{trans[period_unit]}-{weekday}"
    else:
        freq = f"{period}{trans[period_unit]}"

    data = wb["注文"].values
    cols = next(data)[:]
    data = list(data)
    order_df = pd.DataFrame(data, columns=cols).dropna(how="all") 
    order_df.columns = ["品目(ID)","納期","数量"] #列名を指定のものに直す！
    order_df["納期"] = pd.to_datetime(order_df["納期"])
    order_df.set_index("納期", inplace=True)
    order_grouped = order_df.groupby(["品目(ID)"]).resample(freq)["数量"].sum()
    #生成
    time_index = pd.date_range(start, finish, freq= freq)
    T = len(time_index)
    to_idx = {} #日付を期IDに変換するための辞書
    for t, t_idx in enumerate(time_index):
        date_ = t_idx.strftime('%Y-%m-%d')
        to_idx[date_] = t
    #需要量 demand[t,p]
    demand = defaultdict(float)
    for idx in order_grouped.keys():
        date_ = idx[1].strftime('%Y-%m-%d')
        val = order_grouped[idx]
        demand[to_idx[date_],idx[0]] = float(val)
    return demand, T

# %% ../nbs/11lotsize.ipynb 75
def get_resource_ub(wb, start, finish, period=1, period_unit="日"):
    
    trans = {"時":"h", "日":"d", "週":"w", "月":"M"}
    if period_unit=="週":
        weekday = pd.to_datetime(start).strftime('%a')
        freq = f"{period}{trans[period_unit]}-{weekday}"
    else:
        freq = f"{period}{trans[period_unit]}"
        
    time_index = pd.date_range(start, finish, freq= freq)
    T = len(time_index)
    try:
        ws = wb[f"期別上限 {start} {finish}"]
        #print(f"期別上限 {start} {finish}")
    except KeyError as e: #期別上限シートがない場合
        #print(e)
        item_df, process_df, resource_df, bom_df, usage_df = read_dfs_from_excel_lot(wb)
        M = {}
        for row in resource_df.itertuples():
            for t in range(0,T):
                M[t, row[1]] = row[2]*60 #分に変更
        return M
    #期別上限シートがある場合 
    data = ws.values
    cols = next(data)[:]
    data = list(data)
    resource_ub_df = pd.DataFrame(data, columns=cols).dropna(how="all") 
    M ={}
    for row in resource_ub_df.itertuples():
        for t,j in enumerate(row[2:]):
            if pd.isnull(j):
                M[t,row[1]] = 0.
            else:
                M[t,row[1]] = float(j)*60 #分に変更
    return M

# %% ../nbs/11lotsize.ipynb 78
def extract_fix_info(wb, start, finish, period=1, period_unit="日"):
    
    trans = {"時":"h", "日":"d", "週":"w", "月":"M"}
    if period_unit=="週":
        weekday = pd.to_datetime(start).strftime('%a')
        freq = f"{period}{trans[period_unit]}-{weekday}"
    else:
        freq = f"{period}{trans[period_unit]}"
    time_index = pd.date_range(start, finish, freq= freq)
    T = len(time_index)
    to_idx = {} #日付を期IDに変換するための辞書
    for t, t_idx in enumerate(time_index):
        to_idx[t_idx.strftime('%Y-%m-%d')] = t

    fix_x = {}
    for name in wb.sheetnames:
        ws = wb[name]
        item = name[2:]
        for row in ws.iter_rows(min_row=3, min_col=2):
            if row[0].value !="生産量":
                break
            for cell in row[1:]:
                if cell.fill.fgColor.rgb != "00000000": #白以外の色の行を抽出
                    val = float(cell.value)
                    t = to_idx[ws.cell(1,cell.column).value]
                    m = ws.cell(cell.row,1).value[3:]
                    fix_x[t,m,item] = val
    return fix_x

# %% ../nbs/11lotsize.ipynb 82
def multi_mode_lotsizing(item_df, resource_df, process_df, bom_df, usage_df, demand, capacity, T=1, fix_x=None):
    INF = 9999999999.
    h = {} #在庫費用
    IUB, ILB = {},{} #在庫量の下限と上限
    for row in item_df.itertuples():
        h[row[1]] = row[2]
        if pd.isnull(row[3]):
            ILB[row[1]] = 0.
        else:
            ILB[row[1]] = row[3]
        if pd.isnull(row[4]):
            IUB[row[1]] = INF # 在庫量上限がない場合
        else:
            IUB[row[1]] = row[4]

    #親子関係や資源必要量の辞書を作成
    parent = defaultdict(set) #子品目pを必要とする親品目とモードの組の集合
    phi = defaultdict(float) #親品目qをモードmで１単位生産するために必要な子品目pのunit数
    modes = defaultdict(set) #親品目qのモード集合
    resources = defaultdict(set) #親品目qをモードmで生産するときに必要な資源の集合
    setup_time = defaultdict(float)
    setup_cost = defaultdict(float)
    prod_time = defaultdict(float)
    prod_cost = defaultdict(float)

    items = item_df.iloc[:,0] #品目のリストを準備
    item_set = set(items)
    resource_set = set( resource_df.iloc[:,0])

    #resource内にない場合にエラーを起こす
    #品目にモードがない場合にもエラー
    for row in process_df.itertuples():
        if row[1] is not None:
            q = row[1]            
        if row[2] is not None: #モード
            m = row[2]
            modes[q].add(m)
        #費用
        if row[3] is None or np.isnan(row[3]):
            setup_cost[q,m] = 0.
        else:
            setup_cost[q,m] = row[3]
        if row[4] is None or np.isnan(row[4]):
            prod_cost[q,m] = 0.
        else:
            prod_cost[q,m] = row[4] 
            
    for q in items:        
        if len(modes[q])==0:
            raise ValueError(f"品目{q}にモードがありません．")
        
    #BOM
    for row in bom_df.itertuples():
        if row[1] is not None:
            q = row[1]            
        if row[2] is not None: #モード
            m = row[2]
        if row[3] is not None:
            p = row[3]
            phi[p,q,m] = row[4]
            parent[p].add( (q,m) )
        if q not in item_set:
            raise ValueError(f"品目{q}が品目シートにありません．")
        if p not in item_set:
            raise ValueError(f"品目{p}が品目シートにありません．")

    #usage
    for row in usage_df.itertuples():
        if row[1] is not None:
            q = row[1]            
        if row[2] is not None: #モード
            m = row[2]
        #資源と時間
        if row[3] is not None:
            r = row[3]
            resources[q,m].add(r) 
            if row[4] is None or np.isnan(row[4]):
                setup_time[q,m,r] = 0.
            else:
                setup_time[q,m,r] = row[4]
            if row[5] is None or np.isnan(row[5]):
                prod_time[q,m,r] = 0.
            else:
                prod_time[q,m,r] = row[5]

        if r not in resource_set:
            raise ValueError(f"資源{r}が資源シートにありません．")
        if q not in item_set:
            raise ValueError(f"品目{q}が品目シートにありません．")

    item_modes = defaultdict(set) #資源rを使用する品目とモードの組の集合（resourcesの逆写像）
    for key in resources:
        for r in resources[key]:
            item_modes[r].add(key)

    model = Model()
    x, I, y = {}, {}, {}
    slack, surplus = {}, {}
    inv_slack, inv_surplus = {}, {}
    Ts = range(0, T)

    for row in item_df.itertuples():
        p = row[1]
        for m in modes[p]:
            for t in Ts:
                x[t, m, p] = model.addVar(name=f"x({p},{m},{t})")
                I[t, p] = model.addVar(name=f"I({p},{t})") 
                y[t, m, p] = model.addVar(name=f"y({p},{m},{t})", vtype="B")
                slack[t, p] = model.addVar(name=f"slack({p},{t})")
                surplus[t, p] = model.addVar(name=f"surplus({p},{t})")
                inv_slack[t, p] = model.addVar(name=f"inv_slack({p},{t})")
                inv_surplus[t, p] = model.addVar(name=f"inv_surplus({p},{t})")
            if pd.isnull(row[5]):
                I[-1, p] = 0.
            else:
                I[-1, p] =  row[5]  # 初期在庫  

            if pd.isnull(row[6]):
                I[T-1,p] = 0.
            else:
                I[T-1,p] =  row[6]  # 最終期の在庫量            
    #各費用項目を別途合計する
    cost ={}
    for i in range(5):
        cost[i] = model.addVar(vtype="C",name=f"cost[{i}]")

    model.update()

    #変数の固定
    if fix_x is not None:
        for (t,m,p) in fix_x:
            model.addConstr( x[t,m,p] == fix_x[t,m,p] )

    #在庫量の上下限の逸脱の計算
    for t in Ts:
        for p in items:  
            model.addConstr( I[t, p] <= IUB[p] + inv_surplus[t,p], f"IUB({t},{p})" ) 
            model.addConstr( ILB[p]  <= I[t, p]+ inv_slack[t,p], f"ILB({t},{p})" ) 


    for row in resource_df.itertuples():
        r = row[1]
        for t in Ts:
            # time capacity constraints
            model.addConstr(quicksum(prod_time[p,m,r]*x[t,m,p] + setup_time[p,m,r]*y[t,m,p] for (p,m) in item_modes[r])
                            <= capacity[t,r], 
                            f"TimeConstraint1({r},{t})")

    for t in Ts:
        for p in items:
            # flow conservation constraints（ソフト制約）
            model.addConstr(I[t-1, p] + quicksum(x[t, m, p] for m in modes[p]) + slack[t, p] - surplus[t, p] == I[t, p] +demand[t,p]+
                         quicksum( phi[p,q,m]*x[t, m, q] for (q,m) in parent[p]), f"FlowCons({t},{p})" ) 

    for t in Ts:
        for p in items:  
            # capacity connection constraints
            for m in modes[p]:
                for r in resources[p,m]:
                    model.addConstr(prod_time[p,m,r]*x[t,m,p]
                                <=  (capacity[t,r]-setup_time[p,m,r])*y[t,m,p], f"ConstrUB({t},{m},{r},{p})")

    model.addConstr( quicksum( slack[t, p]+surplus[t, p] for t in Ts for p in items) == cost[0] )
    model.addConstr( quicksum( inv_slack[t, p]+inv_surplus[t, p] for t in Ts for p in items) == cost[1] )
    model.addConstr( quicksum( setup_cost[p,m]*y[t,m,p] for t in Ts for p in items for m in modes[p] for r in resources[p,m]) == cost[2])
    model.addConstr( quicksum( prod_cost[p,m]*x[t,m,p] for t in Ts  for p in items for m in modes[p] for r in resources[p,m]) == cost[3])
    model.addConstr( quicksum( h[p]*I[t, p] for t in Ts for p in items) == cost[4] )

    model.setObjective(9999999.*cost[0] + 999999.*cost[1] + quicksum(cost[i] for i in range(2,5)) , GRB.MINIMIZE)

    model.__data = x, I, y, slack, surplus, inv_slack, inv_surplus, cost, items, modes, item_modes, setup_time, prod_time, parent, resources
    
    return model

# %% ../nbs/11lotsize.ipynb 94
def make_cost_df(cost):
    df = pd.DataFrame({"需要逸脱ペナルティ":cost[0].X, "在庫上下限逸脱ペナルティ":cost[1].X,"段取り費用":cost[2].X, "生産変動費用":cost[3].X,"在庫費用":cost[4].X},index=["費用"])
    return df.T

# %% ../nbs/11lotsize.ipynb 98
def lot_output_excel(model, start, finish, period, period_unit, demand, cost_df): 

    trans ={"時":"h", "日":"d", "週":"w", "月":"M"}
    
    if period_unit=="週":
        weekday = pd.to_datetime(start).strftime('%a')
        freq = f"{period}{trans[period_unit]}-{weekday}"
    else:
        freq = f"{period}{trans[period_unit]}"
          
    x, I, y, slack, surplus, inv_slack, inv_surplus, cost, items, modes, item_modes, setup_time, prod_time, parent, resources = model.__data

    wb = Workbook()
    ws0 = wb.active
    wb.remove(ws0)
    time_index = pd.date_range(start, finish, freq= freq)
    T = len(time_index)
    
    ws = wb.create_sheet(title= "費用内訳")
    for r in dataframe_to_rows(cost_df, index=True, header=True):
        ws.append(r)
    
    for i in items:
        ws = wb.create_sheet(title= f"品目{i}")
        ws.append([""]*2 + list(time_index.strftime('%Y-%m-%d')))
        ws.append(["  ","在庫量"] + [I[t,i].X for t in range(T-1)]+[I[T-1,i]])  #T-1は最終期（在庫量は定数）
        for m in modes[i]:
            ws.append([f"モード{m}","生産量"] + [x[t,m,i].X for t in range(T)])  
        ws.append(["  ","需要量"] + [demand[t,i] for t in range(T)])
        ws.append(["  ","品切れ量"] + [slack[t,i].X for t in range(T)])
        ws.append(["  ","超過量"] + [surplus[t,i].X for t in range(T)])

        #日付の列を回転
        for j in range(T): 
            cell = ws.cell(1,j+3)
            cell.alignment = Alignment(horizontal = "center", vertical = "center", textRotation = 90, wrap_text = False)
    return wb

# %% ../nbs/11lotsize.ipynb 103
def show_result_for_multimode_lotsizing(model, start, finish, period, period_unit, capacity):

    #在庫プロット
    trans = {"時":"h", "日":"d", "週":"w", "月":"M"}

    if period_unit=="週":
        weekday = pd.to_datetime(start).strftime('%a')
        freq = f"{period}{trans[period_unit]}-{weekday}"
    else:
        freq = f"{period}{trans[period_unit]}"

    time_index = pd.date_range(start, finish, freq= freq)

    (x, I, y, slack, surplus, inv_slack, inv_surplus, cost, items, modes, item_modes, setup_time, 
     prod_time, parent, resources) = model.__data
        
    xrange =  list(time_index.strftime('%Y-%m-%d'))
    T = len(time_index)

    data =[]
    for i in items:
        # 在庫量の値を取得（変数の場合は.X、定数の場合はそのまま）
        inv_values = []
        for t in range(T):
            try:
                inv_values.append(I[t,i].X)
            except AttributeError:
                # I[t,i]が定数の場合
                inv_values.append(float(I[t,i]))
        trace = go.Scatter( x=xrange, y = inv_values, name=str(i) )
        data.append( trace)
    layout = go.Layout(
        autosize = True,
        title = "Inventory",
        xaxis=dict(
                title='期'
              ),
        yaxis=dict(
                title='在庫量'
              ),
    )
    fig_inv = go.Figure(data=data, layout=layout)
    
    # 容量制約の図
    fig = make_subplots(rows=len(item_modes), cols=1,
                        subplot_titles=[ f"資源{r}" for r in item_modes])
    
    for idx, r in enumerate(item_modes):
        for i,m in item_modes[r]:
            trace = go.Bar( x= xrange, y = [prod_time[i,m,r]*x[t,m,i].X + setup_time[i,m,r]*y[t,m,i].X for t in range(T)], 
                           name= f"Item{i} Mode{m}")
            fig.add_trace(trace, row=idx+1, col=1)
            fig.add_trace(go.Scatter( x= xrange, y = [capacity[t,r] for t in range(T)], name= f"生産容量{r}") , row=idx+1, col=1)

    fig.update_layout(
        barmode='stack',
        autosize = False,
        width = 1400, 
        height=150*len(item_modes),
        title = "資源別生産量",
        yaxis=dict(
                title='生産量'
              ),
    )
    return fig_inv, fig
