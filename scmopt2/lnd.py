"""ロジスティクス・ネットワーク設計システム MEta Logistic network Optimization System"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/05lnd.ipynb.

# %% auto 0
__all__ = ['GUROBI', 'folder', 'host', 'weiszfeld_numpy', 'weiszfeld', 'repeated_weiszfeld', 'show_optimized_continuous_network',
           'make_total_demand', 'kmeans', 'hierarchical_clusterning', 'solve_k_median', 'plot_k_median_lr_find',
           'plot_k_median', 'elbow_method', 'make_aggregated_cust_df', 'make_aggregated_df', 'lnd_ms', 'lnd_ss',
           'distance_histgram', 'make_network_using_road', 'make_network', 'remove_zero_cust',
           'remove_zero_total_demand', 'plot_scm', 'digit_histgram', 'solve_lnd', 'show_optimized_network',
           'make_excel_melos', 'make_demand_production_sheets', 'prepare_df_for_melos', 'prepare_trans_df',
           'customer_aggregation', 'make_network_for_excel', 'solve_lnd_for_excel', 'add_result_for_melos',
           'extract_fix_dc_info', 'make_vrp', 'aggregate_demand_by_cluster', 'convex_comb_sos', 'LNDP', 'co2']

# %% ../nbs/05lnd.ipynb 3
import sys

import pathlib
sys.path.append('..')
from .data import *
from .core import *
    
GUROBI = False  #サーバーの場合はFalseにする．

if GUROBI:
    from gurobipy import GRB, quicksum, Model, multidict, tuplelist, LinExpr
else:
    from pulp import PULP_CBC_CMD
    from scmopt2.mypulp import  GRB, quicksum, Model, multidict, tuplelist, LinExpr

import pandas as pd
import random
import numpy as np
import pickle
import requests
import ast

from geopy.distance import great_circle as distance
from sklearn.cluster import MiniBatchKMeans, KMeans, AgglomerativeClustering

import pathlib
import statistics

import plotly.graph_objs as go
import plotly.express as px
import plotly

import string
import datetime
import math
from collections import OrderedDict, defaultdict
import networkx as nx

from openpyxl import Workbook, load_workbook
from openpyxl.worksheet.table import Table, TableStyleInfo
from openpyxl.chart import ScatterChart, Reference, Series
from openpyxl.worksheet.datavalidation import DataValidation
from openpyxl.formatting.rule import ColorScaleRule, CellIsRule, FormulaRule
from openpyxl.styles import Color, PatternFill, Font, Border, Alignment
from openpyxl.styles.borders import Border, Side
from openpyxl.utils.dataframe import dataframe_to_rows
from openpyxl.comments import Comment

from collections import defaultdict
from IPython.display import Image, YouTubeVideo

folder = "./data/"

host = "test-osrm-intel.aq-cloud.com"
#host ="localhost"

# %% ../nbs/05lnd.ipynb 30
def weiszfeld_numpy(cust_df, weight, num_of_facilities, epsilon=0.0001, max_iter = 1000, seed=None, X0=None, Y0=None):
    """
    Weiszfeld法； 複数施設の連続施設配置問題の近似解法 (NumPy version)
    """
    if seed is not None:
        np.random.seed(seed)
    n = len(cust_df)
    k = num_of_facilities

    x, y, nodeweight = cust_df.lat.values, cust_df.lon.values, np.array(weight)

    D = np.zeros( (n,k)  )
    X = np.zeros(k)
    Y = np.zeros(k)
    newX = np.zeros(k)
    newY = np.zeros(k)

    #初期解
    if X0 is None:
        perm = np.random.permutation(n)
        for i, j in enumerate(perm[:k]):
            X[i] = x[j]
            Y[i] = y[j]
    else:
        X = np.array(X0)
        Y = np.array(Y0)
        

    PrevX=X.copy()
    PrevY=Y.copy()

    wx = nodeweight*x
    wy = nodeweight*y

    for iter__ in range(max_iter):
        nodelist=[[] for i in range(k)]
        for i in range(n):
            for j in range(k):
                D[i,j] = nodeweight[i]*distance( (x[i],y[i]), (X[j],Y[j]) ).km

        #最も近い施設の番号の配列
        min_j = D.argmin(axis=1)
        #施設jに近い顧客のリスト
        nodelist=[[i for i in range(n) if min_j[i]==j] for j in range(k)]

        #重心を求める（初期地点）
        for j in range(k):
            sumx = wx.sum( where= (min_j==j) )
            sumy = wy.sum( where= (min_j==j) )
            sumr = nodeweight.sum( where= (min_j==j) )
            if sumr > 0:
                X[j]=sumx/sumr
                Y[j]=sumy/sumr

        #Weizfeld search
        for iter_ in range(max_iter):
            for j in range(k):
                sumx = sumy= sumr =0.0
                for i in nodelist[j]:
                    d = distance( (x[i],y[i]), (X[j],Y[j]) ).km
                    if d>0.0:
                        sumx += wx[i]/d
                        sumy += wy[i]/d
                        sumr += nodeweight[i]/d
                    else:
                        newX[j] = x[i]
                        newY[j] = y[i]
                        break
                if sumr>0.0:
                    newX[j] = sumx/sumr
                    newY[j] = sumy/sumr

            #compute error (in Weiszfeld search)
            #print(X,Y,newX,newY)
            error = 0.0
            for j in range(k):
                error+=distance((X[j],Y[j]),(newX[j],newY[j]) ).km
            #print("error=",error)
            if error<=epsilon:
                break
            X = newX.copy()
            Y = newY.copy()

        #compute error
        error=0.0
        for j in range(k):
            error+=distance( (X[j],Y[j]),(PrevX[j],PrevY[j]) ).km
        #print ("error=",iter__, error)
        if error<=epsilon:
            break
        X = newX.copy()
        Y = newY.copy()

        PrevX=X.copy()
        PrevY=Y.copy()

    partition = {}
    cost = 0.
    for j in range(k):
        for i in nodelist[j]:
            partition[i]=j
            d = distance( (x[i],y[i]), (X[j],Y[j]) ).km
            cost += d*nodeweight[i]
            
    return X, Y, partition, cost

# %% ../nbs/05lnd.ipynb 31
def weiszfeld(cust_df, weight, num_of_facilities, epsilon=0.0001, max_iter = 1000, seed=None, X0=None, Y0=None):
    """
    Weiszfeld法； 複数施設の連続施設配置問題の近似解法
    """
    if seed is not None:
        np.random.seed(seed)
        
    n = len(cust_df)
    k = num_of_facilities

    x, y, nodeweight = cust_df.lat.values, cust_df.lon.values, weight

    X=[0.]*k
    Y=[0.]*k
    newX=[0.]*k
    newY=[0.]*k

    #初期解
    if X0 is None:
        perm = np.random.permutation(n)
        for i, j in enumerate(perm[:k]):
            X[i] = x[j]
            Y[i] = y[j]
    else:
        X = list(X0)
        Y = list(Y0)

    PrevX = X[:]
    PrevY = Y[:]

    for iter__ in range(max_iter):
        #find the nearest facility
        nodelist=[[] for i in range(k)]
        for i in range(n):
            mindist=9999999.0
            minj=-1
            for j in range(k):
                dist = distance( (x[i],y[i]), (X[j],Y[j]) ).km
                if dist < mindist:
                    mindist = dist
                    minj = j
            nodelist[minj].append(i)

        #find the gravity point
        for j in range(k):
            sumx = sumy= sumr =0.0
            for i in nodelist[j]:
                sumx += nodeweight[i]*x[i]
                sumy += nodeweight[i]*y[i]
                sumr += nodeweight[i]
            if len(nodelist[j])>0:
                X[j]=sumx/sumr
                Y[j]=sumy/sumr

        #Weizfeld search
        for iter_ in range(max_iter):
            for j in range(k):
                sumx = sumy= sumr =0.0
                for i in nodelist[j]:
                    r = distance( (x[i],y[i]), (X[j],Y[j]) ).km
                    if r>0.0:
                        sumx += nodeweight[i]*x[i]/r
                        sumy += nodeweight[i]*y[i]/r
                        sumr += nodeweight[i]/r
                    else:
                        newX[j] = x[i]
                        newY[j] = y[i]
                        break
                if sumr>0.0:
                    newX[j] = sumx/sumr
                    newY[j] = sumy/sumr

            #compute error (in Weiszfeld search)
            error = 0.0
            for j in range(k):
                error+=distance( (X[j],Y[j]),(newX[j],newY[j]) ).km
            #print("error=",error)
            if error<=epsilon:
                break
            for j in range(k):
                X[j]=newX[j]
                Y[j]=newY[j]

        #compute error
        error=0.0
        for j in range(k):
            error+=distance( (X[j],Y[j]),(PrevX[j],PrevY[j]) ).km
        #print ("error=",iter__, error)
        if error<=epsilon:
            break
        for j in range(k):
            X[j]=newX[j]
            Y[j]=newY[j]

        PrevX=X[:]
        PrevY=Y[:]

    partition = {}
    cost = 0.
    for j in range(k):
        for i in nodelist[j]:
            partition[i]=j
            d = distance( (x[i],y[i]), (X[j],Y[j]) ).km
            cost += d*nodeweight[i]

    return X, Y, partition, cost

# %% ../nbs/05lnd.ipynb 38
def repeated_weiszfeld(cust_df, weight, num_of_facilities, epsilon=0.0001, max_iter = 1, numpy=True, seed = None):
    """
    TODO: Multicore (threading)で高速化
    """
    if seed is not None:
        np.random.seed(seed)
    best_cost = float('inf')
    best_X = best_Y = best_partition = None
    for iter_ in range(max_iter):
        if numpy:
            X, Y, partition, cost = weiszfeld_numpy(cust_df, weight, num_of_facilities, epsilon, max_iter)
        else:
             X, Y, partition, cost = weiszfeld(cust_df, weight, num_of_facilities, epsilon, max_iter)
        if cost < best_cost:
            best_X, best_Y, best_partition, best_cost = X, Y, partition, cost
            
    return best_X, best_Y, best_partition, best_cost

# %% ../nbs/05lnd.ipynb 41
def show_optimized_continuous_network(cust_df, X, Y, partition, weight=None):
    """
    連続施設配置の可視化関数
    """
    if weight is None:
        weight = 10
        WEIGHT = 20
    else:
        weight = np.array(weight)
        max_weight = weight.max()
        weight = 10+weight/(max_weight+1)*30
        WEIGHT= np.zeros(len(X))
        for i in range(len(cust_df)):
            j = partition[i]
            WEIGHT[j] +=weight[i]
        Max_Weight = WEIGHT.max()
        WEIGHT = 10.+WEIGHT/(Max_Weight+1)*40
    
    edge_trace_lat, edge_trace_lng = [], []
    x, y = cust_df.lat.values, cust_df.lon.values
    for i in range(len(cust_df)):
        j = partition[i]
        edge_trace_lat += [x[i], X[j], None]
        edge_trace_lng += [y[i], Y[j], None]

    data = [
        go.Scattermapbox(
            lat=cust_df.lat,
            lon=cust_df.lon,
            mode='markers',
            marker=dict(
                size= weight, color="pink", opacity=0.5
            ),
            text=cust_df.name,
            name="Customers"
        ),
        go.Scattermapbox(
            lat=X,
            lon=Y,
            mode='markers',
            marker=dict(
                size=WEIGHT, color="red", opacity=0.7
            ),
            name="Facilities"
        ),
        go.Scattermapbox(
            lat=edge_trace_lat,
            lon=edge_trace_lng,
            line=dict(width=0.5, color='yellow'),
            hoverinfo='none',
            mode='lines',
            name="Edges"
        ),
    ]

    layout = go.Layout(
        autosize=True,
        hovermode='closest',
        mapbox=dict(
            accesstoken=mapbox_access_token,
            bearing=0,
            center=dict(
                lat=35.8573157,
                lon=139.64696
            ),
            pitch=0,
            zoom=5,
            style="dark" #'satellite-streets'
        ),
    )

    fig = go.Figure(data=data, layout=layout)
    return fig

# %% ../nbs/05lnd.ipynb 44
def make_total_demand(demand_df, start="1900/01/01", finish="2050/12/31", num_of_days=365):
    """
    年間（計画期間）の総需要を計算する関数
    """
    try:
        demand_df.reset_index(inplace=True)
    except:
        pass
    demand_df.loc[:,"date"] = pd.to_datetime(demand_df["date"])
    demand_df.set_index("date", inplace=True)
    new_demand_df = demand_df[ (demand_df.index >= pd.to_datetime(start)) & (demand_df.index <= pd.to_datetime(finish)) ]

    periods = max( (new_demand_df.index.max() - new_demand_df.index.min()).days, 1) #計画期間

    total_demand_df=pd.pivot_table(
            new_demand_df, index = ["prod","cust"], values = "demand", aggfunc = "sum")*num_of_days/periods
    total_demand_df.reset_index(inplace=True)
    
    #顧客ごとの集約需要
    demand_cust_df = pd.pivot_table(total_demand_df, index="cust", values="demand", aggfunc=sum)
    #製品ごとの集約需要
    demand_prod_df = pd.pivot_table(total_demand_df, index="prod", values="demand", aggfunc=sum)
    # TODO 売上や需要換算
    
    return total_demand_df, demand_cust_df, demand_prod_df 

# %% ../nbs/05lnd.ipynb 51
def kmeans(cust_df, weight, num_of_facilities = 1, batch=True):
    if batch:
        model = MiniBatchKMeans(n_clusters=num_of_facilities)
    else:
        model = KMeans(n_clusters=num_of_facilities)
    model.fit(cust_df[["lat","lon"]], weight)
    partition = model.labels_
    
    cluster ={i:[] for i in range(num_of_facilities)}
    for i, row in enumerate(cust_df.itertuples()):
        cluster[ model.labels_[i] ].append(i)

    # find center of each cluster
    X, Y = [], [] 
    for i in range(num_of_facilities):
        if len(cluster[i])==0:
            continue
        lat_sum, lon_sum = 0., 0.
        total_weight = 0.
        for j in cluster[i]:
            lat_sum += cust_df.lat[j]*weight[j]
            lon_sum += cust_df.lon[j]*weight[j]
            total_weight +=weight[j]
        X.append( lat_sum/total_weight )
        Y.append( lon_sum/total_weight )
        
    cost = 0.
    x, y = cust_df.lat.values, cust_df.lon.values
    for j in range(len(X)):
        for i in cluster[j]:
            d = distance( (x[i],y[i]), (X[j],Y[j]) ).km
            cost += d*weight[i]    
    return X, Y, partition, cost

# %% ../nbs/05lnd.ipynb 56
def hierarchical_clusterning(cust_df, weight, durations, num_of_facilities = 2, linkage= "average"):
    """
    階層的クラスタリング関数 hierarchical_clusterning
    """
    try:
        cust_df.reset_index(inplace=True)
    except:
        pass
    clustering = AgglomerativeClustering(n_clusters=num_of_facilities, affinity="precomputed",linkage=linkage).fit(durations)
    partition = clustering.labels_

    cluster ={i:[] for i in range(num_of_facilities)}
    for i, row in enumerate(cust_df.itertuples()):
        cluster[ clustering.labels_[i] ].append(i)

    # find center of each cluster
    X, Y = [], [] 
    #median ={}
    total_cost = 0
    for i in range(num_of_facilities):
        if len(cluster[i])==0:
            continue
        min_cost = 99999999999999
        min_j = -1
        for j in cluster[i]:
            cost = 0
            for j2 in cluster[i]:
                if j==j2:
                    continue
                cost += durations[j][j2]*weight[j2]
            if cost < min_cost:
                min_cost = cost
                min_j = j
        total_cost += cost
        #median[i] = min_j
        X.append( cust_df.lat[min_j] )
        Y.append( cust_df.lon[min_j] )
    return X, Y, partition, total_cost

# %% ../nbs/05lnd.ipynb 78
def solve_k_median(cust_df, weight, cost, num_of_facilities, max_iter=100, max_lr=0.01, moms=(0.85,0.95), 
                   convergence=1e-5, lr_find = False, adam = False, capacity = None):
    """
    k-メディアン問題を解くための関数 solve_k_median
    """
    m = num_of_facilities 
    half_iter = max_iter//2
    lrs = (max_lr/25., max_lr)
    lr_sche =  np.concatenate( [np.linspace(lrs[0],lrs[1],half_iter), lrs[1]/2 + (lrs[1]/2)*np.cos(np.linspace(0,np.pi,half_iter) )])  #cosine annealing
    mom_sche = np.concatenate( [np.linspace(moms[1],moms[0],half_iter), moms[1]-(moms[1]-moms[0])/2 -(moms[1]-moms[0])/2*np.cos(np.linspace(0,np.pi,half_iter))] )

    if lr_find:
        phi = 1e-10   #ステップサイズを決めるためのパラメータ
        report_iter = 1
    else:
        report_iter = 100

    n = len(cost)
    u = np.zeros(n) #Lagrange multiplier
    w = np.array(weight)
    c = np.array(cost)
    C = c*w.reshape((n,1))
    
    m_t = np.zeros(n)
    best_ub = np.inf 
    best_open = {}
    
    #Adam
    if adam:
        beta_2 = 0.999
        epsilon = 1e-8
        m_t = np.zeros(n)
        v_t = np.zeros(n)

    lb_list, ub_list, phi_list = [], [], []
    for t in range(max_iter):
        Cbar = C - u.reshape((n,1))   #被約費用の計算
        xstar = np.zeros(n)
        ystar = np.zeros(n)
        # 0-1 knapsackを解く（容量制約のとき）
        # 係数 1の場合には，M（容量）個を選択
        # I, J = np.where( Cbar < 0 ) #負の被約費用をもつインデックスだけを抽出
        if capacity is not None: #容量制約を考慮（施設に割り当て可能な顧客数がcapacity以下）
            ystar = np.sort(np.where(Cbar>0,0.,Cbar), axis=1)[:,:capacity].sum(axis=1)
#             idx = np.argsort(Cbar)
#             for i in range(n):
#                 for j in idx[i][:capacity]: #被約費用の小さい方からcapacity個選択
#                     if Cbar[i,j]>=0.: #被約費用が非負の場合は終了
#                         break
#                     ystar[i] += Cbar[i,j]
        else:    
#             for i,j in zip(I,J): #負の被約費用を施設ごとに集計
#                 ystar[j] += Cbar[i,j] 
            ystar = np.where(Cbar<0, Cbar, 0.).sum(axis=0)
            
        idx = np.argsort(ystar) #小さい順にソート
        open_node = set(idx[:m])#小さい順にm個選択（同じ位置にあるものを選んでいる！）
        
        #下界の計算
#         lb =u.sum()     
#         for j in open_node:
#             lb +=ystar[j]
        lb = u.sum() + ystar[idx[:m]].sum()
        lb_list.append(lb)

#         for i,j in zip(I,J): #各顧客は，被約費用が負の空いている施設へ接続
#             if j in open_node: 
#                 xstar[i] += 1
        xstar = np.where(Cbar<0,1,0)[:,idx[:m]].sum(axis=1)

        #上界の計算  （容量制約がある場合は，（一般化）割当問題を解く必要がある！）
        if capacity is not None:
            if t%report_iter ==0:
                cost, flow = transportation(C[:,idx[:m]],capacity)
                cost2 = find_median(C, flow, n, m)
                ub = min(cost,cost2)
        else:
            ub = C[:,np.array(list(open_node))].min(axis=1).sum()
        
        if ub<best_ub:
            best_ub = ub
            best_open = open_node.copy()
        ub_list.append(best_ub)

        g_t = 1.-xstar #劣勾配の計算
        norm = np.dot(g_t, g_t) #ノルムの計算
        
        if lb > convergence:
            gap = (best_ub-lb)/lb
            if gap <=convergence:
                print("gap=",gap,best_ub,lb)
                break
        else:
            gap = 10.
            
        if t%report_iter ==0:
            print( f"{t}: {gap:.3f}, {lb:.5f}, {best_ub:.5f}, {norm:.2f}" )
            
        if norm <= convergence and capacity is None: 
            print("norm is 0!")
            break    
            
        if lb < -1e5:
            if lr_find:
                break
                
        if lr_find:
            phi *= 2. 
            beta_1 = moms[1]
        else:
            #fit one cycle 
            phi = lr_sche[t]
            beta_1 = mom_sche[t] 
            
        phi_list.append(phi) # lr_find用
            
        # 移動平均の更新
        m_t = beta_1*m_t + (1-beta_1)*g_t
        
        if adam:
            # 勾配の二乗の移動平均の更新
            v_t = beta_2*v_t + (1-beta_2)*(g_t**2)
            m_cap = m_t/(1-beta_1**(t+1))
            v_cap = v_t/(1-beta_2**(t+1))
            u = u + (phi*m_cap)/(np.sqrt(v_cap)+epsilon)
        else:
            alpha = (1.05*best_ub-lb)/norm 
            u = u + phi*alpha*m_t  # 慣性項あり
        
    #解の構成
    X, Y =[], []
    for i in best_open:
        row = cust_df.iloc[i]
        X.append(row.lat)
        Y.append(row.lon)
    facility_index={}
    for idx, i in enumerate(best_open):
        facility_index[i] = idx 
    partition = np.zeros(n, int)
    ub = 0.
    for i in range(n):
        min_cost = np.inf
        for j in best_open:
            if c[i,j] < min_cost:
                min_cost =  c[i,j] 
                partition[i] = facility_index[j]
            
    return X, Y, partition, best_ub, lb_list, ub_list, phi_list

# %% ../nbs/05lnd.ipynb 84
def plot_k_median_lr_find(phi_list, lb_list):
    """
    k-メディアンの学習率探索の結果を可視化する関数 plot_k_median_lr_find
    """
    fig = go.Figure()
    fig.add_trace(go.Scatter(
            x = phi_list, 
            y = lb_list,
            mode='markers+lines',
            name= "lb",
            marker=dict(
                size=10,
                color= "red")
    ))

    fig.update_xaxes(type="log")    
    fig.update_layout(title = "Stepsize finder",
                   xaxis_title='Phi (log scale)',
                   yaxis_title='Lower Bound')
    return fig

# %% ../nbs/05lnd.ipynb 89
def plot_k_median(lb_list, ub_list):
    #plot subgradient method
    fig = go.Figure()
    xx = np.arange(len(lb_list))
    fig.add_trace(go.Scatter(
            x = xx, 
            y = lb_list,
            mode='markers+lines',
            name= "lb",
            marker=dict(
                size=10,
                color= "red")
    ))
    fig.add_trace(go.Scatter(
            x = xx, 
            y = ub_list,
            mode='markers+lines',
            name= "ub",
            marker=dict(
                size=10,
                color= "blue")
    ))
    fig.update_layout(title = "k-median",
                   xaxis_title='Iteration',
                   yaxis_title='Lower Bound, Upper Bound')
    return fig 

# %% ../nbs/05lnd.ipynb 96
def elbow_method(cust_df, weight, n_lb = 1, n_ub = 10, repetitions=3, method="kmeans", durations=None):
    """
    elbow method
    """
    x, y =[],[]
    for n in range(n_lb, n_ub):
        for r in range(repetitions):
            if method == "kmeans":
                X, Y, partition, cost = kmeans(cust_df, weight, num_of_facilities = n)
            elif method =="weiszfeld":
                X, Y, partition, cost = repeated_weiszfeld(cust_df, weight, num_of_facilities = n, max_iter=1)
            elif method =="hierarchical":
                X, Y, partition, cost = hierarchical_clusterning(cust_df, weight, durations, num_of_facilities = n, linkage="complete")                
            else: 
                print( "Method is incorrect!")
                exit(0)
            x.append(n)
            y.append(cost)
    elbow_df = pd.DataFrame({"num of facilities":x, "cost": y})
    fig = px.scatter(elbow_df, x="num of facilities", y ="cost", title ="Elbow method")
    return fig

# %% ../nbs/05lnd.ipynb 104
def make_aggregated_cust_df(cust_df, X, Y, partition, weight):
    """
    make aggregated customer dataframe
    """

    cluster ={i:[] for i in range(len(X))}
    for i, row in enumerate(cust_df.itertuples()):
        cluster[ partition[i] ].append(i)

    cluster_list, total_demand = [],[] 
    name_list =[]
    for i in range(len(X)):
        name_list.append( f"cust{i}")
        cluster_list.append( cluster[i] )
        total = 0
        for j in cluster[i]:
            total += weight[j]
        total_demand.append(total)

    aggregated_cust_df = pd.DataFrame({"name":name_list,"lat": X, "lon":Y, "customers":cluster_list, "weight": total_demand})
    return aggregated_cust_df

# %% ../nbs/05lnd.ipynb 107
def make_aggregated_df(cust_df, demand_df, total_demand_df, X, Y, partition, weight):
    """
    make aggregated dataframe
    """

    cluster ={i:[] for i in range(len(X))}
    for i, row in enumerate(cust_df.itertuples()):
        cluster[ partition[i] ].append(i)

    cluster_list, total_demand = [],[] 
    name_list =[]
    for i in range(len(X)):
        name_list.append( f"cust{i}")
        cluster_list.append( cluster[i] )
        total = 0
        for j in cluster[i]:
            total += weight[j]
        total_demand.append(total)

    aggregated_cust_df = pd.DataFrame({"name":name_list,"lat": X, "lon":Y, "customers":cluster_list, "demand": total_demand})
    
    cust_idx = {}
    for i,row in enumerate(cust_df.itertuples()):
        cust_idx[ str(row.name) ] = i    

# 遅い！
#     cluster_idx =[]
#     try:
#         demand_df.reset_index(inplace=True)
#     except ValueError:
#         pass
#     for row in demand_df.cust:
#         cluster_idx.append( "cust"+ str(partition[ cust_idx[row]]) )
#     demand_df.loc[:,"cluster_idx"] = cluster_idx
#     aggregated_demand_df = pd.pivot_table(demand_df, index=["date", "prod", "cluster_idx"], values="demand", aggfunc=sum)
#     aggregated_demand_df.reset_index(inplace=True)
#     aggregated_demand_df.rename(columns={"cluster_idx":"cust"}, inplace=True)

    cluster_idx =[]    
    for row in total_demand_df.cust:
        cluster_idx.append( "cust"+str(partition[cust_idx[str(row)]]) )

    total_demand_df.loc[:,"cluster_idx"] = cluster_idx
    aggregated_total_demand_df = pd.pivot_table(total_demand_df, index=["prod","cluster_idx"], values="demand", aggfunc=sum)
    aggregated_total_demand_df.reset_index(inplace=True)
    aggregated_total_demand_df.rename(columns={"cluster_idx":"cust"}, inplace=True)

    #return aggregated_cust_df, aggregated_demand_df, aggregated_total_demand_df
    return aggregated_cust_df,  aggregated_total_demand_df

# %% ../nbs/05lnd.ipynb 115
def lnd_ms(weight, cust, dc, dc_lb, dc_ub, plnt, plnt_ub, demand, tp_cost, del_cost, dc_fc, dc_vc, dc_num, 
           volume = None, fix_y=None, dc_slack_penalty=10000., demand_slack_penalty=10000000.):
#     """
#     Logistics network design, multiple source
#     Gurobi model for multiple-source LND
#     :rtype: object of class `Model`, as defined in `gurobipy`
#     :weight: weight[p] -> unit weight for product `p`
#     :cust: dict associating a customer id to its location as (latitute, longitude)
#     :dc: dict associating a distribution center id to its (latitute, longitude)
#     :dc_lb: dc_lb[k] -> lower bound for distribution center k [not used]
#     :dc_ub: dc_ub[k] -> upper bound for distribution center k
#     :plnt: dict associating a plant id to its (latitute, longitude)
#     :plnt_ub: plnt_ub[k,p] -> upper bound for plant k for p
#     :demand: demand[k,p] -> units of `p` demanded by customer `k`
#     :tp_cost: tp_cost[i,j] -> unit transportation cost from plant `i` to dc `j`
#     :del_cost: tp_cost[i,j] -> unit delivery cost from dc `i` to customer `j`
#     :dc_fc: fixed cost for opening a dc
#     :dc_vc: unit (variable) cost for operating a dc
#     :dc_num: (maximum) number of distribution centers to open
#     """
    prod = set(weight.keys())
    plnt_to_dc = set((i,j,p) for i in plnt for j in dc for p in prod
                     if plnt_ub.get((i,p),0) > 0 and (i,j) in tp_cost)
    dc_to_cust = set((j,k,p) for j in dc for (k,p) in demand if (j,k) in del_cost)
    if volume is None:
        volume ={}
        for p in prod:
            volume[p] = 1. #既定値
    
    model = Model()
    x,y = {}, {}
    for (i,j,p) in plnt_to_dc | dc_to_cust:
        x[i,j,p] = model.addVar(vtype='C', name=f'x[{i},{j},{p}]')

    slack = {}
    for (k,p) in demand:
        if k in cust:
            slack[k,p] = model.addVar(vtype="C", name=f"slack[{k},{p}]")

    for j in dc:
        y[j] = model.addVar(vtype='B', name=f'y[{j}]')

    cost ={}
    for i in range(5):
        cost[i] = model.addVar(vtype="C",name=f"cost[{i}]")

    dc_slack = {}
    for j in dc:
        dc_slack[j] = model.addVar(vtype="C", name=f"dc_slack[{j}]")

    model.update()
    #倉庫変数の固定(fix_y[i]に固定したい値が入っている)
    if fix_y is not None:
        for i,j in enumerate(dc):
            if i in fix_y: #固定すべき倉庫番号が辞書内にある
                model.addConstr( y[j] == fix_y[i], name =f"fix_y[{j}]" )

    Cust_Demand_Cons, DC_Flow_Cons, DC_Strong_Cons, DC_UB_Cons, DC_LB_Cons, Plnt_UB_Cons = {}, {}, {}, {}, {}, {}

    for (k,p) in demand: 
        if k in cust:
            Cust_Demand_Cons[k,p] = model.addConstr(
                quicksum(x[j,k,p] for j in dc if (j,k,p) in dc_to_cust)  + slack[k,p]
                ==
                demand[k,p],
                name=f'Cust_Demand_Cons[{k},{p}]'
            )
    for j in dc:
        for p in prod:
            DC_Flow_Cons[j,p] = model.addConstr(
                quicksum(x[i,j,p] for i in plnt if (i,j,p) in plnt_to_dc)
                ==
                quicksum(x[j,k,p] for k in cust if (j,k,p) in dc_to_cust if k in cust),
                name=f'DC_Flow_Cons[{j},{p}]'
            )
    for (j,k,p) in dc_to_cust:
        if k in cust:
            DC_Strong_Cons[j,k,p] = model.addConstr(
                x[j,k,p]
                <=
                demand[k,p] * y[j],
                name=f'DC_Strong_Cons[{j},{k},{p}]'
            )

    for j in dc:
        DC_UB_Cons[j] = model.addConstr(
            dc_ub[j] * y[j]
            >=
            quicksum(volume[p]*x[i,j,p] for i in plnt for p in prod if (i,j,p) in plnt_to_dc),
            name=f'DC_UB_Cons[{j}]'
        )

    for j in dc:
        DC_LB_Cons[j] = model.addConstr(
            dc_lb[j] * y[j]
            <=
            quicksum(volume[p]*x[i,j,p] for i in plnt for p in prod if (i,j,p) in plnt_to_dc) + dc_slack[j],
            name=f'DC_LB_Cons[{j}]'
        )

    for i,p in plnt_ub:
        Plnt_UB_Cons[i,p] = model.addConstr(
            quicksum(x[i,j,p] for j in dc if (i,j,p) in plnt_to_dc)<=plnt_ub[i,p],
            name=f'Plnt_UB_Cons[{i},{p}]'
        )

    if dc_num is not None:
        if isinstance(dc_num, int):
            dc_lb = dc_num
            dc_ub = dc_num
        else:
            dc_lb = dc_num[0]
            dc_ub = dc_num[1]
        assert dc_lb <= dc_ub
        DC_Num_Cons_LB = model.addConstr(
            quicksum(y[j] for j in dc)
            >=
            dc_lb,
            name='DC_Num_Cons_LB'
        )
        DC_Num_Cons_UB = model.addConstr(
            quicksum(y[j] for j in dc)
            <=
            dc_ub,
            name='DC_Num_Cons_UB'
        )

    model.update()

    model.addConstr( quicksum(weight[p] * tp_cost[i,j] * x[i,j,p] for (i,j,p) in plnt_to_dc) == cost[0] )
    model.addConstr( quicksum(weight[p] * del_cost[j,k] * x[j,k,p] for (j,k,p) in dc_to_cust if k in cust) == cost[1] )
    model.addConstr( quicksum(dc_fc[j] * y[j] for j in dc) == cost[2] )
    model.addConstr( quicksum(dc_vc[j] * x[i,j,p] for (i,j,p) in plnt_to_dc)  == cost[3] )
    model.addConstr( quicksum(dc_slack_penalty*dc_slack[j] for j in dc) +  quicksum(demand_slack_penalty*slack[k,p] for (k,p) in demand if k in cust) == cost[4] )

    model.setObjective( quicksum( cost[i] for i in range(5) ),
        GRB.MINIMIZE
    )

    model.update()
    model.__data = x,y,slack,dc_slack,cost

    return model

# %% ../nbs/05lnd.ipynb 118
def lnd_ss(weight, cust, dc, dc_lb, dc_ub, plnt, plnt_ub, demand, tp_cost, del_cost, dc_fc, dc_vc, dc_num, 
           volume = None, fix_y = None, dc_slack_penalty=10000., demand_slack_penalty=10000000.):
#     """
#     Logistics network design, single source

#     Gurobi model for single-source LND

#     :rtype: object of class `Model`, as defined in `gurobipy`
#     :weight: weight[p] -> unit weight for product `p`
#     :cust: dict associating a customer id to its location as (latitute, longitude)
#     :dc: dict associating a distribution center id to its (latitute, longitude)
#     :dc_lb: dc_lb[k] -> lower bound for distribution center k [not used]
#     :dc_ub: dc_ub[k] -> upper bound for distribution center k
#     :plnt: dict associating a plant id to its (latitute, longitude)
#     :plnt_ub: plnt_ub[k] -> upper bound for plant k
#     :demand: demand[k,p] -> units of `p` demanded by customer `k`
#     :tp_cost: tp_cost[i,j] -> unit transportation cost from plant `i` to dc `j`
#     :del_cost: tp_cost[i,j] -> unit delivery cost from dc `i` to customer `j`
#     :dc_fc: fixed cost for opening a dc
#     :dc_vc: unit (variable) cost for operating a dc
#     :dc_num: (maximum) number of distribution centers to open
#     """
    prod = set(weight.keys())
    plnt_to_dc = set((i,j,p) for i in plnt for j in dc for p in prod
                     if plnt_ub.get((i,p),0) > 0 and (i,j) in tp_cost)
    dc_to_cust = set((j,k,p) for j in dc for (k,p) in demand if (j,k) in del_cost)

    if volume is None:
        volume ={}
        for p in prod:
            volume[p] = 1. #既定値
            
    model = Model()
    x,y = {}, {}
    z = {}

    for (i,j,p) in plnt_to_dc:
        x[i,j,p] = model.addVar(vtype='C', name=f'x[{i},{j},{p}]')

    for j,k in del_cost:
        if k in cust:
            z[j,k] = model.addVar(vtype="B",name=f"z[{j},{k}]")

    slack = {}
    for k in cust:
        slack[k]= model.addVar(vtype="C",name=f"slack[{k}]")

    for j in dc:
        y[j] = model.addVar(vtype='B', name=f'y[{j}]')

    cost ={}
    for i in range(5):
        cost[i] = model.addVar(vtype="C",name=f"cost[{i}]")

    dc_slack = {}
    for j in dc:
        dc_slack[j] = model.addVar(vtype="C", name=f"dc_slack[{j}]")

    model.update()

    #倉庫変数の固定(fix_y[i]に固定したい値が入っている)
    if fix_y is not None:
        for i,j in enumerate(dc):
            if i in fix_y: #固定すべき倉庫番号が辞書内にある
                model.addConstr( y[j] == fix_y[i], name =f"fix_y[{j}]" )
                
    Cust_Demand_Cons, DC_Flow_Cons, DC_Strong_Cons, DC_UB_Cons, DC_LB_Cons, Plnt_UB_Cons = {}, {}, {}, {}, {}, {}

    for k in cust:
        Cust_Demand_Cons[k] = model.addConstr(
                    quicksum(z[j,k] for j in dc if (j,k) in del_cost ) +slack[k]
                    == 1,
                    name=f'Cust_Demand_Cons[{k}]'
        )
        
    for j in dc:
        for p in prod:
            DC_Flow_Cons[j,p] = model.addConstr(
                quicksum(x[i,j,p] for i in plnt if (i,j,p) in plnt_to_dc)
                ==
                quicksum(  demand.get((k,p),0) *z[j,k] for k in cust if (j,k) in del_cost if k in cust),
                name=f'DC_Flow_Cons[{j},{p}]'
            )

    for j,k in del_cost:
        if k in cust:
            DC_Strong_Cons[j,k] = model.addConstr(
                    z[j,k]
                    <=
                    y[j],
                    name=f'DC_Strong_Cons[{j},{k}]'
                )

    for j in dc:
        DC_UB_Cons[j] = model.addConstr(
            dc_ub[j] * y[j]
            >=
            quicksum(volume[p]*x[i,j,p] for i in plnt for p in prod if (i,j,p) in plnt_to_dc),
            name=f'DC_UB_Cons[{j}]'
        )

    for j in dc:
        DC_LB_Cons[j] = model.addConstr(
           dc_lb[j] * y[j]
           <=
           quicksum(volume[p]*x[i,j,p] for i in plnt for p in prod if (i,j,p) in plnt_to_dc)+dc_slack[j],
           name=f'DC_LB_Cons[{j}]'
      )

    for i,p in plnt_ub:
        Plnt_UB_Cons[i,p] = model.addConstr(
            quicksum(x[i,j,p] for j in dc if (i,j,p) in plnt_to_dc) <= plnt_ub[i,p],
            name=f'Plnt_UB_Cons[{i},{p}]'
        )

    if dc_num is not None:
        if isinstance(dc_num, int):
            dc_lb = dc_num
            dc_ub = dc_num
        else:
            dc_lb = dc_num[0]
            dc_ub = dc_num[1]
        assert dc_lb <= dc_ub
        DC_Num_Cons_LB = model.addConstr(
            quicksum(y[j] for j in dc)
            >=
            dc_lb,
            name='DC_Num_Cons_LB'
        )
        DC_Num_Cons_UB = model.addConstr(
            quicksum(y[j] for j in dc)
            <=
            dc_ub,
            name='DC_Num_Cons_UB'
        )

    model.update()

    total_demand = { }
    for k in cust:
        total = 0.
        for p in prod:
            if (k,p) in demand:
                total += weight[p] * demand[k,p]
        total_demand[k] = total 

    model.addConstr( quicksum(weight[p] * tp_cost[i,j] * x[i,j,p] for (i,j,p) in plnt_to_dc) == cost[0] )
    model.addConstr( quicksum(del_cost[j,k] * total_demand[k]* z[j,k] for j,k in del_cost if k in cust) == cost[1] )
    model.addConstr( quicksum(dc_fc[j] * y[j] for j in dc) == cost[2] )
    model.addConstr( quicksum(dc_vc[j] * x[i,j,p] for (i,j,p) in plnt_to_dc)  == cost[3] )
    model.addConstr( quicksum(dc_slack_penalty*dc_slack[j] for j in dc) +  quicksum(demand_slack_penalty*slack[k] for k in cust) == cost[4] )

    model.setObjective( quicksum( cost[i] for i in range(5) ),
        GRB.MINIMIZE
    )
    model.update()
    model.__data = x,y,z,slack,dc_slack,cost

    return model

# %% ../nbs/05lnd.ipynb 120
def distance_histgram(cust_df, dc_df, plnt_df, distances=None):
    """
    工場・倉庫間と倉庫・顧客間の距離のヒストグラムを返す関数
    """
    dist, kind = [], []
    if distances is None:
        #直線距離
        for plnt_row in plnt_df.itertuples():
            for dc_row in dc_df.itertuples():
                dist.append( distance((plnt_row.lat,plnt_row.lon),(dc_row.lat,dc_row.lon)).kilometers )
                kind.append("plnt-dc")
        for cust_row in cust_df.itertuples():
            for dc_row in dc_df.itertuples():
                dist.append( distance((cust_row.lat,cust_row.lon),(dc_row.lat,dc_row.lon)).kilometers )
                kind.append("dc-cust")

    else:
        #顧客と倉庫は同じと仮定し，道路距離で計算
        n = len(cust_df)
        m = len(plnt_df)
        for i in range(n,n+m):
            for j in range(n):
                if  distances[i][j] < 99999999:
                    dist.append( distances[i][j]/1000.) 
                    kind.append("plnt-dc")
                
        for i in range(n):
            for j in range(n):
                if  distances[i][j] < 99999999:
                    dist.append( distances[i][j]/1000.) 
                    kind.append("dc-cust")
                
    df = pd.DataFrame({"dist": dist, "kind":kind})
    fig = px.histogram(df, x="dist", color="kind")       
    return fig

# %% ../nbs/05lnd.ipynb 125
def make_network_using_road(cust_df, dc_df, plnt_df, durations, distances, plnt_dc_threshold = 999999., dc_cust_threshold = 999999.,
                 tc_per_dis = 20./20000, dc_per_dis = 10./4000, tc_per_time = 8000./20000, dc_per_time = 8000./4000, lt_lb =1, lt_threshold = 800., stage_time_bound=(1,1)):
    """
    輸送・配送経路の生成
    """
    assert lt_threshold > 0.001
    # 名称が数字の場合困るので文字列に変換
    cust_df["name"] = cust_df["name"].astype(str)
    dc_df["name"] = dc_df["name"].astype(str)
    plnt_df["name"] = plnt_df["name"].astype(str)
    #描画用に座標positionに保管
    graph = nx.Graph()
    graph.add_nodes_from("Plnt_"+ plnt_df.name)
    graph.add_nodes_from("DC_"+ dc_df.name )
    graph.add_nodes_from("Cust_"+ cust_df.name )
    position={}
    for row in plnt_df.itertuples():
        position["Plnt_"+ str(row.name)] =(row.lon, row.lat)
    for row in dc_df.itertuples():
        position["DC_"+ str(row.name) ] =(row.lon, row.lat)
    for row in cust_df.itertuples():
        position["Cust_"+ str(row.name) ] =(row.lon, row.lat)

    dist, kind, time_list, cost, lead_time, stage_time = [], [], [], [], [], []
    from_node, to_node = [], []
    
    n = len(cust_df)
    for i, plnt_row in enumerate(plnt_df.itertuples()):
        for j, dc_row in enumerate(dc_df.itertuples()):

            if distances[n+i][j] < 9999999:
                dis = distances[n+i][j]/1000.
                time = durations[n+i][j]/3600.
            else:
                dis = 10*distance((plnt_row.lat,plnt_row.lon),(dc_row.lat,dc_row.lon)).kilometers
                time = dis/50. #時速
            if dis <= plnt_dc_threshold:
                from_node.append(plnt_row.name)
                to_node.append(dc_row.name)
                dist.append( dis )
                time_list.append( time )
                kind.append("plnt-dc")
                cost.append( dis*tc_per_dis + time*tc_per_time )
                lead_time.append( math.ceil(dis/lt_threshold) + lt_lb )
                stage_time.append( random.randint(stage_time_bound[0], stage_time_bound[1]) )
                if dis < 9999999:
                    graph.add_edge("Plnt_"+ str(plnt_row.name), "DC_"+ str(dc_row.name))

    for i, cust_row in enumerate(cust_df.itertuples()):
        for j, dc_row in enumerate(dc_df.itertuples()):

            if distances[i][j] < 9999999:
                dis = distances[i][j]/1000.
                time = durations[i][j]/3600.
            else:
                dis = 10*distance((cust_row.lat,cust_row.lon),(dc_row.lat,dc_row.lon)).kilometers
                time = dis/50. #時速
            if dis <= dc_cust_threshold:
                from_node.append(dc_row.name)
                to_node.append(cust_row.name)
                dist.append( dis )
                time_list.append( time ) 
                kind.append("dc-cust")
                cost.append( dis*dc_per_dis + time*dc_per_time  )
                lead_time.append( math.ceil(dis/lt_threshold) + lt_lb )
                stage_time.append( random.randint(stage_time_bound[0], stage_time_bound[1]) )
                if dis < 9999999:
                    graph.add_edge("DC_"+str(dc_row.name), "Cust_"+ str(cust_row.name))

    trans_df = pd.DataFrame({"from_node":from_node, "to_node":to_node, "dist": dist, "time":time_list, "cost":cost, "lead_time": lead_time, "stage_time":stage_time, "kind":kind})
    return trans_df, graph, position

# %% ../nbs/05lnd.ipynb 134
def make_network(cust_df, dc_df, plnt_df, plnt_dc_threshold = 999999., dc_cust_threshold = 999999.,
                 unit_tp_cost = 1., unit_del_cost = 1.,lt_lb =1, lt_threshold = 800., stage_time_bound=(1,1)):
    """
    輸送・配送経路の生成: 
    """
    assert lt_threshold > 0.001
    # 名称が数字の場合困るので文字列に変換
    cust_df["name"] = cust_df["name"].astype(str)
    dc_df["name"] = dc_df["name"].astype(str)
    plnt_df["name"] = plnt_df["name"].astype(str)
    #描画用に座標positionに保管
    graph = nx.Graph()
    graph.add_nodes_from("Plnt_"+ plnt_df.name)
    graph.add_nodes_from("DC_"+ dc_df.name )
    graph.add_nodes_from("Cust_"+ cust_df.name )
    position={}
    for row in plnt_df.itertuples():
        position["Plnt_"+ str(row.name)] =(row.lon, row.lat)
    for row in dc_df.itertuples():
        position["DC_"+ str(row.name) ] =(row.lon, row.lat)
    for row in cust_df.itertuples():
        position["Cust_"+ str(row.name) ] =(row.lon, row.lat)

    dist, kind, cost, lead_time, stage_time = [], [], [], [], []
    from_node, to_node = [], []
    for plnt_row in plnt_df.itertuples():
        for dc_row in dc_df.itertuples():
            dis = distance((plnt_row.lat,plnt_row.lon),(dc_row.lat,dc_row.lon)).kilometers
            if dis <= plnt_dc_threshold:
                from_node.append(plnt_row.name)
                to_node.append(dc_row.name)
                dist.append( dis )
                kind.append("plnt-dc")
                cost.append( dis*unit_tp_cost )
                lead_time.append( math.ceil(dis/lt_threshold) + lt_lb )
                stage_time.append( random.randint(stage_time_bound[0], stage_time_bound[1]) )
                graph.add_edge("Plnt_"+ str(plnt_row.name), "DC_"+ str(dc_row.name))

    for cust_row in cust_df.itertuples():
        for dc_row in dc_df.itertuples():
            dis = distance((cust_row.lat,cust_row.lon),(dc_row.lat,dc_row.lon)).kilometers
            if dis <= dc_cust_threshold:
                from_node.append(dc_row.name)
                to_node.append(cust_row.name)
                dist.append( dis )
                kind.append("dc-cust")
                cost.append( dis*unit_del_cost )
                lead_time.append( math.ceil(dis/lt_threshold) + lt_lb )
                stage_time.append( random.randint(stage_time_bound[0], stage_time_bound[1]) )
                graph.add_edge("DC_"+str(dc_row.name), "Cust_"+ str(cust_row.name))

    trans_df = pd.DataFrame({"from_node":from_node, "to_node":to_node, "dist": dist, "cost":cost, "lead_time": lead_time, "stage_time":stage_time, "kind":kind})
    return trans_df, graph, position

# %% ../nbs/05lnd.ipynb 139
def remove_zero_cust(cust_df, demand_df):
    """
    需要が０の地点を除く関数
    """
    #顧客ごとの需要量の計算
    demand_pivot = pd.pivot_table(demand_df,index="cust",values="demand")
    dic = {}
    for row in demand_pivot.itertuples():
        dic[ row.Index ] = row.demand
    total_demand = []
    for row in cust_df.itertuples():
        total_demand.append( dic[ row.name ] )
    #total_demand[-1] = 0. # 例として最後の顧客の需要を0に設定する。
    cust_df["total_demand"] = total_demand
    new_cust_df = cust_df[  cust_df.total_demand > 0.]
    #new_cust_df.tail() #那覇市が除かれたデータフレーム
    return new_cust_df

# %% ../nbs/05lnd.ipynb 142
def remove_zero_total_demand(total_demand_df, cust_df):
    
    td = pd.pivot_table(total_demand_df, index="cust", values="demand")
    td.reset_index(inplace=True)
    nonzero = td[ td.demand >0 ]
    
    try:
        cust_df.set_index("name", inplace=True)
    except:
        pass
    try: #顧客のインデックスが文字列の場合
        idx =  list( map(str, nonzero.cust) )
        cust_df = cust_df.loc[ idx, :]
    except: #顧客のインデックスが整数の場合
        idx =  nonzero.cust
        cust_df = cust_df.loc[ idx, :]
    cust_df.reset_index(inplace=True)
    return cust_df

# %% ../nbs/05lnd.ipynb 146
def plot_scm(cust_df, dc_df, plnt_df, graph, position, node_only=False):
    """
    顧客、倉庫、工場データフレームを入れると、PlotlyのFigureオブジェクトに地図を入れて返す関数
    """
    data = [
        go.Scattermapbox(
            lat=cust_df.iloc[:,1],
            lon=cust_df.iloc[:,2],
            mode='markers',
            marker=dict(
                size=10, color="blue", opacity=0.9
            ),
            text=cust_df.iloc[:,0],
            name="Customers"
        ),
        go.Scattermapbox(
            lat=dc_df.iloc[:,1],
            lon=dc_df.iloc[:,2],
            mode='markers',
            marker=dict(
                size=20, color="red", opacity=0.6
            ),
            text=dc_df.iloc[:,0],
            name="Warehouses"
        ),
        go.Scattermapbox(
            lat=plnt_df.iloc[:,1],
            lon=plnt_df.iloc[:,2],
            mode='markers',
            marker=dict(
                size=30, color="orange", opacity=0.8
            ),
            text=plnt_df.iloc[:,0],
            name="Plants"
        ),
    ]
    
    if node_only == False:
        edge_trace_lat, edge_trace_lon = [], []
        for (i,j) in graph.edges():
            edge_trace_lat += [position[i][1], position[j][1], None]
            edge_trace_lon += [position[i][0], position[j][0], None]
            
        data.append(    
            go.Scattermapbox(
                lat=edge_trace_lat,
                lon=edge_trace_lon,
                line=dict(width=0.5, color='yellow'),
                hoverinfo='none',
                mode='lines',
                name="Edges"
            )
        )

    layout = go.Layout(
        autosize=True,
        hovermode='closest',
        mapbox=dict(
            accesstoken=mapbox_access_token,
            bearing=0,
            center=dict(
                lat=35.8573157,
                lon=139.64696
            ),
            pitch=0,
            zoom=5,
            style="dark"  # 'satellite-streets'
        ),
    )

    fig = go.Figure(data=data, layout=layout)
    return fig

# %% ../nbs/05lnd.ipynb 151
def digit_histgram(df, col_name = ""):
    """
     数値の桁数のヒストグラムを返す関数
    """
    num_digit, num_float_digit = [], []
    for d in df[col_name]:
        nd, nfd = map(len, str(d).split(".") )
        num_digit.append(nd)
        num_float_digit.append(nfd)

    digit_df = pd.DataFrame( {col_name+"_digits":num_digit, col_name+ "_float_digits":num_float_digit})

    digit_stack = pd.DataFrame(digit_df.stack(), columns=["digits"]).reset_index()
    max_digits = digit_stack.digits.max()
    fig = px.histogram(digit_stack, x= "digits", color="level_1", opacity =0.5, range_x= (1,max_digits) )
    return fig

# %% ../nbs/05lnd.ipynb 165
def solve_lnd(prod_df, cust_df, dc_df, plnt_df, plnt_prod_df, total_demand_df, trans_df, dc_num=None, single_sourcing=True, max_cpu = 100):
    """
    データフレームからロジスティック・ネットワーク設計モデルを解く関数
    """
    weight = {str(p):w for p,w in zip(prod_df.name, prod_df.weight)}
    cust = {str(c):(lat,lon) for c,lat,lon in zip(cust_df.name, cust_df.lat, cust_df.lon)}
    dc = {str(c):(lat,lon) for c,lat,lon in zip(dc_df.name, dc_df.lat, dc_df.lon)}
    dc_lb = {str(c):lb for c,lb in zip(dc_df.name, dc_df.lb) }
    dc_ub = {str(c):ub for c,ub in zip(dc_df.name, dc_df.ub) }
    plnt = {str(c):(lat,lon) for c,lat,lon in zip(plnt_df.name, plnt_df.lat, plnt_df.lon)}
    plnt_ub = {(str(p), str(pro)):ub  for p,pro,ub in zip(plnt_prod_df.plnt, plnt_prod_df["prod"], plnt_prod_df.ub) }
    demand = {(str(c), str(pro)):d  for c,pro,d in zip(total_demand_df.cust, total_demand_df["prod"], total_demand_df.demand) }

    tp_df = trans_df[ trans_df.kind =="plnt-dc"]
    del_df = trans_df[ trans_df.kind =="dc-cust"]

    tp_cost = { (str(f),str(t)):c for f,t,c in zip(tp_df.from_node, tp_df.to_node, tp_df.cost)}
    del_cost = { (str(f),str(t)):c for f,t,c in zip(del_df.from_node, del_df.to_node, del_df.cost)}

    dc_fc = {str(dc):dc_fc for dc,dc_fc in zip(dc_df.name, dc_df.fc)}
    dc_vc = {str(dc):dc_vc for dc,dc_vc in zip(dc_df.name, dc_df.vc)}
    
    prod_set = set(weight.keys())
    plnt_to_dc = set((i,j,p) for i in plnt for j in dc for p in prod_set
                     if plnt_ub.get((i,p),0) > 0 and (i,j) in tp_cost)
    dc_to_cust = set((j,k,p) for j in dc for (k,p) in demand if (j,k) in del_cost)

    if single_sourcing:
        model = lnd_ss(weight, cust, dc, dc_lb, dc_ub, plnt, plnt_ub, demand, tp_cost, del_cost, dc_fc, dc_vc, dc_num)
    else:
        model = lnd_ms(weight, cust, dc, dc_lb, dc_ub, plnt, plnt_ub, demand, tp_cost, del_cost, dc_fc, dc_vc, dc_num)

    if GUROBI:
        #model.Params.NumericFocus = 3
        model.optimize()
    else:
        solver = PULP_CBC_CMD(timeLimit=max_cpu, presolve=True, msg=1)
        try:
            model.optimize(solver)  #pulpのバージョンが違う場合のため
        except:
            model.optimize()
    
    if model.Status !=2: #最適解でないときの処理
        raise SolverError(f"Falied to solve the problem! Status Code is {model.Status}.")

    epsilon = 1.00e-4
    if single_sourcing:
        x, y, z, slack, dc_slack, cost = model.__data
    else:
        x, y, slack, dc_slack, cost = model.__data
        
    from_node, to_node, prod, flow = [],[],[],[]
    #需要不足量の計算
    slack_list = [ ]
    cust_list = [ ]
    prod_list =[ ]
    if single_sourcing:
        for i in slack:
            #print(i,slack[i].X)
            if slack[i].X>epsilon:
                #print(i,slack[i].X)
                for p in prod_set:
                    if (i,p) in demand:
                        slack_list.append(demand[i,p])
                        cust_list.append(i)
                        prod_list.append(p)
    else:
        for (i,p) in slack:
            if slack[i,p].X>epsilon:
                #print(i,p,slack[i,p].X)
                slack_list.append(slack[i,p].X)
                cust_list.append(i)
                prod_list.append(p)
    violation_df = pd.DataFrame({"cust":cust_list, "prod":prod_list, "value":slack_list})

    #倉庫の下限の逸脱
    lb_dev = []
    for j in dc_slack:
        lb_dev.append( dc_slack[j].X )
    dc_df["lower_bound_violation"] = lb_dev

    cost_list =[cost[i].X for i in range(5)]
    total_cost = sum(cost_list)
    cost_list.insert(0, total_cost)
    cost_name =["total cost", "transportation (plant to dc)", "delivery (dc to customer)", "dc fixed", "dc variable", "infeasible penalty" ]
    cost_df = pd.DataFrame.from_dict({"cost": cost_name, "value":cost_list})
    #for j in y:
    #    print(dc_ub[j], quicksum(x[i,j,p].X for i in plnt for p in prod_df.name if (i,j,p) in x))
    if single_sourcing:
        for (i,j,p) in x:
            if x[i,j,p].X > epsilon:
                #print(i,j,p,x[i,j,p].X)
                from_node.append("Plnt_"+str(i))
                to_node.append("DC_"+str(j))
                prod.append(p)
                flow.append(x[i,j,p].X)
        for (j,k) in z:
            if z[j,k].X > epsilon:
                for p in weight:
                    if (k,p) in demand:
                        #print(j,k,p,demand[k,p])
                        from_node.append("DC_"+str(j))
                        to_node.append("Cust_"+str(k))
                        prod.append(p)
                        flow.append(demand[k,p])
    else: #multi-soucing
        for (i,j,p) in plnt_to_dc:
            if x[i,j,p].X > epsilon:
                from_node.append("Plnt_"+str(i))
                to_node.append("DC_"+str(j))
                prod.append(p)
                flow.append(x[i,j,p].X)
        for (j,k,p) in dc_to_cust:
            if x[j,k,p].X > epsilon:
                from_node.append("DC_"+str(j))
                to_node.append("Cust_"+str(k))
                prod.append(p)
                flow.append(x[j,k,p].X)

    flow_df = pd.DataFrame.from_dict({"from_node":from_node, "to_node":to_node, "prod":prod, "flow":flow})
    #flow_df.to_csv("flow.csv")
    #flow_df.head()
    open_close = []
    for j in y:
        #print(DC[j],y[j].X)
        open_close.append( int(y[j].X) )
    dc_df["open_close"] = open_close

    return flow_df, dc_df, cost_df, violation_df, model.Status

# %% ../nbs/05lnd.ipynb 172
def show_optimized_network(cust_df, dc_df, plnt_df, prod_df, flow_df, position):
    """
    顧客、倉庫、工場、輸・配送データフレームを入れると、PlotlyのFigureオブジェクトに地図を描画
    """

    pd.set_option('mode.chained_assignment',None)
    
    data = [
        go.Scattermapbox(
            lat=cust_df.iloc[:,1],
            lon=cust_df.iloc[:,2],
            mode='markers',
            marker=dict(
                size=10, color="blue", opacity=0.9
            ),
            text=cust_df.iloc[:,0],
            name="Customers"
        ),
        go.Scattermapbox(
            lat=dc_df.iloc[:,1][ dc_df.open_close==1 ] ,
            lon=dc_df.iloc[:,2][ dc_df.open_close==1 ] ,
            mode='markers',
            marker=dict(
                size=20, color="red", opacity=0.6
            ),
            text=dc_df.iloc[:,0],
            name="Warehouses"
        ),
        go.Scattermapbox(
            lat=plnt_df.iloc[:,1],
            lon=plnt_df.iloc[:,2],
            mode='markers',
            marker=dict(
                size=30, color="orange", opacity=0.8
            ),
            text=plnt_df.iloc[:,0],
            name="Plants"
        ),
    ]

    for p in prod_df.iloc[:,0]:
        edge_trace_lat, edge_trace_lon = [], []
        temp_df = flow_df[ flow_df["prod"]==str(p) ]
        for row in temp_df.itertuples():
            i = row.from_node
            j = row.to_node
            edge_trace_lat += [position[i][1], position[j][1], None]
            edge_trace_lon += [position[i][0], position[j][0], None]
        data.append(
            go.Scattermapbox(
                lat=edge_trace_lat,
                lon=edge_trace_lon,
                line=dict(width=0.5),
                hoverinfo='none',
                mode='lines',
                name= str(p)
            )
        )
    layout = go.Layout(
        autosize=True,
        hovermode='closest',
        mapbox=dict(
            accesstoken=mapbox_access_token,
            bearing=0,
            center=dict(
                lat=35.8573157,
                lon=139.64696
            ),
            pitch=0,
            zoom=5,
            style="dark"  # 'satellite-streets'
        ),
    )

    fig = go.Figure(data=data, layout=layout)
    return fig

# %% ../nbs/05lnd.ipynb 178
def make_excel_melos():
    #テンプレ生成
    wb = Workbook()
    ws = wb.active
    wb.remove(ws)
    ws = wb.create_sheet(title="顧客")
    ws.append(["顧客名称（ID）","緯度(小数)","経度（小数)"])
    #コメント
    ws.cell(1,1).comment = Comment("顧客の名称（住所などの付加情報）", "logopt")
    ws.cell(1,2).comment = Comment("顧客の緯度．形式例 40.268． Google Mapで右クリック", "logopt")
    ws.cell(1,3).comment = Comment("顧客の経度．形式例 135.6983 Google Mapで右クリック", "logopt")

    #データチェック
    dv = DataValidation(type="decimal", allow_blank=False)
    ws.add_data_validation(dv)
    dv.add('B2:C1048576') 
    
    ws = wb.create_sheet(title="倉庫候補地点")
    ws.append(["倉庫候補地点名称（ID）","緯度(小数)","経度（小数)", "容量下限(m3)", "容量上限(m3)", "固定費用（円）", "変動費用（円/unit)"])
    #コメント
    ws.cell(1,1).comment = Comment("倉庫候補地点の名称（住所などの付加情報）", "logopt")
    ws.cell(1,2).comment = Comment("倉庫候補地点の緯度．形式例 35.6983 Google Mapで右クリック", "logopt")
    ws.cell(1,3).comment = Comment("倉庫候補地点の経度．形式例 140.268． Google Mapで右クリック", "logopt")
    ws.cell(1,4).comment = Comment("倉庫を開設したときの使用容量の下限(m3)", "logopt")
    ws.cell(1,5).comment = Comment("倉庫を開設したときの使用容量の上限(m3)", "logopt")  
    ws.cell(1,6).comment = Comment("倉庫の開設にかかる年間固定費用（円）", "logopt")   
    ws.cell(1,7).comment = Comment("倉庫を通過した製品1単位にかかる費用（円/unit）", "logopt")   
    
    #データチェック
    dv = DataValidation(type="decimal", allow_blank=False)
    ws.add_data_validation(dv)
    dv.add('B2:G1048576') 
    
    ws = wb.create_sheet(title="工場")
    ws.append(["工場名称（ID）","緯度(小数)","経度（小数)"])
    #コメント
    ws.cell(1,1).comment = Comment("工場の名称（住所などの付加情報）", "logopt")
    ws.cell(1,2).comment = Comment("工場の緯度．形式例 35.6983 Google Mapで右クリック", "logopt")
    ws.cell(1,3).comment = Comment("工場の経度．形式例 140.268 Google Mapで右クリック", "logopt")

    #データチェック
    dv = DataValidation(type="decimal", allow_blank=False)
    ws.add_data_validation(dv)
    dv.add('B2:C1048576') 
    
    
    ws = wb.create_sheet(title="製品")
    ws.append(["製品名称（ID）","重量(kg/unit)","容量(m3/unit)"])
    #コメント
    ws.cell(1,1).comment = Comment("製品の名称", "logopt")
    ws.cell(1,2).comment = Comment("製品の重量（輸配送費用の計算に用いる）", "logopt")
    ws.cell(1,3).comment = Comment("製品の容量（倉庫の容量制約で用いる）", "logopt")

    #データチェック
    dv = DataValidation(type="decimal", allow_blank=False)
    ws.add_data_validation(dv)
    dv.add('B2:C1048576')  
    
    return wb

# %% ../nbs/05lnd.ipynb 181
def make_demand_production_sheets(wb):
    #製品データ読み込み
    data = wb["製品"].values
    cols = next(data)[:]
    data = list(data)
    prod_df = pd.DataFrame(data, columns=cols).dropna(how="all") 
    products = prod_df.iloc[:,0]

    data = wb["顧客"].values
    cols = next(data)[:]
    data = list(data)
    cust_df = pd.DataFrame(data, columns=cols).dropna(how="all") 
    customers = cust_df.iloc[:,0]

    data = wb["工場"].values
    cols = next(data)[:]
    data = list(data)
    plnt_df = pd.DataFrame(data, columns=cols).dropna(how="all") 
    plants = plnt_df.iloc[:,0]

    ws_demand = wb.create_sheet("需要")
    if len(products) >=1:
        ws_demand.append(["顧客/製品"] + list(products))
        for c in customers:
            ws_demand.append([str(c)])
        #data validation
        dv = DataValidation(type="decimal",
                            operator="greaterThanOrEqual",
                            formula1=0.)
        cell = ws_demand.cell(1,len(products)+1)
        col_name = cell.column_letter
        dv.add(f'B2:{col_name}1048576') 
        ws_demand.add_data_validation(dv)

    ws_production = wb.create_sheet("生産")
    if len(products)>=1:
        ws_production.append(["工場/製品"] + list(products))
        for p in plants:
            ws_production.append([str(p)])
        ws_production.add_data_validation(dv)   
    
    return wb

# %% ../nbs/05lnd.ipynb 184
def prepare_df_for_melos(wb): 
    #基本wbのシートの読み込みとデータフレームの準備
    data = wb["顧客"].values
    cols = next(data)[:]
    data = list(data)
    cust_df = pd.DataFrame(data, columns=["name","lat","lon"]).dropna(how="all") 
    #cust_df = pd.DataFrame(data, columns=cols).dropna(how="all") 
    
    data = wb["倉庫候補地点"].values
    cols = next(data)[:]
    data = list(data)
    dc_df = pd.DataFrame(data, columns=cols).dropna(how="all") 
    
    data = wb["工場"].values
    cols = next(data)[:]
    data = list(data)
    #plnt_df = pd.DataFrame(data, columns=["name","lat","lon"]).dropna(how="all") 
    plnt_df = pd.DataFrame(data, columns=cols).dropna(how="all") 
    
    data = wb["製品"].values
    cols = next(data)[:]
    data = list(data)
    #prod_df = pd.DataFrame(data, columns=["name", "weight", "volume"]).dropna(how="all") 
    prod_df = pd.DataFrame(data, columns=cols).dropna(how="all") 
    
    data = wb["需要"].values
    cols = next(data)[:]
    data = list(data)
    demand_df = pd.DataFrame(data, columns=cols).dropna(how="all")
    
    data = wb["生産"].values
    cols = next(data)[:]
    data = list(data)
    production_df = pd.DataFrame(data, columns=cols).dropna(how="all")
    return  cust_df, dc_df, plnt_df, prod_df, demand_df, production_df

# %% ../nbs/05lnd.ipynb 187
def prepare_trans_df(wb, plnt_df, dc_df, cust_df): 
    data = wb["輸配送ルート"].values
    cols = next(data)[:]
    data = list(data)
    trans_df = pd.DataFrame(data, columns=cols).dropna(how="all") 
    
    graph = nx.Graph()
    position={}
    for row in plnt_df.itertuples():
        graph.add_node("Plnt_"+ str(row[1]))
        position["Plnt_"+ str(row[1])] =(row[3], row[2])
    for row in dc_df.itertuples():
        graph.add_node("DC_"+ str(row[1]))
        position["DC_"+ str(row[1])] =(row[3], row[2])
    for row in cust_df.itertuples():
        graph.add_node("Cust_"+ str(row[1]))
        position["Cust_"+ str(row[1])] =(row[3], row[2])
        
    for row in trans_df.itertuples():
        if row[10] == "plnt-dc":
            graph.add_edge("Plnt_"+ str(row[1]), "DC_"+ str(row[4]))
        else:
            graph.add_edge("DC_"+ str(row[1]), "Cust_"+ str(row[4]))
            
    return trans_df, graph, position

# %% ../nbs/05lnd.ipynb 191
def customer_aggregation(wb, cust_df, prod_df, demand_df, num_of_facilities):   
    #集約のためのweightの計算
    weight_of_prod = prod_df.iloc[:,1]
    dem = demand_df.iloc[:,1:].values
    n_cust = len(cust_df)
    n_prod = len(prod_df)
    weight = np.zeros(shape=n_cust)
    for i in range(n_cust):
        for p in range(n_prod):
            weight[i] += dem[i][p]*weight_of_prod[p]
    #道路距離と時間の計算
    durations,  distances, node_df = compute_durations(cust_df, toll=True, host= host)                
    X, Y, partition, cost = hierarchical_clusterning(cust_df, weight, durations, num_of_facilities, linkage="complete")
    fig = show_optimized_continuous_network(cust_df, X, Y, partition, weight=weight)
    aggregated_cust_df = make_aggregated_cust_df(cust_df, X, Y, partition, weight)
    dem_agg = np.zeros(shape =(num_of_facilities, n_prod))
    for i, row in enumerate(aggregated_cust_df.itertuples()):
        for c in row[4]:
            for p in range(n_prod):
                dem_agg[i,p] += dem[c, p]
    ws = wb.create_sheet(title="集約顧客")
    ws.append(["集約顧客","緯度(小数)", "経度（小数)","顧客リスト"] + list(prod_df.iloc[:,0]))
    for i in range(num_of_facilities):
        ws.append( list(aggregated_cust_df.iloc[i,:3]) +[str(aggregated_cust_df.iloc[i,3])]+ list(dem_agg[i]) )
    return wb, fig

# %% ../nbs/05lnd.ipynb 195
def make_network_for_excel(wb, cust_df, dc_df, plnt_df, plnt_dc_threshold = 999999., dc_cust_threshold = 999999.,
                 tc_per_dis = 20./20000, dc_per_dis = 10./4000, tc_per_time = 8000./20000, dc_per_time = 8000./4000,
                 default_mult=10.,default_velocity = 30. ):

    #距離と時間の計算
    ROUTE =[]
    for row in plnt_df.iloc[:,:3].itertuples():
        ROUTE.append( [row[2], row[3]] )
    for row in dc_df.iloc[:,:3].itertuples():
        ROUTE.append( [row[2], row[3]] )
    for row in cust_df.iloc[:,:3].itertuples():
        ROUTE.append( [row[2], row[3]] )
    route_str =""
    for (i,j) in ROUTE[:]:
        route_str += str(j)+","+str(i)+";"
    response = requests.get(f'http://{host}:5000/table/v1/driving/'+route_str[:-1]+"?annotations=distance,duration")
    result = response.json()
    try:
        durations = result["durations"]
        distances = result["distances"]
    except:
        raise ValueError 
    n = len(ROUTE)
    for i in range(n):
        for j in range(n):
            if durations[i][j] is None:
                #print(i,j)
                durations[i][j] = 999999999
                distances[i][j] = 999999999

    #描画用に座標positionに保管
    graph = nx.Graph()
    position={}
    for row in plnt_df.itertuples():
        graph.add_node("Plnt_"+ str(row[1]))
        position["Plnt_"+ str(row[1])] =(row[3], row[2])
    for row in dc_df.itertuples():
        graph.add_node("DC_"+ str(row[1]))
        position["DC_"+ str(row[1])] =(row[3], row[2])
    for row in cust_df.itertuples():
        graph.add_node("Cust_"+ str(row[1]))
        position["Cust_"+ str(row[1])] =(row[3], row[2])

    dist, kind, time_list, cost = [], [], [], [], 
    from_node, to_node = [], []
    from_lat, to_lat = [], []
    from_lon, to_lon = [], []

    n_plnt = len(plnt_df)
    n_dc = len(dc_df)
    n_cust = len(cust_df)
    for i, plnt_row in enumerate(plnt_df.itertuples()):
        for j, dc_row in enumerate(dc_df.itertuples()):
            if distances[i][n_plnt+j] < 9999999:
                dis = distances[i][n_plnt+j]/1000.  # km 
                time = durations[i][n_plnt+j]/3600. # h
            else:
                dis = default_mult*distance((plnt_row[2],plnt_row[3]),(dc_row[2],dc_row[3])).kilometers
                time = dis/default_velocity #時速

            if dis <= plnt_dc_threshold:
                from_node.append(plnt_row[1])
                from_lat.append(plnt_row[2])
                from_lon.append(plnt_row[3])
                to_node.append(dc_row[1])
                to_lat.append(dc_row[2])
                to_lon.append(dc_row[3])
                dist.append( dis )
                time_list.append( time )
                kind.append("plnt-dc")
                cost.append( dis*tc_per_dis + time*tc_per_time )
                graph.add_edge("Plnt_"+ str(plnt_row[1]), "DC_"+ str(dc_row[1]))

    for i, dc_row in enumerate(dc_df.itertuples()):
        for j,cust_row in enumerate(cust_df.itertuples()):
            ii = n_plnt+i
            jj = n_plnt+n_dc+j
            if distances[ii][jj] < 9999999:
                dis = distances[ii][jj]/1000.
                time = durations[ii][jj]/3600.
            else:
                dis = default_mult*distance((plnt_row[2],plnt_row[3]),(dc_row[2],dc_row[3])).kilometers
                time = dis/default_velocity #時速

            if dis <= dc_cust_threshold:
                from_node.append(dc_row[1])
                from_lat.append(dc_row[2])
                from_lon.append(dc_row[3])
                to_node.append(cust_row[1])
                to_lat.append(cust_row[2])
                to_lon.append(cust_row[3])
                dist.append( dis )
                time_list.append( time ) 
                kind.append("dc-cust")
                cost.append( dis*dc_per_dis + time*dc_per_time)
                graph.add_edge("DC_"+ str(dc_row[1]), "Cust_"+ str(cust_row[1]))

    trans_df = pd.DataFrame({"発地":from_node, "発地緯度": from_lat, "発地経度": from_lon, "着地":to_node, "着地緯度": to_lat, "着地経度": to_lon,
                             "距離(km)": dist, "時間(h)":time_list, "費用(円/kg)":cost,  "種類":kind})
    
    ws = wb.create_sheet(title="輸配送ルート")
    for r in dataframe_to_rows(trans_df, index=False, header=True):
        ws.append(r)
    
    return wb, trans_df, graph, position 

# %% ../nbs/05lnd.ipynb 200
def solve_lnd_for_excel(wb, prod_df, cust_df, dc_df, plnt_df, demand_df, production_df, trans_df, dc_num=None, single_sourcing=True, 
                        max_cpu = 100, aggregation = False, 
                        fix_y = None, dc_slack_penalty=10000., demand_slack_penalty=10000000.):
    #nanの処理
    prod_df.fillna(0, inplace=True)
    dc_df.fillna(0, inplace=True)

    tp_df = trans_df[ trans_df.種類 =="plnt-dc"]
    del_df = trans_df[ trans_df.種類 =="dc-cust"]

    tp_cost = { (str(f),str(t)):c for f,t,c in zip(tp_df.iloc[:,0], tp_df.iloc[:,3], tp_df.iloc[:,8])}
    del_cost = { (str(f),str(t)):c for f,t,c in zip(del_df.iloc[:,0], del_df.iloc[:,3], del_df.iloc[:,8])}
    weight = {str(p): float(w) for p,w in zip(prod_df.iloc[:,0], prod_df.iloc[:,1])}
    volume = {str(p): float(w) for p,w in zip(prod_df.iloc[:,0], prod_df.iloc[:,2])}
    prod_list = list(weight.keys())
    prod_set = set(prod_list)
    cust = {str(c):(lat,lon) for c,lat,lon in zip(cust_df.iloc[:,0], cust_df.iloc[:,1], cust_df.iloc[:,2])}
    dc = {str(c):(lat,lon) for c,lat,lon in zip(dc_df.iloc[:,0], dc_df.iloc[:,1], dc_df.iloc[:,2])}
    dc_lb = {str(c):lb for c,lb in zip(dc_df.iloc[:,0], dc_df.iloc[:,3]) }
    dc_ub = {str(c):ub for c,ub in zip(dc_df.iloc[:,0], dc_df.iloc[:,4]) }
    dc_fc = {str(dc):dc_fc for dc,dc_fc in zip(dc_df.iloc[:,0], dc_df.iloc[:,5])}
    dc_vc = {str(dc):dc_vc for dc,dc_vc in zip(dc_df.iloc[:,0], dc_df.iloc[:,6])}
        
    plnt = {str(c):(lat,lon) for c,lat,lon in zip(plnt_df.iloc[:,0], plnt_df.iloc[:,1], plnt_df.iloc[:,1])}
    production_df.fillna(0, inplace=True)
    production_array = production_df.iloc[:,1:].values
    plnt_ub ={}
    for i, pl in enumerate(plnt):
        for j, pr in enumerate(prod_list):
            plnt_ub[pl, pr] = production_array[i,j]
    
    demand ={} 
    if aggregation: #集約顧客の場合
        cust_df.fillna(0, inplace=True)
        demand_array = cust_df.iloc[:,4:].values
        for i,c in enumerate(cust):
            for j,p in enumerate(prod_list):
                demand[c,p] = demand_array[i,j]
    else:  #もとの顧客の場合
        demand_df.fillna(0, inplace=True)
        demand_array = demand_df.iloc[:,1:].values
        for i,c in enumerate(cust):
            for j,p in enumerate(prod_list):
                demand[c,p] = demand_array[i,j]    
    
    plnt_to_dc = set((i,j,p) for i in plnt for j in dc for p in prod_set
             if plnt_ub.get((i,p),0) > 0 and (i,j) in tp_cost)
    dc_to_cust = set((j,k,p) for j in dc for (k,p) in demand if (j,k) in del_cost)
    
    if single_sourcing:
        model = lnd_ss(weight, cust, dc, dc_lb, dc_ub, plnt, plnt_ub, demand, tp_cost, del_cost, dc_fc, dc_vc, dc_num, volume, fix_y, dc_slack_penalty, demand_slack_penalty)
    else:
        model = lnd_ms(weight, cust, dc, dc_lb, dc_ub, plnt, plnt_ub, demand, tp_cost, del_cost, dc_fc, dc_vc, dc_num, volume, fix_y, dc_slack_penalty, demand_slack_penalty)
        
    if GUROBI:
        #model.Params.NumericFocus = 3
        model.optimize()
    else:
        solver = PULP_CBC_CMD(timeLimit=max_cpu, presolve=True, msg=1)
        try:
            model.optimize(solver)  #pulpのバージョンが違う場合のため
        except:
            model.optimize()

    if model.Status !=2: #最適解でないときの処理
        raise SolverError(f"Falied to solve the problem! Status Code is {model.Status}.")

    epsilon = 1.00e-4
    if single_sourcing:
        x, y, z, slack, dc_slack, cost = model.__data
    else:
        x, y, slack, dc_slack, cost = model.__data

    from_node, to_node, prod, flow = [],[],[],[]
    #需要不足量の計算
    slack_list = [ ]
    cust_list = [ ]
    prod_list =[ ]
    if single_sourcing:
        for i in slack:
            #print(i,slack[i].X)
            if slack[i].X>epsilon:
                #print(i,slack[i].X)
                for p in prod_set:
                    if (i,p) in demand:
                        slack_list.append(demand[i,p])
                        cust_list.append(i)
                        prod_list.append(p)
    else:
        for (i,p) in slack:
            if slack[i,p].X>epsilon:
                #print(i,p,slack[i,p].X)
                slack_list.append(slack[i,p].X)
                cust_list.append(i)
                prod_list.append(p)
    violation_df = pd.DataFrame({"cust":cust_list, "prod":prod_list, "value":slack_list})

    #倉庫の下限の逸脱
    lb_dev = []
    for j in dc_slack:
        lb_dev.append( dc_slack[j].X )
    dc_df["lower_bound_violation"] = lb_dev

    cost_list =[cost[i].X for i in range(5)]
    total_cost = sum(cost_list)
    cost_list.insert(0, total_cost)
    cost_name =["total cost", "transportation (plant to dc)", "delivery (dc to customer)", "dc fixed", "dc variable", "infeasible penalty" ]
    cost_df = pd.DataFrame.from_dict({"cost": cost_name, "value":cost_list})
    #for j in y:
    #    print(dc_ub[j], quicksum(x[i,j,p].X for i in plnt for p in prod_df.name if (i,j,p) in x))
    if single_sourcing:
        for (i,j,p) in x:
            if x[i,j,p].X > epsilon:
                #print(i,j,p,x[i,j,p].X)
                from_node.append("Plnt_"+str(i))
                to_node.append("DC_"+str(j))
                prod.append(p)
                flow.append(x[i,j,p].X)
        for (j,k) in z:
            if z[j,k].X > epsilon:
                for p in weight:
                    if (k,p) in demand:
                        #print(j,k,p,demand[k,p])
                        from_node.append("DC_"+str(j))
                        to_node.append("Cust_"+str(k))
                        prod.append(p)
                        flow.append(demand[k,p])
    else: #multi-soucing

        for (i,j,p) in plnt_to_dc:
            if x[i,j,p].X > epsilon:
                from_node.append("Plnt_"+str(i))
                to_node.append("DC_"+str(j))
                prod.append(p)
                flow.append(x[i,j,p].X)
        for (j,k,p) in dc_to_cust:
            if x[j,k,p].X > epsilon:
                from_node.append("DC_"+str(j))
                to_node.append("Cust_"+str(k))
                prod.append(p)
                flow.append(x[j,k,p].X)

    flow_df = pd.DataFrame.from_dict({"from_node":from_node, "to_node":to_node, "prod":prod, "flow":flow})
    open_close = []
    for j in y:
        #print(DC[j],y[j].X)
        open_close.append( int(y[j].X) )
    dc_df["open_close"] = open_close

    return flow_df, dc_df, cost_df, violation_df, model.Status

# %% ../nbs/05lnd.ipynb 204
def add_result_for_melos(wb, flow_df, cost_df, violation_df, dc_df):
    ws = wb.create_sheet(title="費用内訳")
    for r in dataframe_to_rows(cost_df, index=False, header=True):
        ws.append(r)
    ws = wb.create_sheet(title="制約逸脱")
    for r in dataframe_to_rows(violation_df, index=False, header=True):
        ws.append(r)
    ws = wb.create_sheet(title="最適流量")
    for r in dataframe_to_rows(flow_df, index=False, header=True):
        ws.append(r)
    ws = wb["倉庫候補地点"]
    ws.cell(1,8).value = "下限逸脱量"
    ws.cell(1,9).value = "開設（=1)"
    for i,row in enumerate(dc_df.itertuples()):
        ws.cell(i+2, 8).value = row.lower_bound_violation
        ws.cell(i+2, 9).value = row.open_close
    return wb

# %% ../nbs/05lnd.ipynb 208
def extract_fix_dc_info(wb):
    ws = wb["倉庫候補地点"]
    fix_y = {}
    for i, row in enumerate(ws.iter_rows(min_row=2, min_col=9)):
        for cell in row:
            if cell.fill.fgColor.rgb != "00000000": #白以外の色の行を抽出
                val = int(cell.value)
                fix_y[i] = val
    return fix_y

# %% ../nbs/05lnd.ipynb 212
def make_vrp(cust_df, aggregated_cust_df, aggregated_dc_df, aggregated_flow_df, agg_df_cust):
    """
    ネットワーク設計モデルの結果をもとに配送最適化モデルを構築する関数
    """
    
    open_dc = [ ]
    for row in aggregated_dc_df.itertuples():
        if row.open_close > 0:
            open_dc.append( "DC_"+row.name )
    #print(open_dc)

    assigned_customers ={dc_name:[] for dc_name in open_dc}
    cluster ={}
    for row in aggregated_cust_df.itertuples():
        cluster[ row.name ] = ast.literal_eval( str(row.customers) ) #集約した顧客のクラスターに含まれる顧客番号のリスト
        
    flow_df = pd.pivot_table(aggregated_flow_df, index=["from_node", "to_node"], values="flow")
    flow_df.reset_index(inplace=True)
    for row in flow_df.itertuples():
        if row.to_node[:5] =="Cust_": #倉庫に割り当てられている集約した顧客のクラスターを追加
            assigned_customers[ row.from_node ].extend( cluster[ row.to_node[5:] ] )
    #print(assigned_customers)
    
    #顧客の需要を入れた辞書を準備
    demand_dic = {}
    try:
        agg_df_cust.reset_index(inplace=True)
    except:
        pass
    for row in agg_df_cust.itertuples():
        demand_dic[row.cust] = int(row.demand)
    
    #顧客データに需要を追加
    dem_list = []
    for row in cust_df.itertuples():
        dem_list.append( demand_dic[ row.name ] )
    cust_df["demand"] = dem_list
    
    #デポごとに顧客を入れた辞書
    customer_df_dic = {}
    for i in assigned_customers:
        customer_df_dic[i] = cust_df.iloc[ assigned_customers[i],:]
        
    depots = list(customer_df_dic.keys())
    
    return cust_df, assigned_customers, customer_df_dic, depots

# %% ../nbs/05lnd.ipynb 214
def aggregate_demand_by_cluster(cust_df, aggregated_cust_df, demand_df):
    """
    集約された顧客（クラスター）に対する需要データを作成する関数
    """
    #顧客が含まれている分割（クラスター番号）を作る
    partition = np.zeros(len(cust_df), int)
    for j,row in enumerate(aggregated_cust_df.itertuples()):
        for i in ast.literal_eval(row.customers):
            partition[i] = j

    #顧客データフレームに集約したクラスターの顧客番号を入れる
    cust_idx = {}
    for i,row in enumerate(cust_df.itertuples()):
        cust_idx[ row.name ] = i    

    cluster_idx =[]
    try:
        demand_df.reset_index(inplace=True)
    except ValueError:
        pass
    for row in demand_df.cust:
        cluster_idx.append( "cust"+ str(partition[ cust_idx[row]]) )
    demand_df.loc[:,"cluster_idx"] = cluster_idx
    #集約した顧客（クラスター）に対する製品別需要量
    aggregated_cluster_df = pd.pivot_table(demand_df, index=["date", "prod", "cluster_idx"], values="demand", aggfunc=sum)
    aggregated_cluster_df.reset_index(inplace=True)
    aggregated_cluster_df.rename(columns={"cluster_idx":"cust"}, inplace=True)
    
    return aggregated_cluster_df

# %% ../nbs/05lnd.ipynb 217
def convex_comb_sos(model, a, b):
    """convex_comb_sos -- add piecewise relation with gurobi's SOS constraints
    Parameters:
        - model: a model where to include the piecewise linear relation
        - a[k]: x-coordinate of the k-th point in the piecewise linear relation
        - b[k]: y-coordinate of the k-th point in the piecewise linear relation
    Returns the model with the piecewise linear relation on added variables x, f, and z.
    """
    K = len(a)-1
    z = {}
    for k in range(K+1):
        z[k] = model.addVar(ub=1) # do not name variables for avoiding clash
    x = model.addVar(lb=a[0],ub=a[K])
    f = model.addVar(lb=-GRB.INFINITY)
    model.update()

    model.addConstr(x == quicksum(a[k]*z[k] for k in range(K+1)))
    model.addConstr(f == quicksum(b[k]*z[k] for k in range(K+1)))

    model.addConstr(quicksum(z[k] for k in range(K+1)) == 1)
    model.addSOS(GRB.SOS_TYPE2, [z[k] for k in range(K+1)])

    return x, f, z

def LNDP(Node, ArcData, ProdData, ResourceData, ResourceProdData, ArcResourceData, ArcResourceProdData, NodeProdData, phi):
    
    Arc, ArcFC, Distance= multidict(ArcData)     
    Prod, Weight, VAR = multidict(ProdData)
    Child, Parent ={}, {}
    for (p,q) in phi:
        if q in Child:
            Child[q].append(p)
        else:
            Child[q] = [p] 
        if p in Parent:
            Parent[p].append(q)
        else:
            Parent[p] = [q]

    Resource, ResourceFC, ResourceUB, CFP, CFPV = multidict(ResourceData)
         
    ResourceProd, R= multidict(ResourceProdData)

    ArcResource, ArcResourceFC = multidict(ArcResourceData)
    ArcResourcePair=tuplelist([(i,j,r) for (i,j,r) in ArcResource])
    
    ArcResourceProd, Type, VariableCost, CycleTime, LT, UB = multidict(ArcResourceProdData)
    ArcResourceProdPair=tuplelist(ArcResourceProd)
    TransPair, AsmblPair, DisasmblPair =[],[],[]
    for (i,j,r,p) in Type:
        if Type[i,j,r,p]==1:
            AsmblPair.append( (i,j,r,p) )
        elif Type[i,j,r,p]==2:
            DisasmblPair.append( (i,j,r,p) )
        else:
            TransPair.append( (i,j,r,p) )
            
    NodeProd, VAL, Demand, DP_plus, DP_minus =multidict(NodeProdData)
    NodeProdPair=tuplelist(NodeProd)
    DemandNodeProdPair=[(i,p) for (i,p) in Demand if Demand[i,p]>0]
    SupplyNodeProdPair=[(i,p) for (i,p) in Demand if Demand[i,p]<0]
        
    EIC={} #echelon inventory cost
    for (i,j,r,p) in AsmblPair:
        EIC[i,j,r,p]=max(float(ratio)*(VAL[j,p]-sum(phi[q,p]*VAL[i,q] for q in Child[p]))/100.0,0)
    for (i,j,r,p) in DisasmblPair:
        EIC[i,j,r,p]=max(float(ratio)*(sum(phi[p,q]*VAL[j,q] for q in Parent[p])-VAL[i,p])/100.0,0)
    for (i,j,r,p) in TransPair:
        EIC[i,j,r,p]=max( float(ratio)*(VAL[j,p]-VAL[i,p])/100.0,0)
    #print i,j,p,r,EIC[i,j,r,p]
    
    model = Model()
    #variables
    z, y, w = {}, {}, {}
    for (i,j) in Arc:
        y[i,j] = model.addVar(vtype="B", name="y(%s,%s)"%(i,j))
    for (i,j,r) in ArcResourcePair:
        z[i,j,r] = model.addVar(vtype="B", name="z(%s,%s,%s)"%(i,j,r))
    v_minus, v_plus = {}, {}
    for (i,p) in Demand:
        if Demand[i,p] !=0:
            v_minus[i,p] = model.addVar(vtype="C", name= f"v_minus(i,p)")
            v_plus[i,p] = model.addVar(vtype="C", name= f"v_plus(i,p)")
        
    #prepare the nonlinear function
    a,b={},{}
    w,F,Z={},{},{}
    for (i,j,r,p) in ArcResourceProdPair:
        a[i,j,r,p]=[k for k in range(UB[i,j,r,p]+1)]
        b[i,j,r,p]=[ratio/100.0*VAL[j,p]*SSR*math.sqrt(VAR[p]*LT[i,j,r,p]*k) for k in range(UB[i,j,r,p]+1)]
        w[i,j,r,p],F[i,j,r,p],Z[i,j,r,p]=convex_comb_sos(model,a[i,j,r,p],b[i,j,r,p])
        w[i,j,r,p].ub=UB[i,j,r,p]

    TotalArcFC=model.addVar(vtype="C", name="Arc fixed cost")
    TotalArcResourceFC=model.addVar(vtype="C", name="Arc resource fixed cost")
    TotalVC=model.addVar(vtype="C", name="Variable cost")
    TotalCycleIC=model.addVar(vtype="C", name="Cycle inventory cost")
    TotalSafetyIC=model.addVar(vtype="C", name="Safety inventory cost")
    TotalPenalty=model.addVar(vtype="C", name="Violation penalty cost")
    
    model.update()

    # flow conservation constraints
    for i in Node:
        for p in Prod:        
            LHS=LinExpr()
            for j,ii,r,pp in TransPair+AsmblPair:
                if i==ii and p==pp:
                    LHS.addTerms(1,w[j,i,r,p])
            for j,ii,r,q in DisasmblPair:
                if i==ii and (p in Parent[q]):
                    LHS.addTerms(phi[q,p],w[j,i,r,q])
            for ii,k,r,pp in TransPair+DisasmblPair:
                if i==ii and p==pp:
                    LHS.addTerms(-1,w[i,k,r,p])
            for ii,k,r,q in AsmblPair:
                if i==ii and p in Child[q]:
                    LHS.addTerms(-phi[p,q],w[i,k,r,q])           
            if LHS.size()>0:
                if (i,p) in DemandNodeProdPair:
                    model.addConstr(LHS==Demand[i,p]+v_plus[i,p]-v_minus[i,p],"Flow(%s,%s)"%(i,p)) #demand constraint
                elif (i,p) in SupplyNodeProdPair:
                    model.addConstr(LHS==Demand[i,p]+v_plus[i,p]-v_minus[i,p],"Flow(%s,%s)"%(i,p)) #supply upper bound
                else:
                    model.addConstr(LHS==0.,"Flow(%s,%s)"%(i,p))           #flow conservation
                    
    #capacity constraint                         
    for i,j,r in ArcResourcePair:
        model.addConstr(quicksum(R[r,p]*w[i,j,r,p] for i,j,r,p in ArcResourceProdPair.select(i,j,r,"*"))<=ResourceUB[r]*z[i,j,r],
                        "Capacity(%s,%s,%s)"%(i,j,r))

    #connection between z and y
    for i,j,r in ArcResourcePair:
        model.addConstr(z[i,j,r]<=y[i,j],
                        "Connect(%s,%s,%s)"%(i,j,r))

    #carbon foot print constraint
    model.addConstr(quicksum(CFP[r]*Distance[i,j]*z[i,j,r] for i,j,r in ArcResourcePair) +
                    quicksum(CFPV[r]*Distance[i,j]*Weight[p]*w[i,j,r,p] for i,j,r,p in ArcResourceProdPair) <=CFPUB,
                        "Corbon Foot Print Upper Bound")
        
    #cost declaration
    model.addConstr(TotalArcFC == quicksum(ArcFC[i,j]*y[i,j] for i,j in Arc),"Total Arc Fixed Cost")
    model.addConstr(TotalArcResourceFC == quicksum(ArcResourceFC[i,j,r]*z[i,j,r] for i,j,r in ArcResourcePair),"Total Arc Resource Fixed Cost")
    model.addConstr(TotalVC == quicksum(VariableCost[i,j,r,p]*w[i,j,r,p] for i,j,r,p in ArcResourceProdPair),"Total Variable Cost")
    model.addConstr(TotalCycleIC == quicksum(EIC[i,j,r,p]*CycleTime[i,j,r,p]/2.0*w[i,j,r,p] for i,j,r,p in ArcResourceProdPair),"Total Cycle Inventory Cost")
    model.addConstr(TotalSafetyIC == quicksum(F[i,j,r,p] for i,j,r,p in ArcResourceProdPair),"Total Safety Inventory Cost")
    model.addConstr(TotalPenalty == quicksum( DP_minus[i,p]*v_minus[i,p] + DP_plus[i,p]*v_plus[i,p]
                                             for i,p in Demand if Demand[i,p] !=0),"Total Penalty Cost")
 
    
    #set objective function
    model.setObjective(TotalArcFC+TotalArcResourceFC+TotalVC+TotalCycleIC+TotalSafetyIC+TotalPenalty,
                       GRB.MINIMIZE)    
    model.update()
    model.__data=w,y,z,TotalArcFC,TotalArcResourceFC,TotalVC,TotalCycleIC,TotalSafetyIC,TotalPenalty
   
    model.write("tmp.lp")
    model.optimize()
   
    print("Opt.value=", model.ObjVal)

    print("Total Arc Fixed Cost",TotalArcFC.X)
    print("Total Arc Resource Fixed Cost",TotalArcResourceFC.X)
    print("Total Variable Cost",TotalVC.X)
    print("Total Cycle Inventory Cost",TotalCycleIC.X)
    print("Total Safety Inventory Cost",TotalSafetyIC.X)
 
    print()
    print("Arc") 
    for (i,j) in y:
        if y[i,j].X >0:
            print("y(%s,%s)"%(i,j)," Fixed Cost = ", ArcFC[i,j])
    print()
    print("Arc Resource")
    for (i,j,r) in z:
        if z[i,j,r].X >0:
            print("z(%s,%s,%s)"%(i,j,r)," = ",z[i,j,r].X, " Fixed Cost = ",ArcResourceFC[i,j,r]*z[i,j,r].X)

    print()
    print("Arc Resource Prod")
    for (i,j,r,p) in w:
        if w[i,j,r,p].X >0:
            print( "w(%s,%s,%s,%s)"%(i,j,r,p)," = ", w[i,j,r,p].X, " Var. Cost =", VariableCost[i,j,r,p]*w[i,j,r,p].X,
                   " Cycle IC =", EIC[i,j,r,p]*CycleTime[i,j,r,p]/2.0*w[i,j,r,p].X,
                   " Safety IC =", ratio/100.0*VAL[j,p]*SSR*math.sqrt(VAR[p]*LT[i,j,r,p]*w[i,j,r,p].X)
                 )

    print()
    print("Corbon Foot Print Usage", sum(CFP[r]*Distance[i,j]*z[i,j,r].X for i,j,r in z))
    
    print()
    print("Total Violation Penalty", TotalPenalty.X)
    for (i,p) in v_plus:
        if v_plus[i,p].X > 0:
            print(f"v_plus({i},{p})=", v_plus[i,p].X)
            
    for (i,p) in v_minus:
        if v_minus[i,p].X > 0:
            print(f"v_minus({i},{p})=", v_minus[i,p].X)
    return model
    

# %% ../nbs/05lnd.ipynb 222
def co2(capacity, rate = 0.5, diesel=False):
    """
    引数： 
       - capacity：積載重量（kg)
       - rate: 積載率 (0<rate<=1.0)
       - diesel: ディーゼル車の場合 True， ガソリン車の場合 False
    返値：
       - fuel: トンキロあたりの燃料使用量（リットル）
       - co2: CO2排出量(g)
    """
    if diesel:
        fuel = math.e**(2.67-0.927*math.log(rate) - 0.648*math.log(capacity))
    else:
        fuel = math.e**(2.71-0.812*math.log(rate) - 0.654*math.log(capacity))
    co2 = fuel*2.322*1000
    return fuel, co2
