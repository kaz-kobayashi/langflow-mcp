"""Supply Chain Modeling Language Class"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/04scml2.ipynb.

# %% auto 0
__all__ = ['GUROBI', 'folder', 'name', 'parent', 'children', 'Entity', 'to_pickle', 'setParent', 'addChildren', 'Period',
           'Resource', 'Product', 'Mode', 'Activity', 'Node', 'Arc', 'Data', 'Constraint', 'Model', 'optimize',
           'visualize_network', 'visualize', 'tabu_search_for_SSA']

# %% ../nbs/04scml2.ipynb 2
import sys
sys.path.append('..')
from .core import SCMGraph

from fastapi import FastAPI
from fastapi.encoders import jsonable_encoder
from fastapi.responses import JSONResponse
from typing import List, Optional, Union, Tuple, Dict, Set, Any, DefaultDict
from pydantic import BaseModel, Field, ValidationError, validator, confloat, conint, constr, Json
from pydantic.tools import parse_obj_as
from datetime import datetime, date, time

import networkx as nx
import copy
import pickle
from collections import defaultdict
import pandas as pd
import numpy as np
import scipy

import graphviz

#ソルバー GurobipyのときにはTrueにする（Gurobiは model.updateが必要なため）
GUROBI = False

if GUROBI==False:
    #import mindoptpy as gp
    #gp.GRB = gp.MDO
    import mypulp as gp 
    #import pyscipopt as gp

folder ="./data/"
#from IPython.display import Image, YouTubeVideo
# import re 
# import requests
# from collections import OrderedDict, defaultdict
# import subprocess
# import platform
# import json
# import numpy as np
# import plotly

#import ast  #文字列からオブジェクトを起こすモジュール

# from openpyxl import Workbook, load_workbook
# from openpyxl.worksheet.table import Table, TableStyleInfo
# from openpyxl.chart import ScatterChart, Reference, Series
# from openpyxl.worksheet.datavalidation import DataValidation
# from openpyxl.formatting.rule import ColorScaleRule, CellIsRule, FormulaRule
# from openpyxl.styles import Color, PatternFill, Font, Border, Alignment
# from openpyxl.styles.borders import Border, Side
# from openpyxl.utils.dataframe import dataframe_to_rows
# from openpyxl.comments import Comment

# %% ../nbs/04scml2.ipynb 5
class Entity(BaseModel):
    """A base class for representing hierarchical entities in a supply chain model.
    
    This class implements a tree-like structure where each entity can have a parent
    and multiple children. Entities are identified by either integer or string names.

    Attributes
    ----------
    name : Union[int, str]
        The unique identifier for the entity
    parent : Optional[Union[int, str]]
        The name of the parent entity, if any
    children : Optional[List[Union[int, str]]]
        List of names of child entities, if any
    """
    name: Union[int,str] = Field(description="名称")
    parent: Optional[Union[int,str]] = Field(description="親の名称", default=None)
    children: Optional[List[Union[int,str]]] = Field(description="子の名称のリスト", default=None)

    def to_pickle(self, file_name = None):
        """Save the entity object to a pickle file.

        Parameters
        ----------
        file_name : str, optional
            Name of the file to save to. If None, uses the entity's name
        """
        if file_name is None: file_name = str(self.name)
        with open(f"{file_name}.pkl","wb") as f:
            pickle.dump(self, f)
            
    def setParent(self, parent: Union[int,str]) -> None:
        """Set the parent of this entity and update the parent's children list.

        Parameters
        ----------
        parent : Union[int, str]
            The parent entity to set
        """
        self.parent = parent.name
        if parent.children is None:
            parent.children = []
        parent.children.append(self.name)

    def addChildren(self, children: List[Union[int,str]]) -> None:
        """Add multiple children to this entity and update their parent references.

        Parameters
        ----------
        children : List[Union[int, str]]
            List of child entities to add
        """
        if self.children is None:
            self.children = []
            
        for child in children[:]:
            self.children.append(child.name)
            child.parent = self.name
name: Union[int,str]                      = Field( description="名称")
parent: Optional[Union[int,str]]          = Field( description="親の名称", default=None)
children: Optional[List[Union[int,str]]]  = Field( description="子の名称のリスト", default=None )

def to_pickle(self, file_name = None):
    if file_name is None: file_name = str(self.name)
    with open(f"{file_name}.pkl","wb") as f:
        pickle.dump(self, f)
        
def setParent(self, parent:Union[int,str]) -> None:
    self.parent = parent.name
    if parent.children is None:
        parent.children = []
    parent.children.append(self.name)

def addChildren(self, children:List[Union[int,str]]) -> None:
    if self.children is None:
        self.children = []
        
    for child in children[:]:
        self.children.append(child.name)
        child.parent = self.name

# %% ../nbs/04scml2.ipynb 9
class Period(Entity):
    start: Optional[ Union[int,float,datetime,date,time] ]  = Field( description="開始時刻", dafault = None)
    #end: Optional[ Union[datetime,date,time] ]      = Field( description="終了時刻", default = None)

# %% ../nbs/04scml2.ipynb 13
class Resource(Entity):
    rtype: Optional[str]                         = Field( description="資源のタイプ", default = None)
    capacity: Optional[Union[int,float,Dict]]    = Field( description="容量", default = None)
    fixed_cost: Optional[Union[int,float]]        = Field( description="資源固定費用", default = 0)
    modes: Optional[ Dict[str,Tuple] ]           = Field( description="資源を使用するモード名をキーとし，固定量と変動量のタプルを入れた辞書", 
                                                         default=None )
        
    def addCapacity(self, period:Period, amount:Union[int,float]) ->None:
        """
        Adds a capacity to the resource.
        """
        if self.capacity is None:
            self.capacity = {}
        # data = copy.deepcopy(self.capacity)
        # data.update({period.name: amount})
        # self.capacity = data
        self.capacity[period.name] = amount

# %% ../nbs/04scml2.ipynb 17
class Product(Entity):
    weight: Optional[float] = Field(description="重量", default=0. )
    volume: Optional[float] = Field(description="容量", default=0. )
    value:  Optional[float] = Field(description="価値（点に依存しない場合）", default=0. )
    #モデルクラスに移動
    #value: Optional[Dict[str, float]] = Field(description="点上での製品の価値（点の名称をキー，値を価値とした辞書）")
    #demand, supplyも同様に定義
    # def addValue(self, node_name:str, value: float) -> None:
    #     if self.value is None:
    #         self.value = {}
    #     self.value[node_name] = value
        
    #在庫も地点ごとに入力?
    # safety_inventory: Optional[float] = Field(description="安全在庫量（最終期の目標在庫量）")
    # initial_inventory: Optional[float] = Field(description="初期在庫量")
    # target_inventory: Optional[float] = Field(description="目標在庫量")
    class Config:
        json_schema_extra = {
            "example": {
                "name": "いちご大福",
                "weight": 0.2,
                "value": 100,
            }
        }

# %% ../nbs/04scml2.ipynb 22
class Mode(Entity):
    components: Optional[Dict[str,float]]           = Field( description="部品名称をキー，必要数量を値とした辞書", default=None )
    byproducts: Optional[Dict[str,float]]           = Field( description="副生成物名称をキー，生成数量を値とした辞書", default=None )
 
    fixed_requirement: Optional[Dict[str,float]]    = Field( description="資源名をキー，固定量とした辞書", default=None )
    variable_requirement: Optional[Dict[str,float]] = Field( description="資源名をキー，変動量とした辞書", default=None )

    fixed_cost: Optional[float]                     = Field( description="固定費用", default=0. )
    variable_cost: Optional[float]                  = Field( description="変動費用", default=0. )
    piecewise_x: Optional[List[float]]              = Field( description="区分的線形費用関数のx座標のリスト", default=None )
    piecewise_y: Optional[List[float]]              = Field( description="区分的線形費用関数のy座標のリスト", default=None )

    upper_bound: Optional[float]                    = Field( description="活動量上限", default= None)
    activities: Optional[set]                       = Field( description="モードを含む活動の集合", default =None)

    #シフト最適化用
    periods: Optional[Dict[Union[int,str], Period]] = Field( description="期名称をキー，期インスタンスとした辞書", default=None )
    
    # requirement: Optional[Dict[Tuple,Dict]]
    duration:  Optional[ Union[int,float] ]          = Field( description="作業時間", default = None)
    service_time:  Optional[ Union[int,float] ]      = Field( description="サービス（保証リード）時間", default = None)
    service_level: Optional[float]                   = Field( description="サービス水準", default = 0.9)
    # breakable: Optional[Dict]                      = Field( description="分割指定を表す辞書" )
    # parallel:  Optional[Dict]                      = Field( description="並列実行指定を表す辞書" )
    # state:     Optional[Dict]                      = Field( description="状態推移を表す辞書" )
    # def addResource(self, resource:Resource, requirement:Union[float,int,Dict], rtype:Optional[str]=None) -> None:
    #     if self.requirement is None:
    #         self.requirement = {}
    #     if rtype is None:
    #         self.requirement[ (resource.name,None)] = requirement
    #     elif rtype in ["break", "max"]:
    #         self.requirement[ (resource.name,rtype)] = requirement
    #     else:
    #         raise TypeError("rtype must be None, break or max")
    def addResource(self, resource:Resource, fixed:float=0., variable:float=0.) -> None:
        if self.fixed_requirement is None:
            self.fixed_requirement = {}
        if self.variable_requirement  is None:
            self.variable_requirement = {}
        self.fixed_requirement[resource.name] = fixed
        self.variable_requirement[resource.name] = variable
        if resource.modes is None:
            resource.modes = {}
        resource.modes[self.name] =(fixed,variable)

    def addCost(self, fixed:float=0., variable:float=0., 
                piecewise_x: List[float] =None, piecewise_y: List[float] = None) -> None:
        self.fixed_cost = fixed
        self.variable_cost = variable
        self.piecewise_x = piecewise_x
        self.piecewise_y = piecewise_y
    
    def addComponent(self, component:Product, quantity: float = 1.) -> None:
        if self.components is None:
            self.components = {}
        self.components[component.name] = quantity

    def addByproduct(self, byproduct:Product, quantity: float =1.) -> None:
        if self.byproducts is None:
            self.byproducts = {}
        self.byproducts[byproduct.name] = quantity

    def addPeriod(self, period:Period) -> None:
        if self.periods is None:
            self.periods = {}
        self.periods[period.name] = period

# %% ../nbs/04scml2.ipynb 26
class Activity(Entity):
    atype: Optional[str]                           = Field( description="活動（作業）のタイプ（'make', 'setup', 'inventory', 'transport'など ",
                                                          default = "make")
    mtype: Optional[str]                           = Field( description="モードのタイプ（'select', 'proportional', 'all' など ",
                                                          default = "select")
    product: Product                               = Field( description="製品インスタンス", default=None )
    modes: Optional[Dict[str,Mode]]                = Field( description="モード名をキー，モードインスタンスを値とした辞書", default=None )

    nodes: Optional[Set]                           = Field( description="活動を含む点の集合", default=None )
    arcs: Optional[Set]                            = Field( description="活動を含む枝の集合", default=None )
    
    #OptSeq用
    # duedate: Optional[Union[str,int]]              = Field( description="納期（整数か'Infinity')", default="Infinity" ) #or Period or DateTime
    # backward: Optional[bool]                       = Field( description="後ろ詰めのときTrue", default = False )
    # weight: Optional[int]                          = Field( description="納期遅れペナルティ（重み）", default = 1 )
    # autoselect: Optional[bool]                     = Field( description="モードを自動的に選択するときTrue", default=False )

    def addMode(self, mode:Mode) -> None:
        if self.modes is None:
            self.modes = {}
        self.modes[mode.name] = mode  

        if mode.activities is None:
            mode.activities = set([])
        mode.activities.add(self.name)

    def addModes(self, modes:List[Mode]) -> None:
        for m in modes:
            self.addMode(m)

# %% ../nbs/04scml2.ipynb 30
class Node(Entity):
    location: Union[ None, Json[Tuple[float,float]], 
                 Tuple[float,float] ]           = Field( description="経度・緯度のタプル", default =None )
    location_index: Union[ None, int]           = Field( description="Matricesクラスで定義された行列のインデックス", default =None )
    activities: Optional[Dict[str, Activity]]   = Field( description="点で定義された活動の辞書（名前をキーとし，活動オブジェクトを値とする）",
                                                       default = None)

    def addActivity(self, activity:Activity) -> None:
        if self.activities is None:
            self.activities = {}
        self.activities[activity.name] = activity
        if activity.nodes is None:
            activity.nodes = set([])
        activity.nodes.add(self.name)

    def addActivities(self, activities:List[Activity]) -> None:
        for a in activities:
            self.addActivity(a)

# %% ../nbs/04scml2.ipynb 34
class Arc(Entity):
    source: Node                                = Field( description="始点" )
    sink: Node                                  = Field( description="始点" )
    distance: Optional[Union[int,float]]        = Field( description="距離", default =None )
    time: Optional[Union[int,float]]            = Field( description="時間", default =None )

    activities: Optional[Dict[str, Activity]]   = Field( description="枝で定義された活動の辞書（名前をキーとし，活動オブジェクトを値とする）",
                                                       default=None)

    def addActivity(self, activity:Activity) -> None:
            if self.activities is None:
                self.activities = {}
            self.activities[activity.name] = activity
            if activity.arcs is None:
                activity.arcs = set([])
            activity.arcs.add( (self.source.name, self.sink.name) )

    def addActivities(self, activities:List[Activity]) -> None:
        for a in activities:
            self.addActivity(a)

# %% ../nbs/04scml2.ipynb 38
class Data(BaseModel):
    dtype:str                                   = Field(description="データのタイプ（demand,supply,value,inventoryから選択)", default="demand")
    amount: Optional[ Union[int,float] ]        = Field(description="データの値", default=0)
    std: Optional[float]                        = Field(description="標準偏差", default=0.)
    over_penalty: Optional[ Union[int,float] ]  = Field(description="超過ペナルティ", default=999999)
    under_penalty: Optional[ Union[int,float] ] = Field(description="不足ペナルティ", default=999999)

# %% ../nbs/04scml2.ipynb 44
class Constraint(Entity):
    rhs: Optional[ Union[int,float] ]         = Field( description="右辺定数", default = 0 )
    direction: Optional[str]                  = Field( description="制約の方向", default = "<=" )
    #terms: Optional[List]                     = Field( description="制約の左辺項のリスト", default = None )
    terms: Optional[List[Tuple[ Union[int,float], Activity, Mode] ]] \
                                              = Field( description="制約の左辺項のリスト", default = None )
    weight: Optional[ Union[int,float,str] ]  = Field( description="制約の逸脱ペナルティ", default = "inf" )

    def addTerms(self, coeffs=None, vars=None, values=None):
        """
        Add new terms into left-hand-side of nonrenewable resource constraint.

            - Arguments:
                - coeffs: Coefficients for new terms; either a list of coefficients or a single coefficient.
                The three arguments must have the same size.
                - vars: Activity objects for new terms; either a list of activity objects or a single activity object.
                The three arguments must have the same size.
                - values: Mode objects for new terms; either a list of mode objects or a single mode object.
                The three arguments must have the same size.

            - Example usage:

            >>> budget.addTerms(1,act,express)

            adds one unit of nonrenewable resource (budget) if activity "act" is executed in mode "express."

        """
        if self.terms is None:
            self.terms =[]
        if type(coeffs) != type([]):
            self.terms.append((coeffs, vars, values))
        elif type(coeffs) != type([]) or type(vars) != type([]) or type(values) != type([]):
            print("coeffs, vars, values must be lists")
            raise TypeError("coeffs, vars, values must be lists")
        elif len(coeffs) != len(vars) or len(coeffs) != len(values) or len(values) != len(vars):
            print("length of coeffs, vars, values must be identical")
            raise TypeError("length of coeffs, vars, values must be identical")
        else:
            for i in range(len(coeffs)):
                self.terms.append((coeffs[i], vars[i], values[i]))

    def setRhs(self, rhs=0):
        """
        Sets the right-hand-side of linear constraint.

            - Argument:
                - rhs: Right-hand-side of linear constraint.

            - Example usage:

            >>> L.setRhs(10)

        """
        self.rhs = rhs

    def setDirection(self, direction="<="):
        if direction in ["<=", ">=", "="]:
            self.direction = direction
        else:
            print("direction setting error; direction should be one of '<=' or '>=' or '='")
            raise NameError("direction setting error; direction should be one of '<=' or '>=' or '='")

    def printConstraint(self):
        """
            Returns the information of the linear constraint.

            The constraint is expanded and is shown in a readable format.
        """

        f = [f"Constraint {self.name}: weight={self.weight}: "]
        if self.direction == ">=" or self.direction == ">":
            for (coeff, var, value) in self.terms:
                f.append(
                    "{0}({1},{2}) ".format(-coeff, var.name, value.name))
            f.append("<={0} \n".format(-self.rhs))
        elif self.direction == "==" or self.direction == "=":
            for (coeff, var, value) in self.terms:
                f.append("{0}({1},{2}) ".format(
                    coeff, var.name, value.name))
            f.append("<={0} \n".format(self.rhs))
            f.append("nonrenewable weight {0} ".format(self.weight))
            for (coeff, var, value) in self.terms:
                f.append(
                    "{0}({1},{2}) ".format(-coeff, var.name, value.name))
            f.append("<={0} \n".format(-self.rhs))
        else:
            for (coeff, var, value) in self.terms:
                f.append("{0}({1},{2}) ".format(
                    coeff, var.name, value.name))
            f.append("<={0} \n".format(self.rhs))

        return "".join(f)

# %% ../nbs/04scml2.ipynb 48
class Model(Entity):

    activities: Optional[Dict[str, Activity]]    = Field( description="活動の辞書（名前をキーとし，活動オブジェクトを値とする）", default=None )
    modes: Optional[Dict[str, Mode]]             = Field( description="モードの辞書（名前をキーとし，モードオブジェクトを値とする）", default=None )
    resources: Optional[Dict[str, Resource]]     = Field( description="資源の辞書（名前をキーとし，資源オブジェクトを値とする）" , default=None)
    products: Optional[Dict[str, Product]]       = Field( description="製品の辞書（名前をキーとし，製品オブジェクトを値とする）" , default=None)
    periods: Optional[Dict[str, Period]]         = Field( description="期の辞書（名前をキーとし，期オブジェクトを値とする）", default=None )
    nodes: Optional[Dict[str,Node]]              = Field( description="点の辞書（名前をキーとし，点オブジェクトを値とする）", default=None )
    arcs: Optional[Dict[str,Arc]]                = Field( description="枝の辞書（名前をキーとし，枝オブジェクトを値とする）", default=None )
    constraints: Optional[Dict[str,Constraint]]  = Field( description="制約の辞書（名前をキーとし，制約オブジェクトを値とする）", default=None )

    data: Optional[Dict]                         = Field( description="数値データを保管する辞書（データタイプ，製品名，点名，期名をキーとし，データインスタンスを値とする）", default=None )
    # demands: Optional[Dict]                      = Field( description="需要の辞書（製品名，点名，期名をキーとし，需要量を値とする）", default=None )
    # values: Optional[Dict]                       = Field( description="価値の辞書（製品名，点名，期名をキーとし，価値を値とする）", default=None )
    # inventories: Optional[Dict]                  = Field( description="在庫の辞書（製品名，点名，期名をキーとし，在庫オブジェクトを値とする））", default=None )
    interest_rate: Optional[float]               = Field( description="投資利子率（在庫費用の計算で用いる）", default = None )

    period_list: Optional[List[Tuple]]           = Field( description="期のリスト（開始時刻と期の名前のタプルを要素とする）", default=None )
    period_index: Optional[Dict[str,int]]      = Field( description="期の名前をキー，期インデックスを値とした辞書", default=None )

    def addResource(self, name:str, 
                    capacity:Optional[Union[int,Dict]] = None, 
                    fixed_cost:Optional[Union[int,float]] =0)->Resource:
        if self.resources is None:
            self.resources = {}
        self.resources[name] = Resource(name=name, capacity=capacity, fixed_cost=fixed_cost) 
        return self.resources[name] 

    def addActivity(self, name:str, atype:Optional[str] ="make", product:Product=None)->Activity:
        if self.activities is None:
            self.activities = {}
        self.activities[name] = Activity(name=name, atype=atype, product=product)
        #関連するモードをモデルに追加する？ addModeで追加すると二度手間になる！
        return self.activities[name]

    #必ず活動に付随させるので不必要？
    def addMode(self, name:str, components: Optional[Dict[str,float]] =None, byproducts: Optional[Dict[str,float]]=None,
                fixed_requirement: Optional[Dict[str,float]]=None, variable_requirement: Optional[Dict[str,float]]=None,
                fixed_cost: Optional[float]=None, variable_cost: Optional[float]=None)->Mode:
        if self.modes is None:
            self.modes = {}
        self.modes[name] = Mode(name=name, components=components, 
                                byproduct=byproducts, fixed_requirement=fixed_requirement,
                                variable_requirement=variable_requirement, fixed_cost=fixed_cost, variable_cost=variable_cost)
        return self.modes[name]

    def addNode(self, name:str, location:Union[ None, Json[Tuple[float,float]], Tuple[float,float] ]=None ) -> Node:
        if self.nodes is None:
            self.nodes = {}
        self.nodes[name] = Node(name=name,location=location)
        return self.nodes[name]
        
    def addArc(self, name:str, source:Node, sink:Node) -> Arc:
        if self.arcs is None:
            self.arcs = {}
        if self.nodes is None:
            self.nodes = {}
        self.arcs[source.name, sink.name] = Arc(name=name, source=source, sink=sink)
        if source.name not in self.nodes: self.nodes[source.name] = source
        if sink.name not in self.nodes: self.nodes[sink.name] = sink
        return self.arcs[source.name, sink.name]

    def addPeriod(self, name:str, start:Optional[Union[int,float,datetime,date,time]]=None):
        if self.periods is None:
            self.periods = {}
        self.periods[name] = Period(name=name, start=start)
        return self.periods[name] 

    def addProduct(self, name:str, volume:float=None, weight:float=None, value:float=None):
        if self.products is None:
            self.products = {}
        self.products[name] = Product(name=name, volume=volume, weight=weight, value=value)
        return self.products[name]

    def addConstraint(self, name:str, rhs:Union[int,float] =0, direction:str ="<=", weight: Union[int,float,str] ="inf"):
        if self.constraints is None:
            self.constraints = {}
        self.constraints[name] = Constraint(name=name, rhs=rhs, direction=direction, weight=weight)
        return self.constraints[name]
    
    def addData(self, dtype:str, product:Product, node:Optional[Node]=None, period:Optional[Period]=None, amount:Union[int,float]=0,
                std:Union[int,float]=0, under_penalty:Union[int,float]=999999, over_penalty:Union[int,float]=999999)->None:
        if self.data is None:
            self.data = {}
        if node is None:
            node_name = "*" 
        else:
            node_name = node.name
        if period is None:
            period_name = "*" 
        else:
            period_name =period.name
        self.data[dtype, product.name, node_name, period_name] = Data(dtype=dtype, amount=amount, 
                                                                      std=std, under_penalty=under_penalty, over_penalty=over_penalty)
    def update(self):
        if self.periods is not None:
            self.period_list =[ (t.start,name) for (name,t) in self.periods.items()]
            self.period_list.sort()
            self.period_index = {}
            for i, (t,name) in enumerate(self.period_list):
                self.period_index[name]= i
        else:
            self.period_list = [(datetime.now(),"period(0)")]
        #return self.period_list
        
    # def addDemand(self, product:Product, node:Optional[Node]=None, period:Optional[Period]=None, amount:Union[int,float]=0,
    #                     std:Union[int,float]=0, under_penalty:Union[int,float]=999999, over_penalty:Union[int,float]=999999)->None:
    #     if self.demands is None:
    #         self.demands = {}
    #     if node is None:
    #         node_name = "*" 
    #     else:
    #         node_name = node.name
    #     if period is None:
    #         period_name = "*" 
    #     else:
    #         period_name =period.name
    #     self.demands[product.name, node_name, period_name] = amount

    # def addValue(self, product:Product, node:Optional[Node]=None, period:Optional[Period]=None, value:Union[int,float]=0)->None:
    #     if self.values is None:
    #         self.values = {}
    #     if node is None:
    #         node_name = "*" 
    #     else:
    #         node_name = node.name
    #     if period is None:
    #         period_name = "*" 
    #     else:
    #         period_name =period.name
    #     self.values[product.name, node_name, period_name] = value

    # def addInventory(self, product:Product, node:Optional[Node]=None, period:Optional[Period]=None, 
    #                  amount:Union[int,float] = 0
    #                 )->None:
    #     if self.inventories is None:
    #         self.inventories = {}
    #     if node is None:
    #         node_name = "*" 
    #     else:
    #         node_name = node.name
    #     if period is None:
    #         period_name = "*" 
    #     else:
    #         period_name =period.name
    #     self.inventories[product.name, node_name, period_name] = amount

    def __str__(self):
        """
         SCMLフォーマットを定義して出力
        """
        return ""
        

# %% ../nbs/04scml2.ipynb 54
#SCMLモデルを与えると最適化を行う関数（本来ならばモデルのメソッド）
#引数： model, start_period_name, end_period_name
def optimize(model: Model, start_period_name:str =None, end_period_name:str = None) -> gp.Model:
    if model.periods is None or start_period_name is None or end_period_name is None:
        start = 0
        end = 1
    else:
        start = model.period_index[start_period_name]
        end = model.period_index[end_period_name]+1
    assert start < end 
    print("計画期間　=", start,end)
    
    gp_model = gp.Model()
    #変数を定義            
    x, y, Y = {}, {}, {}
    I ={}
    
    vc, fc ={}, {} #変動費用と固定費用
    rfc = {} #資源の固定費用
    ub ={} #活動量の上限
    demand_point, supply_point = {}, {}
    value, inventory = {},{}
    over_penalty, under_penalty = {}, {}
    total_demand = defaultdict(float) #製品ごとの需要量の合計
    total_supply = defaultdict(float) #製品ごとの供給量の合計
    
    for (dtype,p,i,t) in model.data:
        if t=="*": #すべての計画期間にデータをコピーする
            for t0 in range(start,end):
                if dtype=="demand": 
                    demand_point[p,i,t0] = model.data[dtype,p,i,t].amount
                    total_demand[p] += demand_point[p,i,t0]
                elif dtype=="supply":
                    supply_point[p,i,t0] = model.data[dtype,p,i,t].amount
                    total_supply[p] += supply_point[p,i,t0]
                elif dtype =="value":
                    value[p,i,t0] = model.data[dtype,p,i,t].amount
                elif dtype =="inventory":
                    inventory[p,i,t0] = model.data[dtype,p,i,t].amount
                over_penalty[p,i,t0] = model.data[dtype,p,i,t].over_penalty
                under_penalty[p,i,t0] = model.data[dtype,p,i,t].under_penalty
        else:
            period_idx = model.period_index[t]
            if dtype=="demand": 
                demand_point[p,i,t] = model.data[dtype,p,i,t].amount
                total_demand[p] += demand_point[p,i,t]
            elif dtype=="supply":
                supply_point[p,i,t] = model.data[dtype,p,i,t].amount
                total_supply[p] += supply_point[p,i,t]
            elif dtype =="value":
                value[p,i,t] = model.data[dtype,p,i,t].amount
            elif dtype =="inventory":
                inventory[p,i,t] = model.data[dtype,p,i,t].amount
            if period_idx>=start and period_idx<end:    
                over_penalty[p,i,t] = model.data[dtype,p,i,t].over_penalty
                under_penalty[p,i,t] = model.data[dtype,p,i,t].under_penalty
    #フロー保存制約の左辺，右辺の変数と係数をのタプルのリストを保管した辞書
    lhs = defaultdict(list)
    rhs = defaultdict(list)
    #資源制約の固定使用量と変動使用量の係数と変数のタプルのリストを保管した辞書
    fixed_req = defaultdict(list)
    variable_req = defaultdict(list)
    
    #点上での活動変数
    for i, node in model.nodes.items():
        if node.activities is not None and len(node.activities)>0:
            for aname, act in node.activities.items():
                if act.atype == "make":
                    p = act.product.name
                    for t in range(start,end):
                        for m, mode in act.modes.items():  
                            if mode.upper_bound is None: 
                                ub[i,m,p] = max(total_demand[p],total_supply[p])
                            else:
                                ub[i,m,p] = float(mode.upper_bound)
                        
                            x[i,m,p,t] = gp_model.addVar(name=f"x({i},{m},{p},{t})", vtype="C")
                            y[i,m,p,t] = gp_model.addVar(name=f"y({i},{m},{p},{t})", vtype="B")
                            
                            if mode.components is not None:
                                for q, quantity in mode.components.items(): #部品　q は i で消費
                                    rhs[i,q,t].append( (quantity,x[i,m,p,t]) )  
                            if mode.byproducts is not None:
                                for q, quantity in mode.byproducts.items(): #副生成物 q は i に発生
                                    lhs[j,q,t].append( (quantity,x[i,m,p,t]) )
                            lhs[i,p,t].append( (1.,x[i,m,p,t]) )    #付随する製品 p は i に発生
                            vc[i,m,p] = mode.variable_cost
                            #if mode.fixed_cost is not None and mode.fixed_cost > 0.:
                            fc[i,m,p] = mode.fixed_cost
                            if mode.fixed_requirement is not None:
                                for r, val in mode.fixed_requirement.items():
                                    fixed_req[r].append((val,y[i,m,p,t])) 
                            if mode.variable_requirement is not None:
                                for r, val in mode.variable_requirement.items():
                                    variable_req[r].append((val,x[i,m,p,t])) 
    #枝上での活動変数
    for (i,j), arc in model.arcs.items():
        if arc.activities is not None and len(arc.activities) >0:
            for a, act in arc.activities.items():
                p = act.product.name
                for m, mode in act.modes.items():
                    if mode.upper_bound is None: #中間製品（需要も供給もなし）の場合には必ずモードのupper_boundを指定する必要がある
                        ub[i,j,m,p] = max(total_demand[p],total_supply[p])
                    else:
                        ub[i,j,m,p] = float(mode.upper_bound)
                    fc[i,j,m,p] = mode.fixed_cost
                    vc[i,j,m,p] = mode.variable_cost
    
                    #変数の定義
                    for t in range(start,end):
                        x[i,j,m,p,t] = gp_model.addVar(name=f"x({i},{j},{m},{p},{t})")
                        y[i,j,m,p,t] = gp_model.addVar(name=f"y({i},{j},{m},{p},{t})", vtype="B")
                        if act.atype == "transport":
                            rhs[i,p,t].append( (1.,x[i,j,m,p,t]) )
                            lhs[j,p,t].append( (1.,x[i,j,m,p,t]) )
                        elif act.atype == "make":
                            if mode.components is not None:
                                for q, quantity in mode.components.items(): #部品　q はsource i で消費
                                    rhs[i,q,t].append( (quantity,x[i,j,m,p,t]) ) 
                            if mode.byproducts is not None:
                                for q, quantity in mode.byproducts.items(): #副生成物 q はsink j に発生
                                    lhs[j,q,t].append( (quantity,x[i,j,m,p,t]) )
                            lhs[j,p,t].append( (1.,x[i,j,m,p,t]) )  #付随する製品 p はsink j に発生
                        #if mode.fixed_cost > 0.:
                        fc[i,j,m,p,t] = mode.fixed_cost
    
                    #資源制約の変数と係数の保管
                    if mode.fixed_requirement is not None:
                        for r, val in mode.fixed_requirement.items():
                            fixed_req[r].append((val,y[i,j,m,p,t])) 
                    if mode.variable_requirement is not None:
                        for r, val in mode.variable_requirement.items():
                            variable_req[r].append((val,x[i,j,m,p,t])) 
    
    #在庫変数
    for i, node in model.nodes.items():
        if node.activities is None:
            continue
        for a, act in node.activities.items():
            if act.atype=="inventory":
                p = act.product.name
                for t in range(start,end):
                    I[i,p,t] = gp_model.addVar(name=f"I({i},{p},{t})")
    #固定在庫量
    for (p,i,t), amount in inventory.items():
        I[i,p,model.period_index[t]] = amount
    
    #需要地点と供給地点に余裕変数と超過変数を追加する
    slack, surplus = {}, {}
    for (p,i,t) in demand_point:
        slack[i,p,t] = gp_model.addVar(name=f"slack({i},{p},{t})")
        surplus[i,p,t] = gp_model.addVar(name=f"surplus({i},{p},{t})")
    for (p,i,t) in supply_point:
        slack[i,p,t] = gp_model.addVar(name=f"slack({i},{p},{t})")
        surplus[i,p,t] = gp_model.addVar(name=f"surplus({i},{p},{t})")

    #資源を使用するか否かを表す0-1変数（超過，不足変数は必要？）
    if model.resources is not None:
        for r, res in model.resources.items():
            for t in range(start,end):
                rfc[r, t] = res.fixed_cost
                Y[r,t] = gp_model.addVar(name=f"Y({r},{t})", vtype="B")

    if GUROBI: gp_model.update()
    
    #フロー整合
    for t in range(start,end):
        for i, node in model.nodes.items():
            for p, product in model.products.items():
                if len(lhs[i,p,t])==0 and len(rhs[i,p,t])==0:
                    continue
                if (p,i,t) in demand_point:
                    gp_model.addConstr( gp.quicksum( coeff*variable for coeff,variable in lhs[i,p,t] ) 
                                        - gp.quicksum( coeff*variable for coeff,variable in rhs[i,p,t]) 
                                        -slack[i,p,t]+surplus[i,p,t] == demand_point[p,i,t],
                                        name = f"flow_cons({i},{p},{t})"
                                        )
                elif (p,i,t) in supply_point:
                    gp_model.addConstr( - gp.quicksum( coeff*variable for coeff,variable in lhs[i,p,t] ) 
                                        + gp.quicksum( coeff*variable for coeff,variable in rhs[i,p,t]) 
                                        +slack[i,p,t]-surplus[i,p,t] == supply_point[p,i,t],
                                           name = f"flow_cons({i},{p},{t})"
                                          )
                else:
                    gp_model.addConstr( gp.quicksum( coeff*variable for coeff,variable in lhs[i,p,t] ) 
                                        - gp.quicksum( coeff*variable for coeff,variable in rhs[i,p,t]) 
                                            + (I[i,p,t-1]  if (i,p,t-1) in I else 0. ) 
                                            - (I[i,p,t] if (i,p,t) in I else 0.) == 0,
                                           name = f"flow_cons({i},{p},{t})"
                                          )
        #資源量上限
        if model.resources is not None:
            for r, res in model.resources.items():
                gp_model.addConstr( gp.quicksum( val*variable for val,variable in variable_req[r] ) +
                                    gp.quicksum( val*variable for val,variable in fixed_req[r] ) 
                                    <= res.capacity*Y[r,t], name=f"capacity({r},{t})")
        
    #繋ぎ
    for idx in y:
        gp_model.addConstr( x[idx] <= ub[idx[:-1]]*y[idx], name=f"connection({idx})")
            
    #目的関数
    gp_model.setObjective(gp.quicksum(vc[idx[:-1]]*x[idx] for idx in x) + 
                          gp.quicksum(fc[idx[:-1]]*y[idx] for idx in y) +
                          gp.quicksum(rfc[idx]*Y[idx] for idx in Y) + 
                          gp.quicksum(under_penalty[p,i,t]*slack[i,p,t] + over_penalty[p,i,t]*surplus[i,p,t] for (i,p,t) in surplus) +
                          gp.quicksum(model.interest_rate*value[p,i,t]*I[i,p,t] for (i,p,t) in I if t>=start and t<end), gp.GRB.MINIMIZE)
    
    gp_model.optimize()
    
    print("Opt. Val=", gp_model.ObjVal )
    
    # for idx in x:
    #     if x[idx].X > 0.0001:
    #         print(idx,x[idx].X )
            
    # for idx in I:
    #     try:
    #         if I[idx].X > 0.0001:
    #             print(idx,I[idx].X)
    #     except:
    #         print("fix=", idx, I[idx])
    return gp_model

# %% ../nbs/04scml2.ipynb 56
def visualize_network(model:Model):
    D = SCMGraph()
    for (i,j), arc in  model.arcs.items():
        D.add_edge(i,j)
            
    pos ={}
    no_position = False
    for i, node in model.nodes.items():
        if node.location is None:
            no_position = True
            break
        else:
            pos[i] = node.location
    if no_position:
        if nx.is_directed_acyclic_graph(D):
            pos = D.layout()
        else:
            pos=nx.spring_layout(D)
    nx.draw(D, pos=pos, with_labels=True, node_color="Yellow")

# %% ../nbs/04scml2.ipynb 58
def visualize(model:Model, rankdir:str ="LR", size:float = 5):
    def draw_activity(a:str, act:Activity, g:graphviz.Digraph, c:graphviz.Digraph.subgraph ):
        c.attr(style='filled', color='lightgrey')
        c.node(name= a, shape="rectangle", color="red")  
        #product
        c.node(name = f"{a}\n {act.product.name}", shape ="oval", color ="yellow")
        for m, mode in act.modes.items():
            c.node(name=mode.name, shape="box3d", color="blue")
            c.edge(a, mode.name, arrowhead="tee", style="dotted", color="blue" )
            if mode.variable_requirement is not None:
                requirement = mode.variable_requirement
            elif mode.fixed_requirement is not None:
                requirement = mode.fixed_requirement
            else:
                requirement = {}
            for rname, val in requirement.items():
                g.edge(mode.name, rname, arrowhead="box", style="dashed", color="green")
                    
    g = graphviz.Digraph('G', filename='ｓｃｍｌ.gv')
    g.graph_attr["rankdir"]= rankdir
    g.graph_attr["size"] = str(size)
    act_in_node = set([])
    if model.nodes is not None:
        for i, node in model.nodes.items():
            with g.subgraph(name=f"cluster[{i}]") as nc:
                nc.attr(style='filled', color='lightblue')
                nc.node(name= str(i), shape="folder", color="black")
                if node.activities is not None:
                    for a, act in node.activities.items():
                        act_in_node.add(a)
                        with nc.subgraph(name=f"cluster[{a}]") as c:
                            draw_activity(a,act,g,c)
    
    if model.arcs is not None:
        for (i,j), arc in  model.arcs.items():
            label = ""
            if arc.activities is not None:
                for a, act in arc.activities.items():
                    label += f"{a} \n"
            g.edge(str(i), str(j), arrowhead="normal", label=label )
    
    if model.resources is not None:
        for r, res in model.resources.items():
            g.node(name=r, shape="trapezium", color="green")
    
    if model.activities is not None:
        for a, act in model.activities.items():
            if a in act_in_node:
                continue
            with g.subgraph(name=f"cluster[{a}]") as c:
                draw_activity(a,act,g,c)
    #BOM
    bom = graphviz.Digraph('BOM', filename='bom.gv')
    bom.graph_attr["rankdir"]="LR"
    if model.activities is not None:
        for a, act in model.activities.items():
            bom.node(name = f"{act.product.name}", shape ="oval", color ="black")
            for m, mode in act.modes.items():
                #bom.edge(a, mode.name, arrowhead="tee", style="dotted", color="blue" )
                if mode.components is not None:
                    for child, weight  in mode.components.items():
                        if weight !=1.0:
                            label = str(weight)
                        else:
                            label = ""
                        bom.edge(child, act.product.name, arrowhead="curve", label= label )
    return g, bom

# %% ../nbs/04scml2.ipynb 130
def tabu_search_for_SSA(G, ProcTime, z, mu, sigma, h, LTUB, max_iter = 100, TLLB =1, TLUB =10, seed = 1):
    """
    一般のネットワークの安全在庫配置モデルに対するタブー探索（mu未使用；NRT日の最大在庫量をシミュレーションもしくは畳み込みによって事前計算？もしくは正規分布で近似）
    """
    assert nx.is_directed_acyclic_graph(G)
    np.random.seed(seed)
    
    n = len(G)
    b = np.random.randint(0,2,n)# random 0-1 vector
    
    candidate = []  #探索候補のリストを準備
    for i in G:
        # if G.out_degree(i)==0:
        #     b[i] = 1  #demand point always has inventory
        # else:
        candidate.append(i)
    
    m = len(candidate) #近傍解の個数
    
    NRT = np.zeros(n)
    MaxLI = np.zeros(n)
    MinLT =np.zeros(n)
    # 全ての近傍を同時に評価するための多次元配列
    vNRT = np.zeros((m,n))  #正味補充時間
    vMaxLI = np.zeros((m,n)) #最大入庫リード時間
    vMinLT = np.zeros((m,n)) #最小保証リード時間
    
    TabuList = np.zeros(m, int)
    
    # 初期解の評価
    # MaxLI: 最大入庫リード時間
    for i in G.down_order():
        if G.in_degree(i) == 0: #供給地点のMAXLIは生産時間
            MaxLI[i] = ProcTime[i]  #LTLB + ProcTime[i]
        else: #それ以外の点では，在庫を置く場合（b[k]=1)は生産時間， 置かない場合は max MAXLI[k] に生産時間を加えたものになる
            max_ = 0.
            for k in G.predecessors(i):
                max_ = max(max_, (1-b[k])*MaxLI[k])
            MaxLI[i] = ProcTime[i] + max_
    
    #MinLT: 最小保証リード時間
    for i in G.up_order():
        if G.out_degree(i)==0: #需要地点のリード時間は０（もしくはLTUB）とする
            MinLT[i] = LTUB[i]  # or 0
        else: #それ以外の場合には，後続点jの正味補充時間と最小保証リード時間から生産時間を減じた量の最小値になる
            min_ = np.inf
            for j in G.successors(i):
                min_ = min( min_, NRT[j]+MinLT[j] -ProcTime[j] )
            MinLT[i] = min_
        NRT[i] = max( MaxLI[i]-MinLT[i], 0) #点iの正味保証時間（負の場合は0とする）
    
    cost = (h*z*sigma*np.sqrt(NRT)).sum() #正規分布でない一般の分布 dist の場合には，　h * dist.ppt(ssr) に変更！
    #print("cost=",cost,b)
    
    #最良解の保存
    best_cost = cost
    prev_cost = cost
    best_sol = b.copy()
    b_prev = b.copy() #直前の解を保存
    best_NRT = NRT.copy()
    best_MaxLI = MaxLI.copy()
    best_MinLT = MinLT.copy()
    
    # タブー探索
    ltm_factor = 0. #長期メモリの係数
    ltm_increase = cost/float(n*max_iter)/10.
    ltm = np.zeros(m, int) #移動に選ばれた回数（長期メモリ）
    
    #print("iter cost TLLB TLUB LTM")
    for iter_ in range(max_iter):
    
        #近傍解の構築
        B = [ ]
        for i in candidate:
            newb = b.copy()
            newb[i] = 1-b[i] #ビット反転
            B.append(newb)
        B = np.array(B)
    
        for i in G.down_order():
            if G.in_degree(i) == 0:
                vMaxLI[:,i] = ProcTime[i]  
            else:
                max_ = np.zeros(m)
                for k in G.predecessors(i):
                    max_ = np.maximum(max_, (1-B[:,k])*vMaxLI[:,k])
                vMaxLI[:,i] = ProcTime[i] + max_
    
        for i in G.up_order():
            if G.out_degree(i)==0:
                vMinLT[:,i] = LTUB[i]  #or 0
            else:
                min_ = np.full(m, np.inf )
                for j in G.successors(i):
                    min_ = np.minimum( min_, vNRT[:,j]+vMinLT[:,j] -ProcTime[j] )
                vMinLT[:,i] = min_
            vNRT[:,i] = np.maximum(vMaxLI[:,i]-vMinLT[:,i], 0)
    
        cost = (h*z*sigma*np.sqrt(vNRT[:,:])).sum(axis=1)
    
        #istar = cost.argmin()
        min_ = np.inf 
        istar = -1
        for i in range(m):
            if iter_ >= TabuList[i]:
                if cost[i] + ltm_factor*ltm[i] < min_ :
                    min_ = cost[i] + ltm_factor*ltm[i]
                    istar = i
            else:
                #tabu check the aspiration level
                if cost[i] < best_cost:
                    if cost[i] < min_ :
                        min_ = cost[i]
                        istar = i
    
        if istar==-1:
            #print("Tabu List Clear!")
            TLLB =max(TLLB -1, 1)
            TLUB =max(TLUB -1, 2)
            TabuList = np.zeros(m, int)
        else:
            b = B[istar]
            ltm[istar] +=1
            if np.all(b_prev == b): # same solution => increase Tabu Length
                #print("Tabu Length increase!")
                TLLB +=1
                TLUB +=1
            elif prev_cost==cost[istar]: #same solution value => plateau => increase long term memory
                ltm_factor += ltm_increase
    
            b_prev = b.copy()
            prev_cost = cost[istar]
            TabuList[istar] = iter_ + np.random.randint(TLLB,TLUB+1)
            if cost[istar] < best_cost:
                best_cost = cost[istar]
                best_sol = B[istar].copy()
                best_NRT = vNRT[istar].copy()
                best_MaxLI = vMaxLI[istar].copy()
                best_MinLT = vMinLT[istar].copy()
            #print(iter_, round(cost[istar],3), TLLB, TLUB, round(ltm_factor,4) )  #,B[istar])
    # 在庫のない（正味補充時間が0の）地点のビットを0にする．
    for i in range(n):
        if best_NRT[i]<=0.00001:
            best_sol[i] = 0
    
    return best_cost, best_sol, best_NRT, best_MaxLI, best_MinLT
