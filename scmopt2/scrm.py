"""Supply chain risk analysis system MERIODAS (MEta RIsk Oriented Disruption Analysis System)"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/09scrm.ipynb.

# %% auto 0
__all__ = ['folder', 'folder_bom', 'data_generation_for_scrm', 'make_df_for_scrm', 'prepare', 'draw_graph', 'solve_scrm',
           'draw_scrm']

# %% ../nbs/09scrm.ipynb 3
import sys
sys.path.append('..')
from .optinv import *
from .core import *

#from gurobipy import Model, quicksum, GRB
from .mypulp import Model, quicksum, GRB

import numpy as np
import networkx as nx
import plotly.graph_objs as go
import plotly.express as px
import plotly
import pandas as pd
import random
import datetime
import math
from collections import OrderedDict, defaultdict
import networkx as nx
from IPython.display import Image, YouTubeVideo

folder = "./data/scrm/"
folder_bom = "./data/bom/"

# %% ../nbs/09scrm.ipynb 23
def data_generation_for_scrm(BOM, n_plnts = 3, n_flex = 2, prob = 0.5, capacity_factor=1.0,
                             production_factor=1.0, pipeline_factor =1.0, seed = 1):
    """
    ベンチマーク問題例から、データを生成する関数
    """
    random.seed(seed)

    # 点の深さと、各深さに含まれる製品のリストを作る
    depth_dic = nx.get_node_attributes(BOM, "relDepth")  # map node to depth (str)
    depth_set = set(depth_dic.values())
    depth = len(depth_set)
    ProdInDepth = [[] for d in range(depth)]
    for i in depth_dic:
        d = int(depth_dic[i])
        # print(i,d)
        ProdInDepth[d].append(i)

    # 工場グラフを生成（各深さに n_plnts個の工場を配置、製品をランダムにn_flex個配置、枝はprobではる）
    G = nx.DiGraph()  # Plant Graph
    Product = {}
    pos2 = {}
    NodeInDepth = [[] for d in range(depth)]
    id_ = 0
    for d in range(depth):
        added_prod = []
        for i in range(n_plnts):
            G.add_node(id_)
            pos2[id_] = (depth-d, n_plnts-i)
            NodeInDepth[d].append(id_)
            Product[id_] = random.sample(
                ProdInDepth[d], min(n_flex, len(ProdInDepth[d])))
            added_prod.extend(Product[id_])
            id_ += 1
        # どの工場でも生産されていない製品があれば、それを加える。
        all_prod = set(ProdInDepth[d])
        added_prod_set = set(added_prod)
        Product[id_ - 1].extend(all_prod-added_prod_set)

    for d in range(1, depth):
        for count1, i in enumerate(NodeInDepth[d]):
            for count2, j in enumerate(NodeInDepth[d-1]):
                if count1 == count2:
                    G.add_edge(i, j)
                elif random.random() <= prob:
                    G.add_edge(i, j)

    # Construct product graph（生産グラフの生成）
    ProdGraph = nx.tensor_product(G, BOM)
    Temp = ProdGraph.copy()
    for (i, p) in Temp:
        if p not in Product[i]:
            ProdGraph.remove_node((i, p))

    # 座標を得るためにSCMGraphにコピー
    ProdGraph2 = SCMGraph()
    ProdGraph2.add_nodes_from(ProdGraph.nodes())
    ProdGraph2.add_edges_from(ProdGraph.edges())
    pos3 = ProdGraph2.layout()

    Pipeline, Demand, UB = {}, {}, {}
    Capacity = {}
    total_demand = 0.
    for n in ProdGraph:
        if BOM.out_degree(n[1]) == 0:
            Demand[n] = float(BOM.nodes[n[1]]["avgDemand"])
            total_demand += Demand[n]

    for i in G:
        Capacity[i] = total_demand * capacity_factor  # 工場の容量
    for n in ProdGraph:
        UB[n] = total_demand *production_factor
        Pipeline[n] = float(BOM.nodes[n[1]]["stageTime"])*total_demand * pipeline_factor

    R = {}
    for (u, v) in ProdGraph.edges():
        (i, p) = u
        (j, q) = v
        R[u, v] = 1

    return Demand, total_demand, UB, Capacity, Pipeline, R, Product, G, ProdGraph2, pos2, pos3

# %% ../nbs/09scrm.ipynb 27
def  make_df_for_scrm(G,Demand,UB,Capacity,Pipeline,BOM,fn):
    col_name = ["child", "parent", "units"]
    col_list = {i: [] for i in col_name}
    for (i,j) in BOM.edges():
        col_list["child"].append(i)
        col_list["parent"].append(j)
        col_list["units"].append(1)

    bom_df = pd.DataFrame(col_list, columns= col_name)
    bom_df.to_csv(folder+"bom"+fn+".csv")

    col_name =["from_node", "to_node", "kind"]
    col_list = {i: [] for i in col_name}
    for (i,j) in G.edges():
        col_list["from_node"].append(i)
        col_list["to_node"].append(j)
        col_list["kind"].append("plnt-plnt")

    trans_df = pd.DataFrame(col_list, columns= col_name)
    trans_df.to_csv(folder+"trans"+fn+".csv")

    col_name =["plnt", "prod", "ub", "pipeline", "demand"]
    col_list = {i: [] for i in col_name}
    for i,p in Pipeline:
        col_list["plnt"].append(i)
        col_list["prod"].append(p)
        col_list["ub"].append(UB[i,p])
        col_list["pipeline"].append(Pipeline[i,p])
        if (i,p) in Demand:
            col_list["demand"].append(Demand[i,p])
        else:
            col_list["demand"].append(None)
    plnt_prod_df = pd.DataFrame(col_list, columns= col_name)
    plnt_prod_df.to_csv(folder+"plnt_prod"+fn+".csv")
    col_name =["name", "ub"]
    col_list = {i: [] for i in col_name}
    for i in Capacity:
        col_list["name"].append(i)
        col_list["ub"].append(Capacity[i])
    plnt_df = pd.DataFrame(col_list, columns= col_name)
    plnt_df.to_csv(folder+"plnt"+fn+".csv")

# %% ../nbs/09scrm.ipynb 31
def prepare(fn, folder):
    bom_df = pd.read_csv(folder+"bom"+fn+".csv", index_col=0)
    plnt_df = pd.read_csv(folder+"plnt"+fn+".csv", index_col=0)
    plnt_prod_df = pd.read_csv(folder+"plnt_prod"+fn+".csv", index_col=0)
    trans_df = pd.read_csv(folder+"trans"+fn+".csv", index_col=0)

    #Demand, UB, Pipeline
    Demand, UB, Pipeline= {}, {}, {}
    Product ={ i:[]  for i in list(plnt_df.name) }
    for row in plnt_prod_df.itertuples():
        if np.isnan(row.demand):
            pass
        else:
            Demand[row.plnt, row.prod] = row.demand
        UB[row.plnt, row.prod] = row.ub
        Pipeline[row.plnt, row.prod] = row.pipeline
        Product[row.plnt].append(row.prod)

    Capacity ={ }
    for row in plnt_df.itertuples():
        Capacity[row.name] = row.ub

    #BOM
    BOM = SCMGraph()
    for row in bom_df.itertuples():
        BOM.add_edge(row.child, row.parent, weight=row.units)
    pos = BOM.layout()
    #Plant Transportaion Graph
    G = SCMGraph()
    for row in trans_df.itertuples():
        G.add_edge(row.from_node, row.to_node)
    pos2 = G.layout()
    # Construct product graph（生産グラフの生成）
    ProdGraph = nx.tensor_product(G, BOM)
    Temp = ProdGraph.copy()
    for (i, p) in Temp:
        if p not in Product[i]:
            ProdGraph.remove_node((i, p))

    # 座標を得るためにSCMGraphにコピー
    ProdGraph2 = SCMGraph()
    ProdGraph2.add_nodes_from(ProdGraph.nodes())
    ProdGraph2.add_edges_from(ProdGraph.edges())
    pos3 = ProdGraph2.layout()

    R = {}
    for (u, v) in ProdGraph.edges():
        (i, p) = u
        (j, q) = v
        R[u, v] = BOM[p][q]["weight"]

    return Demand, UB, Capacity, Pipeline, R, BOM, Product, G, ProdGraph2, pos, pos2, pos3, bom_df, plnt_df, plnt_prod_df, trans_df

# %% ../nbs/09scrm.ipynb 35
def draw_graph(G, pos, title="", size=30, color="Yellow"):
    """
    グラフをPlotlyで描画する関数
    """

    x_, y_, text_ = [], [], []
    for idx, i in enumerate(G):
        x_.append(pos[i][0])
        y_.append(pos[i][1])
        text_.append(str(i))

    node_trace = go.Scatter(
        x=x_,
        y=y_,
        mode='markers',
        text=text_,
        marker=dict(
            size=size,
            color=color
        ),
        hoverinfo="text",
        name="nodes",
        showlegend=False
    )

    edge_x = []
    edge_y = []
    for edge in G.edges():
        x0, y0 = pos[edge[0]]
        x1, y1 = pos[edge[1]]
        edge_x.append(x0)
        edge_x.append(x1)
        edge_x.append(None)
        edge_y.append(y0)
        edge_y.append(y1)
        edge_y.append(None)

    edge_trace = go.Scatter(
        x=edge_x, y=edge_y,
        line=dict(width=0.5, color='#888'),
        hoverinfo='none',
        mode='lines',
        name="edges",
        showlegend=False
    )

    layout = go.Layout(xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
                       yaxis=dict(showgrid=False, zeroline=False,
                                  showticklabels=False),
                       title=title)

    data = [node_trace, edge_trace]
    fig = go.Figure(data, layout)
    return fig

# %% ../nbs/09scrm.ipynb 40
def solve_scrm(Demand, UB, Capacity, Pipeline, R, Product, ProdGraph, BOM):
    """
    リスク分析問題を解く関数
    """
    survival_time = []
    tempUB = {}
    for s in ProdGraph:
        # for each scenario s
        for n in ProdGraph:
            tempUB[n] = UB[n]
        tempUB[s] = 0.0
        #print("Scenario", s)

        model = Model()
        tn = model.addVar(name='tn', vtype='C')
        u, y = {}, {}
        for i, j in ProdGraph.edges():
            y[i, j] = model.addVar(name='y({0},{1})'.format(i, j))
        for j in ProdGraph:
            u[j] = model.addVar(name='u({0})'.format(j), ub=tempUB[j])

        model.update()
        model.setObjective(tn, GRB.MAXIMIZE)

        # 生産量と入庫輸送量との関係
        for j in ProdGraph:
            if ProdGraph.in_degree(j) > 0:
                (plant, prod) = j
                for child in BOM.predecessors(prod):
                    model.addConstr(u[j] <= quicksum((1/float(R[i, j])) * y[i, j]
                                                     for i in ProdGraph.predecessors(j)
                                                     if i[1] == child),
                                    name=f"BOM{j}_{child}")

        # 生産量と出庫輸送量の関係
        for i in ProdGraph:
            if ProdGraph.out_degree(i) > 0:
                model.addConstr(quicksum(y[i, j] for j in ProdGraph.successors(i))
                                <= u[i] + Pipeline[i], name="BOM2_{0}".format(i))

        # 需要満足条件
        for j in Demand:
            model.addConstr(u[j] >= Demand[j]*tn, name="Demand{0}".format(j))

        # 工場の生産容量制約
        for f in Capacity:
            model.addConstr(quicksum(u[f, p] for p in Product[f]) <= Capacity[f]*tn,
                            name="Capacity{0}".format(f))

        # print(model)
        model.Params.OutputFlag = False
        model.optimize()
        #print('tn=', tn.X)
        survival_time.append(tn.X)
    return survival_time

# %% ../nbs/09scrm.ipynb 44
def draw_scrm(ProdGraph, survival_time, Pipeline, UB, pos3):
    """
    リスク分析ネットワークを描画する関数
    """
    #ST = np.array(survival_time)
    #scaledST = np.log(ST/(ST.max()+0.001))
    
    ST = np.array(survival_time)
    scaledST = np.log(ST+1.001)

    size_ = scaledST*30 + 1.

    x_, y_, text_ = [],[],[]
    color_ =[]
    for i,n in enumerate(ProdGraph):
        x_.append( pos3[n][0] )
        y_.append( pos3[n][1] )
        text_.append( str(n) + " 生存期間:" +str(survival_time[i]) + " パイプライン在庫:" + str(Pipeline[n]) + " 生産量上限:" + str(UB[n])  )
        color_.append( Pipeline[n])

    node_trace = go.Scatter(
        x = x_,
        y = y_,
        mode = 'markers',
        text= text_,
        hoverinfo="text",
        marker= dict(size= size_,
            #'Greys' | 'YlGnBu' | 'Greens' | 'YlOrRd' | 'Bluered' | 'RdBu' |
            #'Reds' | 'Blues' | 'Picnic' | 'Rainbow' | 'Portland' | 'Jet' |
            #'Hot' | 'Blackbody' | 'Earth' | 'Electric' | 'Viridis' |
                colorscale="Hot",
                reversescale=True,
                color= color_,
                colorbar=dict(
                        thickness=15,
                        title='Pipeline Inventory',
                        xanchor='left',
                        titleside='right'
                        ),
                ),
         name = "nodes",
         showlegend=False
    )

    edge_x = []
    edge_y = []
    for edge in ProdGraph.edges():
        x0, y0 = pos3[edge[0]]
        x1, y1 = pos3[edge[1]]
        edge_x.append(x0)
        edge_x.append(x1)
        edge_x.append(None)
        edge_y.append(y0)
        edge_y.append(y1)
        edge_y.append(None)

    edge_trace = go.Scatter(
        x=edge_x, y=edge_y,
        line=dict(width=0.5, color='#888'),
        hoverinfo='none',
        mode='lines',
        name = "edges",
        showlegend=False
        )

    layout=go.Layout(xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
                    yaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
                    title="Risk Analysis Network (点の大きさ: 途絶時の生存期間, 色： パイプライン在庫)")

    data = [node_trace, edge_trace]
    fig = go.Figure(data,layout)
    return fig
