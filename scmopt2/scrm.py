"""Supply chain risk analysis system MERIODAS (MEta RIsk Oriented Disruption Analysis System)"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/09scrm.ipynb.

# %% auto 0
__all__ = ['folder', 'folder_bom', 'data_generation_for_scrm', 'make_df_for_scrm', 'prepare', 'draw_graph', 'solve_scrm',
           'draw_scrm', 'optimize_scrm_expected', 'optimize_scrm_cvar', 'compare_scrm_policies']

# %% ../nbs/09scrm.ipynb 3
import sys
sys.path.append('..')
from .optinv import *
from .core import *

#from gurobipy import Model, quicksum, GRB
from .mypulp import Model, quicksum, GRB

import numpy as np
import networkx as nx
import plotly.graph_objs as go
import plotly.express as px
import plotly
import pandas as pd
import random
import datetime
import math
from collections import OrderedDict, defaultdict
import networkx as nx
from IPython.display import Image, YouTubeVideo

folder = "./data/scrm/"
folder_bom = "./data/bom/"

# %% ../nbs/09scrm.ipynb 23
def data_generation_for_scrm(BOM, n_plnts = 3, n_flex = 2, prob = 0.5, capacity_factor=1.0,
                             production_factor=1.0, pipeline_factor =1.0, seed = 1):
    """
    ベンチマーク問題例から、データを生成する関数
    """
    random.seed(seed)

    # 点の深さと、各深さに含まれる製品のリストを作る
    depth_dic = nx.get_node_attributes(BOM, "relDepth")  # map node to depth (str)
    depth_set = set(depth_dic.values())
    depth = len(depth_set)
    ProdInDepth = [[] for d in range(depth)]
    for i in depth_dic:
        d = int(depth_dic[i])
        # print(i,d)
        ProdInDepth[d].append(i)

    # 工場グラフを生成（各深さに n_plnts個の工場を配置、製品をランダムにn_flex個配置、枝はprobではる）
    G = nx.DiGraph()  # Plant Graph
    Product = {}
    pos2 = {}
    NodeInDepth = [[] for d in range(depth)]
    id_ = 0
    for d in range(depth):
        added_prod = []
        for i in range(n_plnts):
            G.add_node(id_)
            pos2[id_] = (depth-d, n_plnts-i)
            NodeInDepth[d].append(id_)
            Product[id_] = random.sample(
                ProdInDepth[d], min(n_flex, len(ProdInDepth[d])))
            added_prod.extend(Product[id_])
            id_ += 1
        # どの工場でも生産されていない製品があれば、それを加える。
        all_prod = set(ProdInDepth[d])
        added_prod_set = set(added_prod)
        Product[id_ - 1].extend(all_prod-added_prod_set)

    for d in range(1, depth):
        for count1, i in enumerate(NodeInDepth[d]):
            for count2, j in enumerate(NodeInDepth[d-1]):
                if count1 == count2:
                    G.add_edge(i, j)
                elif random.random() <= prob:
                    G.add_edge(i, j)

    # Construct product graph（生産グラフの生成）
    ProdGraph = nx.tensor_product(G, BOM)
    Temp = ProdGraph.copy()
    for (i, p) in Temp:
        if p not in Product[i]:
            ProdGraph.remove_node((i, p))

    # 座標を得るためにSCMGraphにコピー
    ProdGraph2 = SCMGraph()
    ProdGraph2.add_nodes_from(ProdGraph.nodes())
    ProdGraph2.add_edges_from(ProdGraph.edges())
    pos3 = ProdGraph2.layout()

    Pipeline, Demand, UB = {}, {}, {}
    Capacity = {}
    total_demand = 0.
    for n in ProdGraph:
        if BOM.out_degree(n[1]) == 0:
            Demand[n] = float(BOM.nodes[n[1]]["avgDemand"])
            total_demand += Demand[n]

    for i in G:
        Capacity[i] = total_demand * capacity_factor  # 工場の容量
    for n in ProdGraph:
        UB[n] = total_demand *production_factor
        Pipeline[n] = float(BOM.nodes[n[1]]["stageTime"])*total_demand * pipeline_factor

    R = {}
    for (u, v) in ProdGraph.edges():
        (i, p) = u
        (j, q) = v
        R[u, v] = 1

    return Demand, total_demand, UB, Capacity, Pipeline, R, Product, G, ProdGraph2, pos2, pos3

# %% ../nbs/09scrm.ipynb 27
def  make_df_for_scrm(G,Demand,UB,Capacity,Pipeline,BOM,fn):
    col_name = ["child", "parent", "units"]
    col_list = {i: [] for i in col_name}
    for (i,j) in BOM.edges():
        col_list["child"].append(i)
        col_list["parent"].append(j)
        col_list["units"].append(1)

    bom_df = pd.DataFrame(col_list, columns= col_name)
    bom_df.to_csv(folder+"bom"+fn+".csv")

    col_name =["from_node", "to_node", "kind"]
    col_list = {i: [] for i in col_name}
    for (i,j) in G.edges():
        col_list["from_node"].append(i)
        col_list["to_node"].append(j)
        col_list["kind"].append("plnt-plnt")

    trans_df = pd.DataFrame(col_list, columns= col_name)
    trans_df.to_csv(folder+"trans"+fn+".csv")

    col_name =["plnt", "prod", "ub", "pipeline", "demand"]
    col_list = {i: [] for i in col_name}
    for i,p in Pipeline:
        col_list["plnt"].append(i)
        col_list["prod"].append(p)
        col_list["ub"].append(UB[i,p])
        col_list["pipeline"].append(Pipeline[i,p])
        if (i,p) in Demand:
            col_list["demand"].append(Demand[i,p])
        else:
            col_list["demand"].append(None)
    plnt_prod_df = pd.DataFrame(col_list, columns= col_name)
    plnt_prod_df.to_csv(folder+"plnt_prod"+fn+".csv")
    col_name =["name", "ub"]
    col_list = {i: [] for i in col_name}
    for i in Capacity:
        col_list["name"].append(i)
        col_list["ub"].append(Capacity[i])
    plnt_df = pd.DataFrame(col_list, columns= col_name)
    plnt_df.to_csv(folder+"plnt"+fn+".csv")

# %% ../nbs/09scrm.ipynb 31
def prepare(fn, folder):
    bom_df = pd.read_csv(folder+"bom"+fn+".csv", index_col=0)
    plnt_df = pd.read_csv(folder+"plnt"+fn+".csv", index_col=0)
    plnt_prod_df = pd.read_csv(folder+"plnt_prod"+fn+".csv", index_col=0)
    trans_df = pd.read_csv(folder+"trans"+fn+".csv", index_col=0)

    #Demand, UB, Pipeline
    Demand, UB, Pipeline= {}, {}, {}
    Product ={ i:[]  for i in list(plnt_df.name) }
    for row in plnt_prod_df.itertuples():
        if np.isnan(row.demand):
            pass
        else:
            Demand[row.plnt, row.prod] = row.demand
        UB[row.plnt, row.prod] = row.ub
        Pipeline[row.plnt, row.prod] = row.pipeline
        Product[row.plnt].append(row.prod)

    Capacity ={ }
    for row in plnt_df.itertuples():
        Capacity[row.name] = row.ub

    #BOM
    BOM = SCMGraph()
    for row in bom_df.itertuples():
        BOM.add_edge(row.child, row.parent, weight=row.units)
    pos = BOM.layout()
    #Plant Transportaion Graph
    G = SCMGraph()
    for row in trans_df.itertuples():
        G.add_edge(row.from_node, row.to_node)
    pos2 = G.layout()
    # Construct product graph（生産グラフの生成）
    ProdGraph = nx.tensor_product(G, BOM)
    Temp = ProdGraph.copy()
    for (i, p) in Temp:
        if p not in Product[i]:
            ProdGraph.remove_node((i, p))

    # 座標を得るためにSCMGraphにコピー
    ProdGraph2 = SCMGraph()
    ProdGraph2.add_nodes_from(ProdGraph.nodes())
    ProdGraph2.add_edges_from(ProdGraph.edges())
    pos3 = ProdGraph2.layout()

    R = {}
    for (u, v) in ProdGraph.edges():
        (i, p) = u
        (j, q) = v
        R[u, v] = BOM[p][q]["weight"]

    return Demand, UB, Capacity, Pipeline, R, BOM, Product, G, ProdGraph2, pos, pos2, pos3, bom_df, plnt_df, plnt_prod_df, trans_df

# %% ../nbs/09scrm.ipynb 35
def draw_graph(G, pos, title="", size=30, color="Yellow"):
    """
    グラフをPlotlyで描画する関数
    """

    x_, y_, text_ = [], [], []
    for idx, i in enumerate(G):
        x_.append(pos[i][0])
        y_.append(pos[i][1])
        text_.append(str(i))

    node_trace = go.Scatter(
        x=x_,
        y=y_,
        mode='markers',
        text=text_,
        marker=dict(
            size=size,
            color=color
        ),
        hoverinfo="text",
        name="nodes",
        showlegend=False
    )

    edge_x = []
    edge_y = []
    for edge in G.edges():
        x0, y0 = pos[edge[0]]
        x1, y1 = pos[edge[1]]
        edge_x.append(x0)
        edge_x.append(x1)
        edge_x.append(None)
        edge_y.append(y0)
        edge_y.append(y1)
        edge_y.append(None)

    edge_trace = go.Scatter(
        x=edge_x, y=edge_y,
        line=dict(width=0.5, color='#888'),
        hoverinfo='none',
        mode='lines',
        name="edges",
        showlegend=False
    )

    layout = go.Layout(xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
                       yaxis=dict(showgrid=False, zeroline=False,
                                  showticklabels=False),
                       title=title)

    data = [node_trace, edge_trace]
    fig = go.Figure(data, layout)
    return fig

# %% ../nbs/09scrm.ipynb 40
def solve_scrm(Demand, UB, Capacity, Pipeline, R, Product, ProdGraph, BOM):
    """
    リスク分析問題を解く関数
    """
    survival_time = []
    tempUB = {}
    for s in ProdGraph:
        # for each scenario s
        for n in ProdGraph:
            tempUB[n] = UB[n]
        tempUB[s] = 0.0
        #print("Scenario", s)

        model = Model()
        tn = model.addVar(name='tn', vtype='C')
        u, y = {}, {}
        for i, j in ProdGraph.edges():
            y[i, j] = model.addVar(name='y({0},{1})'.format(i, j))
        for j in ProdGraph:
            u[j] = model.addVar(name='u({0})'.format(j), ub=tempUB[j])

        model.update()
        model.setObjective(tn, GRB.MAXIMIZE)

        # 生産量と入庫輸送量との関係
        for j in ProdGraph:
            if ProdGraph.in_degree(j) > 0:
                (plant, prod) = j
                for child in BOM.predecessors(prod):
                    model.addConstr(u[j] <= quicksum((1/float(R[i, j])) * y[i, j]
                                                     for i in ProdGraph.predecessors(j)
                                                     if i[1] == child),
                                    name=f"BOM{j}_{child}")

        # 生産量と出庫輸送量の関係
        for i in ProdGraph:
            if ProdGraph.out_degree(i) > 0:
                model.addConstr(quicksum(y[i, j] for j in ProdGraph.successors(i))
                                <= u[i] + Pipeline[i], name="BOM2_{0}".format(i))

        # 需要満足条件
        for j in Demand:
            model.addConstr(u[j] >= Demand[j]*tn, name="Demand{0}".format(j))

        # 工場の生産容量制約
        for f in Capacity:
            model.addConstr(quicksum(u[f, p] for p in Product[f]) <= Capacity[f]*tn,
                            name="Capacity{0}".format(f))

        # print(model)
        model.Params.OutputFlag = False
        model.optimize()
        #print('tn=', tn.X)
        survival_time.append(tn.X)
    return survival_time

# %% ../nbs/09scrm.ipynb 44
def draw_scrm(ProdGraph, survival_time, Pipeline, UB, pos3):
    """
    リスク分析ネットワークを描画する関数
    """
    #ST = np.array(survival_time)
    #scaledST = np.log(ST/(ST.max()+0.001))
    
    ST = np.array(survival_time)
    scaledST = np.log(ST+1.001)

    size_ = scaledST*30 + 1.

    x_, y_, text_ = [],[],[]
    color_ =[]
    for i,n in enumerate(ProdGraph):
        x_.append( pos3[n][0] )
        y_.append( pos3[n][1] )
        text_.append( str(n) + " 生存期間:" +str(survival_time[i]) + " パイプライン在庫:" + str(Pipeline[n]) + " 生産量上限:" + str(UB[n])  )
        color_.append( Pipeline[n])

    node_trace = go.Scatter(
        x = x_,
        y = y_,
        mode = 'markers',
        text= text_,
        hoverinfo="text",
        marker= dict(size= size_,
            #'Greys' | 'YlGnBu' | 'Greens' | 'YlOrRd' | 'Bluered' | 'RdBu' |
            #'Reds' | 'Blues' | 'Picnic' | 'Rainbow' | 'Portland' | 'Jet' |
            #'Hot' | 'Blackbody' | 'Earth' | 'Electric' | 'Viridis' |
                colorscale="Hot",
                reversescale=True,
                color= color_,
                colorbar=dict(
                        thickness=15,
                        title='Pipeline Inventory',
                        xanchor='left'
                        ),
                ),
         name = "nodes",
         showlegend=False
    )

    edge_x = []
    edge_y = []
    for edge in ProdGraph.edges():
        x0, y0 = pos3[edge[0]]
        x1, y1 = pos3[edge[1]]
        edge_x.append(x0)
        edge_x.append(x1)
        edge_x.append(None)
        edge_y.append(y0)
        edge_y.append(y1)
        edge_y.append(None)

    edge_trace = go.Scatter(
        x=edge_x, y=edge_y,
        line=dict(width=0.5, color='#888'),
        hoverinfo='none',
        mode='lines',
        name = "edges",
        showlegend=False
        )

    layout=go.Layout(xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
                    yaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
                    title="Risk Analysis Network (点の大きさ: 途絶時の生存期間, 色： パイプライン在庫)")

    data = [node_trace, edge_trace]
    fig = go.Figure(data,layout)
    return fig

# %% SCRM Optimization Models
def optimize_scrm_expected(Demand, UB, Capacity, Pipeline, R, Product, ProdGraph, BOM, G,
                           h_cost, b_cost, disruption_prob, TTR, K_max=2):
    """
    期待値最小化による在庫最適化モデル

    Parameters:
    - h_cost: dict, 在庫保管費用 {(plant, product): cost}
    - b_cost: dict, 品切れ費用 {(plant, product): cost}
    - disruption_prob: dict, 工場の途絶確率 {plant: probability}
    - TTR: dict, 工場の回復時間 {plant: time}
    - K_max: int, 同時途絶する工場数の上限 (default: 2)

    Returns:
    - optimal_inventory: dict, 最適在庫量
    - total_cost: float, 総費用
    - expected_backorder: float, 期待バックオーダー費用
    - expected_inventory: float, 期待在庫費用
    """
    from itertools import combinations

    # シナリオ生成
    V = list(Capacity.keys())
    prob = disruption_prob.copy()

    # 同時途絶シナリオの確率計算
    for k in range(2, K_max + 1):
        for comb in combinations(V, k):
            prob_ = 1.0
            for i in comb:
                prob_ *= disruption_prob[i]
            prob[comb] = prob_

    # シナリオごとのTMAX計算
    TMAX = {}
    TTR_scenario = defaultdict(int)
    for s in prob:
        max_ttr = 0
        if hasattr(s, "__iter__") and not isinstance(s, str):
            for i in s:
                TTR_scenario[i, s] = TTR[i]
                max_ttr = max(TTR[i], max_ttr)
            TMAX[s] = max_ttr
        else:
            TTR_scenario[s, s] = TTR[s]
            TMAX[s] = TTR[s]

    # 最適化モデル
    model = Model()
    u, y, I, B = {}, {}, {}, {}

    # 変数定義
    for i, j in ProdGraph.edges():
        for s in prob:
            y[i, j, s] = model.addVar(name=f'y({i},{j},{s})')

    for j in ProdGraph:
        I[j] = model.addVar(name=f'I({j})')  # 在庫量（即時決定変数）
        for s in prob:
            B[j, s] = model.addVar(name=f"B({j},{s})")  # バックオーダー量
            u[j, s] = model.addVar(name=f'u({j},{s})', ub=UB[j])

    model.update()

    # 目的関数: 期待総費用最小化
    model.setObjective(
        quicksum(h_cost[i] * I[i] for i in ProdGraph) +
        quicksum(prob[s] * b_cost[i] * B[i, s] for i in ProdGraph for s in prob),
        GRB.MINIMIZE
    )

    # 制約条件
    # 1. 生産量と入庫輸送量の関係
    for s in prob:
        for j in ProdGraph:
            if ProdGraph.in_degree(j) > 0:
                (plant, prod) = j
                for child in BOM.predecessors(prod):
                    model.addConstr(
                        u[j, s] <= quicksum(
                            (1 / float(R[i, j])) * y[i, j, s]
                            for i in ProdGraph.predecessors(j)
                            if i[1] == child
                        ),
                        name=f"BOM{j}_{child}_{s}"
                    )

    # 2. 生産量と出庫輸送量の関係
    for s in prob:
        for i in ProdGraph:
            if ProdGraph.out_degree(i) > 0:
                model.addConstr(
                    quicksum(y[i, j, s] for j in ProdGraph.successors(i)) <= u[i, s] + I[i],
                    name=f"BOM2_{i}_{s}"
                )

    # 3. 需要満足条件（在庫+生産+バックオーダー）
    for s in prob:
        for j in Demand:
            model.addConstr(
                u[j, s] + I[j] + B[j, s] >= Demand[j] * TMAX[s],
                name=f"Demand{j}_{s}"
            )

    # 4. 工場の生産容量制約（TTR考慮）
    for s in prob:
        for f in Capacity:
            model.addConstr(
                quicksum(u[(f, p), s] for p in Product[f]) <=
                Capacity[f] * max((TMAX[s] - TTR_scenario[f, s]), 0),
                name=f"Capacity{f}_{s}"
            )

    # 最適化実行
    model.Params.OutputFlag = False
    model.optimize()

    # 結果の取得
    optimal_inventory = {i: I[i].X for i in ProdGraph}
    expected_inventory_cost = sum(h_cost[i] * I[i].X for i in ProdGraph)
    expected_backorder_cost = sum(prob[s] * b_cost[i] * B[i, s].X for i in ProdGraph for s in prob)
    total_cost = expected_inventory_cost + expected_backorder_cost

    return {
        'optimal_inventory': optimal_inventory,
        'total_cost': total_cost,
        'expected_inventory_cost': expected_inventory_cost,
        'expected_backorder_cost': expected_backorder_cost,
        'scenarios': list(prob.keys()),
        'num_scenarios': len(prob)
    }

def optimize_scrm_cvar(Demand, UB, Capacity, Pipeline, R, Product, ProdGraph, BOM, G,
                       h_cost, b_cost, disruption_prob, TTR, beta=0.95, K_max=2):
    """
    CVaR最小化による在庫最適化モデル（リスク回避型）

    Parameters:
    - beta: float, 信頼水準 (例: 0.95 = 95%信頼水準)
    - その他のパラメータは optimize_scrm_expected と同じ

    Returns:
    - optimal_inventory: dict, 最適在庫量
    - cvar: float, CVaR値
    - var: float, VaR値
    - その他の統計情報
    """
    from itertools import combinations

    # シナリオ生成
    V = list(Capacity.keys())
    prob = disruption_prob.copy()

    for k in range(2, K_max + 1):
        for comb in combinations(V, k):
            prob_ = 1.0
            for i in comb:
                prob_ *= disruption_prob[i]
            prob[comb] = prob_

    # TMAX計算
    TMAX = {}
    TTR_scenario = defaultdict(int)
    for s in prob:
        max_ttr = 0
        if hasattr(s, "__iter__") and not isinstance(s, str):
            for i in s:
                TTR_scenario[i, s] = TTR[i]
                max_ttr = max(TTR[i], max_ttr)
            TMAX[s] = max_ttr
        else:
            TTR_scenario[s, s] = TTR[s]
            TMAX[s] = TTR[s]

    # CVaR最適化モデル
    model = Model()
    u, y, I, B, z = {}, {}, {}, {}, {}
    theta = model.addVar(name='theta', lb=-1e10)  # VaR (large negative bound)

    # 変数定義
    for i, j in ProdGraph.edges():
        for s in prob:
            y[i, j, s] = model.addVar(name=f'y({i},{j},{s})')

    for j in ProdGraph:
        I[j] = model.addVar(name=f'I({j})')
        for s in prob:
            B[j, s] = model.addVar(name=f"B({j},{s})")
            u[j, s] = model.addVar(name=f'u({j},{s})', ub=UB[j])

    # CVaR用の補助変数
    for s in prob:
        z[s] = model.addVar(name=f'z({s})')

    model.update()

    # 目的関数: CVaR最小化
    model.setObjective(
        theta + (1 / (1 - beta)) * quicksum(prob[s] * z[s] for s in prob),
        GRB.MINIMIZE
    )

    # CVaR制約
    for s in prob:
        cost_s = quicksum(h_cost[i] * I[i] for i in ProdGraph) + \
                 quicksum(b_cost[i] * B[i, s] for i in ProdGraph)
        model.addConstr(z[s] >= cost_s - theta, name=f"CVaR_{s}")

    # BOM制約（期待値モデルと同じ）
    for s in prob:
        for j in ProdGraph:
            if ProdGraph.in_degree(j) > 0:
                (plant, prod) = j
                for child in BOM.predecessors(prod):
                    model.addConstr(
                        u[j, s] <= quicksum(
                            (1 / float(R[i, j])) * y[i, j, s]
                            for i in ProdGraph.predecessors(j)
                            if i[1] == child
                        ),
                        name=f"BOM{j}_{child}_{s}"
                    )

    for s in prob:
        for i in ProdGraph:
            if ProdGraph.out_degree(i) > 0:
                model.addConstr(
                    quicksum(y[i, j, s] for j in ProdGraph.successors(i)) <= u[i, s] + I[i],
                    name=f"BOM2_{i}_{s}"
                )

    for s in prob:
        for j in Demand:
            model.addConstr(
                u[j, s] + I[j] + B[j, s] >= Demand[j] * TMAX[s],
                name=f"Demand{j}_{s}"
            )

    for s in prob:
        for f in Capacity:
            model.addConstr(
                quicksum(u[(f, p), s] for p in Product[f]) <=
                Capacity[f] * max((TMAX[s] - TTR_scenario[f, s]), 0),
                name=f"Capacity{f}_{s}"
            )

    # 最適化実行
    model.Params.OutputFlag = False
    model.optimize()

    # 結果の取得
    optimal_inventory = {i: I[i].X for i in ProdGraph}
    var_value = theta.X
    cvar_value = model.ObjVal

    # シナリオごとの費用計算
    scenario_costs = {}
    for s in prob:
        cost = sum(h_cost[i] * I[i].X for i in ProdGraph) + \
               sum(b_cost[i] * B[i, s].X for i in ProdGraph)
        scenario_costs[str(s)] = cost

    # 期待費用とバックオーダー費用を計算
    expected_cost = sum(h_cost[i] * I[i].X for i in ProdGraph) + \
                   sum(prob[s] * b_cost[i] * B[i, s].X for i in ProdGraph for s in prob)
    expected_inventory_cost = sum(h_cost[i] * I[i].X for i in ProdGraph)
    expected_backorder_cost = sum(prob[s] * b_cost[i] * B[i, s].X for i in ProdGraph for s in prob)

    return {
        'optimal_inventory': optimal_inventory,
        'cvar': cvar_value,
        'var': var_value,
        'expected_cost': expected_cost,
        'expected_inventory_cost': expected_inventory_cost,
        'expected_backorder_cost': expected_backorder_cost,
        'beta': beta,
        'scenario_costs': scenario_costs,
        'scenarios': list(prob.keys()),
        'num_scenarios': len(prob),
        'n_scenarios': len(prob)
    }

def compare_scrm_policies(Demand, UB, Capacity, Pipeline, R, Product, ProdGraph, BOM, G,
                          h_cost, b_cost, disruption_prob, TTR, beta=0.95, K_max=2):
    """
    期待値最小化とCVaR最小化の在庫方針を比較

    Parameters:
    - 全パラメータは optimize_scrm_expected / optimize_scrm_cvar と同じ

    Returns:
    - dict with comparison results
    """
    # 期待値最小化を実行
    expected_result = optimize_scrm_expected(
        Demand, UB, Capacity, Pipeline, R, Product, ProdGraph, BOM, G,
        h_cost, b_cost, disruption_prob, TTR, K_max
    )

    # CVaR最小化を実行
    cvar_result = optimize_scrm_cvar(
        Demand, UB, Capacity, Pipeline, R, Product, ProdGraph, BOM, G,
        h_cost, b_cost, disruption_prob, TTR, beta, K_max
    )

    # 在庫量の差分を計算
    total_expected_inventory = sum(expected_result['optimal_inventory'].values())
    total_cvar_inventory = sum(cvar_result['optimal_inventory'].values())
    inventory_increase = total_cvar_inventory - total_expected_inventory
    inventory_increase_pct = (inventory_increase / total_expected_inventory) * 100 if total_expected_inventory > 0 else 0

    # 費用の比較
    expected_total_cost = expected_result['total_cost']
    cvar_total_cost = cvar_result['expected_cost']
    cost_increase = cvar_total_cost - expected_total_cost
    cost_increase_pct = (cost_increase / expected_total_cost) * 100 if expected_total_cost > 0 else 0

    # CVaRのリスク指標
    var_value = cvar_result['var']
    cvar_value = cvar_result['cvar']

    # 推奨方針を決定
    recommendation = ""
    if cost_increase_pct < 5:
        recommendation = "CVaR方針を推奨します。費用増加が小さく、リスク回避効果が高いです。"
    elif cost_increase_pct < 15:
        recommendation = "状況に応じて選択してください。期待値方針は費用効率的、CVaR方針はリスク回避的です。"
    else:
        recommendation = "期待値方針を推奨します。CVaR方針の費用増加が大きすぎます。"

    return {
        'expected_policy': expected_result,
        'cvar_policy': cvar_result,
        'comparison': {
            'total_expected_inventory': total_expected_inventory,
            'total_cvar_inventory': total_cvar_inventory,
            'inventory_increase': inventory_increase,
            'inventory_increase_pct': inventory_increase_pct,
            'expected_total_cost': expected_total_cost,
            'cvar_total_cost': cvar_total_cost,
            'cost_increase': cost_increase,
            'cost_increase_pct': cost_increase_pct,
            'var': var_value,
            'cvar': cvar_value
        },
        'recommendation': recommendation
    }
