"""Shift Optimzation using SCOP (Solver for Constraint Programming)"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/10shift.ipynb.

# %% auto 0
__all__ = ['folder', 'TEST', 'generate_day', 'generate_period', 'generate_break_excel', 'generate_requirement_excel',
           'generate_day_excel', 'generate_staff_excel', 'convert_shift_data', 'estimate_requirement',
           'evaluate_violation', 'shift_scheduling', 'shift_scheduling2', 'make_gannt_excel', 'make_allshift_excel',
           'make_requirement_graph', 'make_gannt_for_shift', 'plot_scop_for_shift']

# %% ../nbs/10shift.ipynb 2
import random
import pandas as pd
import holidays
from faker import Faker
from collections import namedtuple, OrderedDict, defaultdict
import ast  #文字列からオブジェクトを起こすモジュール
from plotly.subplots import make_subplots
import plotly.figure_factory as ff
import plotly.graph_objs as go
import plotly.express as px
import plotly
import numpy as np
import datetime as dt
import re
import json 

from openpyxl import Workbook, load_workbook
from openpyxl.worksheet.table import Table, TableStyleInfo
from openpyxl.chart import ScatterChart, Reference, Series
from openpyxl.worksheet.datavalidation import DataValidation
from openpyxl.formatting.rule import ColorScaleRule, CellIsRule, FormulaRule
from openpyxl.styles import Color, PatternFill, Font, Border, Alignment
from openpyxl.styles.borders import Border, Side
from openpyxl.comments import Comment

#import pdb
#%debug
import sys
sys.path.append('..')
from .scop import *
#from scop import *
folder = "./data/shift/"

from ortools.sat.python.cp_model import CpModel, CpSolver
from ortools.sat.python import cp_model

TEST = False

# %% ../nbs/10shift.ipynb 16
def generate_day(start_date, end_date):
    """
    日データ day_df 生成
    """
    jp_holidays = holidays.Japan()
    day_df = pd.DataFrame(pd.date_range(start_date, end_date, freq='D'), columns=["day"])
    day_df["day_of_week"] = [('Holiday') if  t in jp_holidays else (t.strftime('%a')) for t in day_df["day"] ] #曜日欄の追加
    n_day = len(day_df)

    row_ = []
    for row in day_df.itertuples():
        if row.day_of_week =="Holiday":
            row_.append("holiday")
        elif row.day_of_week =="Sun":
            row_.append("sunday")
        else:
            row_.append("weekday")
    day_df["day_type"] = row_
    day_df["id"] = [t for t in range(len(day_df))] 
    day_df = day_df.reindex(columns=["id", "day", "day_of_week", "day_type"])
    return day_df

# %% ../nbs/10shift.ipynb 22
def generate_period(start_time, end_time, freq="1h"):
    """
    期間データ生成関数 generate_period
    """
    period_df = pd.DataFrame(pd.date_range(start_time, end_time, freq=freq),columns=["description"])
    period_df["description"] = period_df.description.dt.strftime("%H:%M")
    period_df["id"] = [t for t in range(len(period_df))]
    period_df = period_df.reindex(columns = ["id", "description"])
    return period_df

# %% ../nbs/10shift.ipynb 28
def generate_break_excel(start_time, end_time, freq):
    period_df = generate_period(start_time, end_time, freq)
    wb = Workbook()
    ws = wb.active 
    data =[]
    ws.append(["期", "開始時刻", "休憩数"])
    for row in period_df.itertuples():
        ws.append([row.id, row.description, 0])
        
    #コメント
    ws.cell(1,1).comment = Comment("期ID（0から始まる整数）", "logopt")
    ws.cell(1,2).comment = Comment("期の開始時刻", "logopt")
    ws.cell(1,3).comment = Comment("最初の期に業務開始したときに必要な休憩期数", "logopt")
    return wb

# %% ../nbs/10shift.ipynb 32
def generate_requirement_excel(start_time, end_time, freq, job_list):
    period_df = generate_period(start_time, end_time, freq)
    T = len(period_df)-1
    day_type_list =['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun', 'Holiday']+[ f"Special{i}" for i in range(1,4)]
    wb = Workbook()
    ws = wb.active
    wb.remove(ws)
    for d in day_type_list:
        ws = wb.create_sheet(d)
        #ws.append( ["  ","期"]+list(period_df.id[:-1]) ) #ヘッダが余分なので削除
        ws.append( ["業務","開始時刻"]+list(period_df.description[:-1]) )
        for i, job in enumerate(job_list):
            ws.append([i, job] +[0 for t in range(T)])
            
        #コメント
        ws.cell(1,1).comment = Comment("業務ID", "logopt")
        ws.cell(1,2).comment = Comment("業務名", "logopt")
        ws.cell(1,3).comment = Comment("時刻ごとの業務の必要人数", "logopt")
    return wb

# %% ../nbs/10shift.ipynb 35
def generate_day_excel(start_date, end_date):
    """
    日データ day_df 生成
    """
    jp_holidays = holidays.Japan()
    day_df = pd.DataFrame(pd.date_range(start_date, end_date, freq='D'), columns=["day"])
    day_df["day_of_week"] = [('Holiday') if  t in jp_holidays else (t.strftime('%a')) for t in day_df["day"] ]
    day_df = day_df.reindex(columns=["day", "day_of_week"])
    wb = Workbook()
    ws = wb.active
    ws.append( ["日","日タイプ"] )
    for row in day_df.itertuples():
        ws.append([row.day.strftime('%Y-%m-%d'), row.day_of_week])
    #データバリデーションの追加（日タイプのみ）
    day_type_list =['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun', 'Holiday']+[ f"Special{i}" for i in range(1,4)]
    stl = ",".join(day_type_list)
    dv = DataValidation(type="list", formula1= f'\"{stl}\"' , allow_blank=False)
    ws.add_data_validation(dv)
    dv.add('B2:B1048576') 
    
    #コメント
    ws.cell(1,1).comment = Comment("日（年-月-日）", "logopt")
    ws.cell(1,2).comment = Comment("日タイプ（曜日，休日，特別日1..3）", "logopt")
    return wb

# %% ../nbs/10shift.ipynb 38
def generate_staff_excel(job_list):
    wb = Workbook()
    ws = wb.active
    ws.append(["email", "秘密鍵", "優先度"] + job_list )
    ws.append(["sample@logopt.com","secret", 1 ]+[1 for i in job_list] )
    #データバリデーションの追加(0か1か)
    dv = DataValidation(type="decimal",
                    operator="between",
                    formula1=0,
                    formula2=1)
    ws.add_data_validation(dv)    
    cell = ws.cell(1, 3+len(job_list))
    col_name = cell.column_letter #列名を抽出
    dv.add(f'D2:{col_name}1048576') 
    
    #コメント
    ws.cell(1,1).comment = Comment("email（スタッフの電子メイル）", "logopt")
    ws.cell(1,2).comment = Comment("秘密鍵（スタッフが決めた秘密の文字列）", "logopt")
    ws.cell(1,3).comment = Comment("優先度（小さい値のスタッフが優先）", "logopt")
    ws.cell(1,4).comment = Comment("スタッフが業務（ジョブ）を遂行できるなら1，それ以外は0", "logopt")
    
    return wb

# %% ../nbs/10shift.ipynb 48
def convert_shift_data(day_json, break_json, staff_json, requirement_json, min_work_periods = 1):
    
    day_df = pd.read_json(day_json)
    period_df = pd.read_json(break_json)
    staff_data = pd.read_json(staff_json)
    req_dic =json.loads(requirement_json)
    requirement_dic ={}
    for d in req_dic:
        df = pd.read_json(req_dic[d])
        requirement_dic[d] = df
    
    day_df.rename(columns={"日":"day", "日タイプ":"day_type"}, inplace=True)
    period_df.rename(columns={"期":"id", "開始時刻":"description", "休憩数": "breaks"}, inplace=True)
    break_df = period_df.iloc[min_work_periods: , :]
    break_df.drop("description", axis=1, inplace=True)
    break_df.rename(columns={"id": "period", "breaks": "break_time"}, inplace =True)
    break_df.reset_index(inplace=True)
    break_df.drop("index", axis=1, inplace=True)
    
    #時刻を入れると期を返す辞書を準備
    period_dic = {d:i for d,i in zip(period_df.description, period_df.id) }
    #日を入れると何日目かを返す辞書を準備
    day_dic ={d:t  for d,t in zip(day_df.day, day_df.index)}

    staff_df = staff_data[ ["ニックネーム", "優先度", "最大稼働期間", "最大出勤日数", "開始時刻", "終了時刻", "日別希望時間"] ]
    job_data = staff_data.iloc[:,13:] #job data
    job_set = []
    for row in job_data.values:
        jobs = []
        for idx, i in enumerate(row):
            if i==1:
                jobs.append(idx+1)
        job_set.append( str(list(jobs))) 
    staff_df["job_set"] = job_set
    
    request = []
    for req in staff_df.日別希望時間:
        if req is None or len(req)==0: 
            request.append(None)
            continue    

        D ={}
        for key in req:
            try:
                D[ day_dic[key] ] = (period_dic.get(req[key][0],0), period_dic.get(req[key][0],period_df.id.max()-1) )
            except KeyError: #対応する日が計画期間内にない
                pass
        if len(D)>=1:
            request.append(str(D))
        else:
            request.append(None)
    staff_df["日別希望時間"] = request

    staff_df.rename(columns={"ニックネーム":"name", "優先度":"wage_per_period", "最大稼働期間": "max_period", 
                             "最大出勤日数":"max_day", "開始時刻":"start", "終了時刻":"end", "日別希望時間":"request"}, inplace=True)

    start_list = [period_dic.get(t,0) for t in staff_df.start ]
    end_list = [period_dic.get(t, period_df.id.max()-1) for t in staff_df.end ]
    staff_df["start"] = start_list
    staff_df["end"] = end_list

    Trans = {"月": "Mon", "火":"Tue", "水":"Wed", "木":"Thu", "金":"Fri", "土": "Sat", "日":"Sun"}
    day_off_list =[]
    for row in staff_data["出勤希望日"]:
        day_on =set([])
        for i in row: #ast.literal_eval(row): #=> day_off
            if i in Trans:
                day_on.add( Trans[i] )
        day_off = [] 
        for i,d in enumerate(day_df.day):
            day = pd.to_datetime(d)
            #print(i, day, day.strftime('%a'))
            if day.strftime('%a') not in day_on:
                day_off.append(i)
        day_off_list.append( str(day_off) )
    staff_df["day_off"] = day_off_list

    #requirement_df : day_type, job, period, requirement
    day_type, job, period, requirement =[],[],[],[]
    for day in requirement_dic:
        for row in requirement_dic[day].itertuples():
            for t, req in enumerate(row[3:]):
                #print(row.業務, t, req)
                day_type.append(day)
                job.append(row.業務+1) #0はbreak
                period.append(t)
                requirement.append(req)
    requirement_df = pd.DataFrame({"day_type": day_type, "job":job, "period":period, "requirement":requirement})
    #requirement_df
    job_list = ["break"]+ list(requirement_dic["Sun"].開始時刻)
    job_df = pd.DataFrame({"id": list(range(len(job_list)))  , "description": job_list} )
    
    return period_df, break_df, day_df, job_df, staff_df, requirement_df 

# %% ../nbs/10shift.ipynb 57
def estimate_requirement(day_df, period_df, job_df, staff_df, requirement_df, days=None):
    
    n_day = len(day_df)
    if days is None:
        days = list( range(n_day) )     
    
    n_job = len(job_df)
    n_period = len(period_df)-1
    work_hours = np.zeros( (n_job,n_day,n_period) )

    for row in staff_df.itertuples():
        job_set = ast.literal_eval(row.job_set) 
        day_off = set( ast.literal_eval(row.day_off) )
        max_period = row.max_period  #最大稼働時間/１日の稼働時間 だけ加算する
        max_day = row.max_day #最大稼働日数/計画期間 だけ加算する．
        ratio = max_period/n_period * max_day/n_day
        #print(ratio)
        for d in range(n_day):
            if d not in day_off:
                for j in job_set:
                    for t in range(row.start, row.end+1):
                        work_hours[j,d,t]+= ratio
                        
    requirement ={}
    for row in requirement_df.itertuples():
        requirement[row.day_type, row.period, row.job] = row.requirement
    req = np.zeros( (n_job, n_day, n_period) )
    for d, row in enumerate(day_df.itertuples()):
        for j in range(1,n_job):
            for t in range(n_period):
                req[j,d,t] += requirement[row.day_type,t,j]
                   
    fig = make_subplots(rows=len(days), cols=n_job-1, shared_xaxes="all", shared_yaxes="all",
                       row_titles=[str(day_df.day.iloc[d]) for d in days], column_titles= [job_df.description.iloc[j] for j in range(1,n_job)] )

    for i,d in enumerate(days):
        for j in range(1,n_job):
            #必要量
            yy = [req[j,d,t] for t in range(n_period)]
            xx = period_df.description
            trace0 = go.Scatter(
                             x=xx,
                             y=yy,
                             mode='lines',
                             line = dict(color='firebrick', width=4, dash='dot'),
                             name="# of staffs required"
                             )
            fig.add_trace(
                trace0,
                row=i+1, col=j
            )
            #割当可能な人数
            trace1 = go.Bar(x=xx,
                         y= [ work_hours[j,d,t] for t in range(n_period)],
                         name="# of staffs",
                         marker_color='gray',
                         opacity = 0.5
                         )

            fig.add_trace(
                trace1,
                row=i+1, col=j
            )
    fig.update_layout(height=1000,title_text=f"# of staffs & lower bound for day {d}: dashed lines=LB, bar=estimated # of staffs", showlegend=False)
    
    return fig

# %% ../nbs/10shift.ipynb 61
def evaluate_violation(violated, x, period_df, day_df, staff_df):
    """
    制約逸脱計算関数 
    """
    n_day  =len(day_df)
    n_period = len(period_df) -1 #最後の期は終了期なので１を減じる
    n_staff =len(staff_df)
    
    cost_name =["total_cost", "staffLBConstr", "staffUBConstr", "changeJobConstr","breakLBConstr","noEarlyBreakConstr","noLateBreakConstr","totalUBConstr"]
    cost_name_ = ["Cost", "Staff Lower Bound", "Staff Upper Bound", "Change Job", "Break Number", "Early Break", "Late Break", "Max Work Day"]
    violation ={cn:0 for cn in cost_name}
    violate = np.zeros( (len(cost_name)-2, len(day_df) ) )
    totalUB = np.zeros( len(staff_df) )
    if violated is not None:
        for v in violated:
            for i, cn in enumerate(cost_name):
                if v[:len(cn)]==cn:
                    violation[cn] += violated[v]
                    #indexを抽出
                    idx = re.split('_|\]|\[', v)
                    if i==0:
                        pass
                    elif i in {3,4,5,6}: #change job, Break Number", "Early Break", "Late Break"
                        violate[i-1, int(idx[2]) ] += violated[v]
                    elif i==7: #total UB
                        totalUB[ int(idx[1]) ] += violated[v]
                    else:
                        violate[i-1, int(idx[1]) ] += violated[v]

    value_list =[ ]
    for cn in cost_name:    
        value_list.append( violation[cn] )
    cost_df = pd.DataFrame({"penalty": cost_name_, "value": value_list})
    violate_df = pd.DataFrame(violate, index= cost_name_[1:-1], columns=[f"Day {d}" for d in range(n_day)])

    #シフトの抽出
    arr=np.empty( (n_staff, n_day) ,dtype=object)
    for i in range(n_staff):
        for d in range(n_day):
            try:
                if x[i,d].value != f"{n_period}_{n_period}":
                    arr[i,d] = x[i,d].value
            except:
                pass
    shift_df = pd.DataFrame(arr, columns =[ f"Shift for Day {d}" for d in range(n_day)])
    new_staff_df = pd.concat([staff_df, shift_df], axis=1)
    new_staff_df["max day violation"] = totalUB
        
    return cost_df, violate_df, new_staff_df

# %% ../nbs/10shift.ipynb 64
def shift_scheduling(period_df, break_df, day_df, job_df, staff_df, requirement_df, theta=1,
                     lb_penalty =10000, ub_penalty=0, job_change_penalty = 10, break_penalty = 10000, max_day_penalty = 5000,
                    OutputFlag=False, TimeLimit=10, random_seed = 1, cloud=False):
    """
    シフト最適化
    """

    #最小稼働期間
    min_work_time = break_df.loc[0, "period"]
    #print("min work time = ", min_work_time)
    n_job = len(job_df)
    n_day  =len(day_df)
    n_period = len(period_df) -1 #最後の期は終了期なので１を減じる
    n_staff =len(staff_df)

    # 要求タイプ、ジョブ、期ごとの必要人数を入れる辞書 requirement を準備
    requirement ={}
    for row in requirement_df.itertuples():
        requirement[row.day_type, row.period, row.job] = row.requirement
        
    # 休日希望日の集合を返す辞書 day_off[i]
    day_off = {}
    for i in range(n_staff):
        day_off[i] = set( ast.literal_eval(staff_df.loc[i, "day_off"]) )

    # スタッフごとに開始時刻と終了時刻の組（パターン）を入れる辞書st_dicを準備（本来ならば日別）
    st_dic = defaultdict(list)
    start, end = {}, {} #スタッフの開始期と終了期
    max_period, max_day ={},{} #最大稼働期間と最大出勤日数
    for i, row in enumerate(staff_df.itertuples()):
        start[i] = int(row.start)
        end[i] = int(row.end)
        max_period[i] = int(row.max_period)
        max_day[i] = int(row.max_day)
        
    for i in range(n_staff):
        st_dic[i].append(f"{n_period}_{n_period}") # 割り当てがないことを表すダミー（費用は0)
        for s in range(start[i], end[i]-min_work_time+1):
            for t in range(s+min_work_time-1, end[i]+1):
                if s + max_period[i] < t:
                    break
                else:
                    st_dic[i].append(f"{s}_{t}")

    # 稼働時間に対する休憩時間数を返す辞書
    break_time = defaultdict(int)
    for t,b in zip(break_df.period, break_df.break_time):
        break_time[int(t)] = int(b)

    #スタッフに割り当て可能なジョブのリストを準備（n_job番目のジョブは割り当てがないことを表すダミー）
    job_set ={}
    for i in range(n_staff):
        job_set[i] = [0] + ast.literal_eval(staff_df.loc[i, "job_set"]) + [n_job]

    model = Model(name="sfift_scop")

    x = {}
    for i in range(n_staff):
        for d in range(n_day):
            if d in day_off[i]:
                continue
            x[i, d] = model.addVariable(name=f"x[{i}_{d}]", domain=st_dic[i])

    y = {}
    for i in range(n_staff):
        for d in range(n_day):
            if d in day_off[i]:
                continue
            for t in range(n_period):
                y[i, d, t] = model.addVariable(
                    name=f"y[{i}_{d}_{t}]", domain=job_set[i])

    #目的関数 
    total_cost = Linear("total_cost",rhs=0, direction="<=", weight=1)
    for i in range(n_staff):
        for d in range(n_day):
            if d in day_off[i]:
                continue
            for st in st_dic[i]:
                s, _ , e = st.partition("_")
                total_cost.addTerms( int((int(e)-int(s))*staff_df.loc[i,"wage_per_period"]), x[i,d], st)
                #print(start,e,st)
    model.addConstraint(total_cost)

    xyConstr = {} #xとyの繋ぎ式
    for i in range(n_staff):
        for d in range(n_day):
            if d in day_off[i]:
                continue
            #if staff.getAvailable_day(day.getID()):
            for t in range(n_period):
                xyConstr[i,d,t] = Linear(f"xyConstr[{i}_{d}_{t}]", rhs=0, direction="=", weight="inf")
                for j in job_set[i][:-1]: #dummyは除く
                    xyConstr[i,d,t].addTerms(1, y[i,d,t], j)
                for st in st_dic[i]:
                    if st==f"{n_period}_{n_period}":
                        continue # dummyは除く
                    s, _, e = st.partition("_")
                    if int(s) <=  t <= int(e):
                        xyConstr[i,d,t].addTerms(-1, x[i,d], st)
                model.addConstraint(xyConstr[i,d,t])
    #print(xyConstr[0,0,0])

    staffLBConstr = {} #スタッフの人数の下限制約
    for d in range(n_day):
        for t in range(n_period):
            for j in range(1,n_job): #最初のジョブは休憩なので除く
                req_type = day_df.loc[d,"day_type"]
                staffLBConstr[d,t,j] = Linear(f"staffLBConstr[{d}_{t}_{j}]",
                                                   rhs= requirement[req_type,t,j], direction=">=")
                for i in range(n_staff):
                    if d in day_off[i]:
                        continue
                    if j in set(job_set[i]):
                            staffLBConstr[d,t,j].addTerms(1, y[i,d,t], j)
                staffLBConstr[d,t,j].setWeight(lb_penalty)
                model.addConstraint(staffLBConstr[d,t,j])

    staffUBConstr = {} #スタッフの人数の上限制約
    for d in range(n_day):
        for t in range(n_period):
            for j in range(1,n_job): #最初のジョブは休憩なので除く
                req_type = day_df.loc[d,"day_type"]
                staffUBConstr[d,t,j] = Linear(f"staffUBConstr[{d}_{t}_{j}]",
                                                   rhs= requirement[req_type,t,j], direction="<=") 
                for i in range(n_staff):
                    if d in day_off[i]:
                        continue
                    if j in set(job_set[i]):
                            staffUBConstr[d,t,j].addTerms(1, y[i,d,t], j)
                staffUBConstr[d,t,j].setWeight(ub_penalty)
                model.addConstraint(staffUBConstr[d,t,j])
                
    changeJobConstr = {} #ジョブ変更のペナルティ
    for i in range(n_staff):
        for d in range(n_day):
            if d in day_off[i]:
                continue
            for t in range(1,n_period):
                for j in job_set[i][1:-1]: #休憩とダミーは除く
                    changeJobConstr[i,d,t,j] = Linear(f"changeJobConstr[{i}_{d}_{t}_{j}]", rhs=0, direction="<=")
                    changeJobConstr[i,d,t,j].addTerms( 1, y[i,d,t], j)
                    changeJobConstr[i,d,t,j].addTerms( -1, y[i,d,t-1], j)
                    changeJobConstr[i,d,t,j].addTerms( -1, y[i,d,t-1], 0 )
                    changeJobConstr[i,d,t,j].addTerms( -1, y[i,d,t-1], n_job ) #dummy 
                    changeJobConstr[i,d,t,j].setWeight(job_change_penalty)
                    model.addConstraint(changeJobConstr[i,d,t,j])

    breakLBConstr = {} #必要な休憩時間数の下限を表す制約
    for i in range(n_staff):
        for d in range(n_day):
            if d in day_off[i]:
                continue
            breakLBConstr[i,d] = Linear(f"breakLBConstr[{i}_{d}]", rhs=0, direction="=")
            for t in range(n_period):
                breakLBConstr[i,d].addTerms(1, y[i,d,t], 0) #0は休憩
            for st in st_dic[i]:
                s, _ , e = st.partition("_")
                breakLBConstr[i,d].addTerms(-1*int(break_time[int(e)- int(s)+1]), x[i,d], st)
            breakLBConstr[i,d].setWeight("inf")
            model.addConstraint(breakLBConstr[i,d])

    if theta >=1:
        noEarlyBreakConstr = {} #開始直後からtheta期は休憩を入れない
        for i in range(n_staff):
            for d in range(n_day):
                if d in day_off[i]:
                    continue
                
                for t in range(start[i],end[i]+1):  #スタッフiの開始・終了期    
                    noEarlyBreakConstr[i,d,t] = Linear(f"noEarlyBreakConstr[{i}_{d}_{t}]", rhs=theta, direction="<=")
                    
                    #右辺のx[idst]
                    no_x = True
                    for st in st_dic[i]:
                        s, _ , e = st.partition("_")
                        if int(s) == t:
                            noEarlyBreakConstr[i,d,t].addTerms(theta, x[i,d], st)
                            no_x = False
                    if no_x: #右辺のｘがない
                        break #それより遅いtだと見込みがないので終わって良い
                    
                    #左辺のｙ[i,d,k,r]
                    for k in range(t,t+theta):
                        noEarlyBreakConstr[i,d,t].addTerms(1, y[i,d,k], 0)

                    noEarlyBreakConstr[i,d,t].setWeight(break_penalty)
                    model.addConstraint(noEarlyBreakConstr[i,d,t])

        noLateBreakConstr = {} #終了直前のtheta期は休憩を入れない
        for i in range(n_staff):
            for d in range(n_day):
                if d in day_off[i]:
                    continue
                for t in range(end[i],start[i]-1,-1):  #スタッフiの開始・終了期（後ろから探索） 
                    noLateBreakConstr[i,d,t] = Linear(f"noLateBreakConstr[{i}_{d}_{t}]", rhs=theta, direction="<=")
                        
                    no_x = True
                    for st in st_dic[i]:
                        s, _ , e = st.partition("_")
                        if int(e) == t:
                            noLateBreakConstr[i,d,t].addTerms(theta, x[i,d], st)
                            no_x = False
                    if no_x:
                        break #今より早いtだと見込みがないので終わる．

                    for k in range(t-theta+1,t+1):
                        noLateBreakConstr[i,d,t].addTerms(1, y[i,d,k], "0")

                    noLateBreakConstr[i,d,t].setWeight(break_penalty)
                    model.addConstraint(noLateBreakConstr[i,d,t])

    totalUBConstr = {} #総稼働期間の上限制約
    for i in range(n_staff):
        totalUBConstr[i] = Linear(f"totalUBConstr[{i}]",rhs= max_day[i], direction="<=")
        for d in range(n_day):
            if d in day_off[i]:
                continue
            for st in st_dic[i]:
                if st != f"{n_period}_{n_period}": #ダミーのシフト
                    totalUBConstr[i].addTerms( 1, x[i,d], st)
        totalUBConstr[i].setWeight(max_day_penalty)
        model.addConstraint(totalUBConstr[i])

    model.Params.TimeLimit = TimeLimit
    model.Params.OutputFlag = OutputFlag
    model.Params.RandomSeed = random_seed

    sol, violated = model.optimize(cloud=cloud)
    
    #cost_df = evaluate_violation(violated)
    cost_df, violate_df, new_staff_df = evaluate_violation(violated, x, period_df, day_df, staff_df)
    
    #yの情報の保管（辞書のキーはJSONに変換できるように文字列にしておく）
    job_assign = {}
    for (i,d,t) in y:
        val_ = int(y[i,d,t].value )
        if  val_ != n_job:
            #print(i,d,t,val_)
            job_assign[ str( (i,d,t) ) ] = val_ 
            
    return cost_df, violate_df, new_staff_df, job_assign, model.Status

# %% ../nbs/10shift.ipynb 66
def shift_scheduling2(period_df, break_df, day_df, job_df, staff_df, requirement_df, theta=1,
                     lb_penalty =10000, ub_penalty=0, job_change_penalty = 10, break_penalty = 10000, max_day_penalty = 5000,
                    OutputFlag=False, TimeLimit=10, random_seed = 1, cloud=False):
    """
    シフト最適化（スタッフが日毎に開始希望時刻と終了希望時刻を入れられるように変更）
    """

    #最小稼働期間
    min_work_time = break_df.loc[0, "period"]
    #print("min work time = ", min_work_time)
    n_job = len(job_df)
    n_day  =len(day_df)
    n_period = len(period_df) -1 #最後の期は終了期なので１を減じる
    n_staff =len(staff_df)

    # 要求タイプ、ジョブ、期ごとの必要人数を入れる辞書 requirement を準備
    requirement ={}
    for row in requirement_df.itertuples():
        requirement[row.day_type, row.period, row.job] = row.requirement
        
    # 休日希望日の集合を返す辞書 day_off[i]
    day_off = {}
    for i in range(n_staff):
        day_off[i] = set( ast.literal_eval(staff_df.loc[i, "day_off"]) )

    # スタッフごとに開始時刻と終了時刻の組（パターン）を入れる辞書st_dic[スタッフ,日] を準備

    start, end = {}, {} #スタッフの開始期と終了期（既定値）
    max_period, max_day ={},{} #最大稼働期間と最大出勤日数
    for i, row in enumerate(staff_df.itertuples()):
        start[i] = int(row.start)
        end[i] = int(row.end)
        max_period[i] = int(row.max_period)
        max_day[i] = int(row.max_day)

    st_dic = defaultdict(list)
    for i in range(n_staff):
        for d in range(n_day):
            st_dic[i,d].append(f"{n_period}_{n_period}") # 割り当てがないことを表すダミー（費用は0)
            #request列の辞書を参照
            req = staff_df.loc[i,"request"] 
            if req is None or len(req)==0:
                st_ = start[i]
                en_ = end[i]
            else:
                D = ast.literal_eval(staff_df.loc[i,"request"])
                if d in D:
                    st_, en_ =D[d]
                else:
                    st_ = start[i]
                    en_ = end[i]
            for s in range(st_, en_-min_work_time+1):
                for t in range(s+min_work_time-1, end[i]+1):
                    if s + max_period[i] < t:
                        break
                    else:
                        st_dic[i,d].append(f"{s}_{t}")

    # 稼働時間に対する休憩時間数を返す辞書
    break_time = defaultdict(int)
    for t,b in zip(break_df.period, break_df.break_time):
        break_time[int(t)] = int(b)

    #スタッフに割り当て可能なジョブのリストを準備（n_job番目のジョブは割り当てがないことを表すダミー）
    job_set ={}
    for i in range(n_staff):
        job_set[i] = [0] + ast.literal_eval(staff_df.loc[i, "job_set"]) + [n_job]

    model = Model(name="sfift_scop")

    x = {}
    for i in range(n_staff):
        for d in range(n_day):
            if d in day_off[i]:
                continue
            x[i, d] = model.addVariable(name=f"x[{i}_{d}]", domain=st_dic[i,d])

    y = {}
    for i in range(n_staff):
        for d in range(n_day):
            if d in day_off[i]:
                continue
            for t in range(n_period):
                y[i, d, t] = model.addVariable(
                    name=f"y[{i}_{d}_{t}]", domain=job_set[i])

    #目的関数 
    total_cost = Linear("total_cost",rhs=0, direction="<=", weight=1)
    for i in range(n_staff):
        for d in range(n_day):
            if d in day_off[i]:
                continue
            for st in st_dic[i,d]:
                s, _ , e = st.partition("_")
                total_cost.addTerms( int((int(e)-int(s))*staff_df.loc[i,"wage_per_period"]), x[i,d], st)
                #print(start,e,st)
    model.addConstraint(total_cost)

    xyConstr = {} #xとyの繋ぎ式
    for i in range(n_staff):
        for d in range(n_day):
            if d in day_off[i]:
                continue
            #if staff.getAvailable_day(day.getID()):
            for t in range(n_period):
                xyConstr[i,d,t] = Linear(f"xyConstr[{i}_{d}_{t}]", rhs=0, direction="=", weight="inf")
                for j in job_set[i][:-1]: #dummyは除く
                    xyConstr[i,d,t].addTerms(1, y[i,d,t], j)
                for st in st_dic[i,d]:
                    if st==f"{n_period}_{n_period}":
                        continue # dummyは除く
                    s, _, e = st.partition("_")
                    if int(s) <=  t <= int(e):
                        xyConstr[i,d,t].addTerms(-1, x[i,d], st)
                model.addConstraint(xyConstr[i,d,t])
    #print(xyConstr[0,0,0])

    staffLBConstr = {} #スタッフの人数の下限制約
    for d in range(n_day):
        for t in range(n_period):
            for j in range(1,n_job): #最初のジョブは休憩なので除く
                req_type = day_df.loc[d,"day_type"]
                staffLBConstr[d,t,j] = Linear(f"staffLBConstr[{d}_{t}_{j}]",
                                                   rhs= requirement[req_type,t,j], direction=">=")
                for i in range(n_staff):
                    if d in day_off[i]:
                        continue
                    if j in set(job_set[i]):
                            staffLBConstr[d,t,j].addTerms(1, y[i,d,t], j)
                staffLBConstr[d,t,j].setWeight(lb_penalty)
                model.addConstraint(staffLBConstr[d,t,j])

    staffUBConstr = {} #スタッフの人数の上限制約
    for d in range(n_day):
        for t in range(n_period):
            for j in range(1,n_job): #最初のジョブは休憩なので除く
                req_type = day_df.loc[d,"day_type"]
                staffUBConstr[d,t,j] = Linear(f"staffUBConstr[{d}_{t}_{j}]",
                                                   rhs= requirement[req_type,t,j], direction="<=") 
                for i in range(n_staff):
                    if d in day_off[i]:
                        continue
                    if j in set(job_set[i]):
                            staffUBConstr[d,t,j].addTerms(1, y[i,d,t], j)
                staffUBConstr[d,t,j].setWeight(ub_penalty)
                model.addConstraint(staffUBConstr[d,t,j])
                
    changeJobConstr = {} #ジョブ変更のペナルティ
    for i in range(n_staff):
        for d in range(n_day):
            if d in day_off[i]:
                continue
            for t in range(1,n_period):
                for j in job_set[i][1:-1]: #休憩とダミーは除く
                    changeJobConstr[i,d,t,j] = Linear(f"changeJobConstr[{i}_{d}_{t}_{j}]", rhs=0, direction="<=")
                    changeJobConstr[i,d,t,j].addTerms( 1, y[i,d,t], j)
                    changeJobConstr[i,d,t,j].addTerms( -1, y[i,d,t-1], j)
                    changeJobConstr[i,d,t,j].addTerms( -1, y[i,d,t-1], 0 )
                    changeJobConstr[i,d,t,j].addTerms( -1, y[i,d,t-1], n_job ) #dummy 
                    changeJobConstr[i,d,t,j].setWeight(job_change_penalty)
                    model.addConstraint(changeJobConstr[i,d,t,j])

    breakLBConstr = {} #必要な休憩時間数の下限を表す制約
    for i in range(n_staff):
        for d in range(n_day):
            if d in day_off[i]:
                continue
            breakLBConstr[i,d] = Linear(f"breakLBConstr[{i}_{d}]", rhs=0, direction="=")
            for t in range(n_period):
                breakLBConstr[i,d].addTerms(1, y[i,d,t], 0) #0は休憩
            for st in st_dic[i,d]:
                s, _ , e = st.partition("_")
                breakLBConstr[i,d].addTerms(-1*int(break_time[int(e)- int(s)+1]), x[i,d], st)
            breakLBConstr[i,d].setWeight("inf")
            model.addConstraint(breakLBConstr[i,d])

    if theta >=1:
        noEarlyBreakConstr = {} #開始直後からtheta期は休憩を入れない
        for i in range(n_staff):
            for d in range(n_day):
                if d in day_off[i]:
                    continue
                
                for t in range(start[i],end[i]+1):  #スタッフiの開始・終了期    
                    noEarlyBreakConstr[i,d,t] = Linear(f"noEarlyBreakConstr[{i}_{d}_{t}]", rhs=theta, direction="<=")
                    
                    #右辺のx[idst]
                    no_x = True
                    for st in st_dic[i,d]:
                        s, _ , e = st.partition("_")
                        if int(s) == t:
                            noEarlyBreakConstr[i,d,t].addTerms(theta, x[i,d], st)
                            no_x = False
                    if no_x: #右辺のｘがない
                        break #それより遅いtだと見込みがないので終わって良い
                    
                    #左辺のｙ[i,d,k,r]
                    for k in range(t,t+theta):
                        noEarlyBreakConstr[i,d,t].addTerms(1, y[i,d,k], 0)

                    noEarlyBreakConstr[i,d,t].setWeight(break_penalty)
                    model.addConstraint(noEarlyBreakConstr[i,d,t])

        noLateBreakConstr = {} #終了直前のtheta期は休憩を入れない
        for i in range(n_staff):
            for d in range(n_day):
                if d in day_off[i]:
                    continue
                for t in range(end[i],start[i]-1,-1):  #スタッフiの開始・終了期（後ろから探索） 
                    noLateBreakConstr[i,d,t] = Linear(f"noLateBreakConstr[{i}_{d}_{t}]", rhs=theta, direction="<=")
                        
                    no_x = True
                    for st in st_dic[i,d]:
                        s, _ , e = st.partition("_")
                        if int(e) == t:
                            noLateBreakConstr[i,d,t].addTerms(theta, x[i,d], st)
                            no_x = False
                    if no_x:
                        break #今より早いtだと見込みがないので終わる．

                    for k in range(t-theta+1,t+1):
                        noLateBreakConstr[i,d,t].addTerms(1, y[i,d,k], "0")

                    noLateBreakConstr[i,d,t].setWeight(break_penalty)
                    model.addConstraint(noLateBreakConstr[i,d,t])

    totalUBConstr = {} #総稼働期間の上限制約
    for i in range(n_staff):
        totalUBConstr[i] = Linear(f"totalUBConstr[{i}]", rhs= max_day[i], direction="<=")
        for d in range(n_day):
            if d in day_off[i]:
                continue
            for st in st_dic[i,d]:
                if st != f"{n_period}_{n_period}": #ダミーのシフト
                    totalUBConstr[i].addTerms( 1, x[i,d], st)
        totalUBConstr[i].setWeight(max_day_penalty)
        model.addConstraint(totalUBConstr[i])

    model.Params.TimeLimit = TimeLimit
    model.Params.OutputFlag = OutputFlag
    model.Params.RandomSeed = random_seed

    sol, violated = model.optimize(cloud=cloud)
    
    #cost_df = evaluate_violation(violated)
    cost_df, violate_df, new_staff_df = evaluate_violation(violated, x, period_df, day_df, staff_df)
    
    #yの情報の保管（辞書のキーはJSONに変換できるように文字列にしておく）
    job_assign = {}
    for (i,d,t) in y:
        val_ = int(y[i,d,t].value )
        if  val_ != n_job:
            #print(i,d,t,val_)
            job_assign[ str( (i,d,t) ) ] = val_ 
            
    return cost_df, violate_df, new_staff_df, job_assign, model.Status

# %% ../nbs/10shift.ipynb 79
def make_gannt_excel(job_assign, period_df, day_df, job_df, staff_df, requirement_df):
    LEFTSPACE = 2 #Excelの左の空白数

    # 要求タイプ、ジョブ、期ごとの必要人数を入れる辞書 requirement を準備
    requirement ={}
    for row in requirement_df.itertuples():
        requirement[row.day_type, row.period, row.job] = row.requirement

    n_staff = len(staff_df)
    n_day = len(day_df)
    n_period = len(period_df)-1
    n_job = len(job_df)
    
    #割り当てジョブを配列に入れる
    job_array = np.zeros(shape=(n_staff, n_day, n_period), dtype=int)
    for idx_str in job_assign:
        #i,d,t = map(int, idx_str[1:-1].split(",")) 
        i,d,t = ast.literal_eval(idx_str)
        job_array[i,d,t] = job_assign[idx_str]

    wb = Workbook()
    ws0 = wb.active
    wb.remove(ws0)
    for day in range(n_day):
        ws = wb.create_sheet(title= day_df.day[day]) #日付に変換
        data = job_array[:,day,:]
        ws.append([""]*LEFTSPACE + list(period_df.description[:-1]))
        #スタッフごとのジョブデータをシートに追加
        for i, row in enumerate(list(data)):
            ws.append([i , staff_df.name[i] ] + list(row))

        ws.append(["人数","期"] + [t for t in range(n_period)]) #散布図にするため期にする
        #ws.append(["人数","時刻"] + list(period_df.description[:-1]))
        #ジョブのカウントを計算するためのセルを追加
        for j in range(1,n_job):
            for col in range(LEFTSPACE+1, LEFTSPACE + n_period +1):
                cell = ws.cell(n_staff+2+j, col)
                col_name = cell.column_letter #列名を抽出
                cell.value = f"=COUNTIF({col_name}2:{col_name}{n_staff+1},{j})" 
        #ジョブの名前と番号を1,2列に追加
        for j in range(1,n_job):
            cell = ws.cell(n_staff+2+j, 1)
            cell.value = j
            cell = ws.cell(n_staff+2+j, 2)
            cell.value = job_df.description[j]
        #必要人数の追加
        req_type = day_df.loc[day,"day_type"]
        ws.append(["必要人数"])
        for j in range(1,n_job):
            ws.append( [j, str(job_df.description[j])+" 下限"] + [requirement[req_type,t,j] for t in range(n_period) ] )  
        #Tableの定義
        tab = Table(displayName=f"Table{day}", ref= f"C1:{col_name}{n_staff+1}")
        style = TableStyleInfo(name="TableStyleMedium9", showFirstColumn=False,
                               showLastColumn=False, showRowStripes=True, showColumnStripes=False)
        tab.tableStyleInfo = style
        ws.add_table(tab)

        #チャートの描画
        for j in range(1, n_job):
            c1 = ScatterChart()
            c1.title = "必要人数チャート"
            c1.style = 13
            c1.y_axis.title = '人数'
            c1.x_axis.title = '期'
            xvalues = Reference(ws, min_col=LEFTSPACE+1, min_row=n_staff+2, max_col=LEFTSPACE+n_period)
            yvalues1 = Reference(ws, min_col=LEFTSPACE, min_row=n_staff+2+j, max_col=LEFTSPACE+n_period)
            series1 = Series(yvalues1, xvalues, title_from_data=True)
            series1.marker.symbol = "triangle"
            series1.marker.graphicalProperties.solidFill = "FF0000" # Marker filling
            series1.marker.graphicalProperties.line.solidFill = "FF0000" # Marker outline
            series1.graphicalProperties.line.noFill = True
            c1.series.append(series1)
            yvalues2 = Reference(ws, min_col=LEFTSPACE, min_row=n_staff+2+j+n_job, max_col=LEFTSPACE+n_period)
            series2 = Series(yvalues2, xvalues, title_from_data=True)
            series2.graphicalProperties.line.solidFill = "00AAAA"
            series2.graphicalProperties.line.dashStyle = "sysDot"
            series2.graphicalProperties.line.width = 100050 # width in EMUs
            #series2.smooth = True # Make the line smooth
            c1.series.append(series2)
            ws.add_chart(c1, f"A{n_staff+n_job*2+5 + (j-1)*20}")
    return wb

# %% ../nbs/10shift.ipynb 83
def make_allshift_excel(new_staff_df, day_df, period_df):
    n_day = len(day_df)
    n_staff = len(new_staff_df)
    
    #period_dic = {d:i for d,i in zip(period_df.description, period_df.id) } #逆写像も作る！
    period_dic = {i:d for d,i in zip(period_df.description, period_df.id) } #ID => 時刻
    
    LEFTSPACE = 2
    shift = new_staff_df.iloc[:,9:-1]
    wb = Workbook()
    ws = wb.active 
    data =[]
    for row in shift.values:
        L1, L2, L3 = [], [], []
        for j in row:
            if j is None:
                L1.append("")
                L2.append("")
                L3.append(0)
            else:
                s,f = map(int, j.split("_"))
                L1.append( period_dic[s])
                L2.append( period_dic[f])
                L3.append(f-s)
        data.append(L1)
        data.append(L2)
        data.append(L3)
    ws.append([""]*LEFTSPACE + [day_df.day[d] for d in range(n_day)]+["合計"]) #日付に変換 
    #シフトデータ出力
    for i, row in enumerate(list(data)):
        if i%3==0:
            ws.append([i//3 , new_staff_df.name[i//3] ] + row)
        else:
            ws.append([ "", ""] + row)

    # n_day+6列目に行の和の関数を代入
    for i in range(n_staff):
        row = 4 + i*3
        cell = ws.cell(row, LEFTSPACE+n_day+1)
        last_column = ws.cell(1,LEFTSPACE+n_day).column_letter
        cell.value = f"=SUM(C{row}:{last_column}{row})" 
            
    #Tableの定義
    tab = Table(displayName=f"ShiftTable", ref= f"C1:{last_column}{n_staff*3+1}")
    style = TableStyleInfo(name="TableStyleMedium9")
    tab.tableStyleInfo = style
    ws.add_table(tab)
    return wb

# %% ../nbs/10shift.ipynb 89
def make_requirement_graph(day_df, period_df, job_df, staff_df, requirement_df, job_assign, day=0):
    """
    必要人数のグラフを生成する関数
    """

    n_day = len(day_df)
    n_period = len(period_df)-1
    n_job = len(job_df)
    n_staff = len(staff_df)

    req_type = day_df.loc[day,"day_type"]
    
    # 要求タイプ、ジョブ、期ごとの必要人数を入れる辞書 requirement を準備
    requirement ={}
    for row in requirement_df.itertuples():
        requirement[row.day_type, row.period, row.job] = row.requirement
        
    # 休日希望日の集合を返す辞書 day_off[i]
    day_off = {}
    for i in range(n_staff):
        day_off[i] = set( ast.literal_eval(staff_df.loc[i, "day_off"]) )
    
    y = {}
    for key in job_assign:
        tpl = ast.literal_eval(key)
        y[tpl] = job_assign[key]
        
    #人数の計算
    val = np.zeros((n_day,n_period,n_job+1),int)
    for d in range(n_day):
        for t in range(n_period):
            for i in range(n_staff):
                if d in day_off[i]:
                    continue
                j = int(y.get( (i,d,t), 0) )
                #print(i,d,t,"=",j)
                val[d,t,j] += 1

    fig = make_subplots(rows=n_job-1, cols=1, subplot_titles= [job_df.description.iloc[j] for j in range(1,n_job)] )
    for j in range(1,n_job):

        yy = [requirement[req_type,t,j] for t in range(n_period)]
        xx = period_df.description

        trace0 = go.Scatter(x=xx,
                         y=yy,
                         mode='lines',
                         #marker=dict(
                         #   size=30, color="blue", opacity=0.8
                         #),
                         line = dict(color='firebrick', width=4, dash='dot'),
                         name="# of staffs required"
                         )
        #    print(s,d,t,day,y[s,d,t].value,job)
        trace1 = go.Bar(x=xx,
                     y=val[day,:,j],
                     name="# of staffs",
                     marker_color='gray',
                     opacity = 0.5
                     )

        fig.add_trace(
            trace0,
            row=j, col=1
        )
        fig.add_trace(
            trace1,
            row=j, col=1
        )
    #fig.update_layout(height=1000,title_text=f"Number of staffs and lower bound for day {day}", showlegend=False)
    fig.update_layout(height=1000, showlegend=False)


    return fig

# %% ../nbs/10shift.ipynb 94
def make_gannt_for_shift(day_df, period_df, staff_df, job_df, job_assign, day=0 ):
    """
    スタッフごとのガントチャートを生成する関数
    """
    n_period = len(period_df)-1
    n_job = len(job_df)
    n_staff = len(staff_df)
    #変数yの準備
    y = {}
    for key in job_assign:
        tpl = ast.literal_eval(key)
        y[tpl] = job_assign[key]
        
    # 休日希望日の集合を返す辞書 day_off[i]
    day_off = {}
    for i in range(n_staff):
        day_off[i] = set( ast.literal_eval(staff_df.loc[i, "day_off"]) )
        
    # 日dと期tに対してdatetime型を返す辞書を準備
    dt_dic = { }
    for d, day_ in enumerate(day_df["day"]):
        for t, time_ in enumerate(period_df["description"]):
            dt_dic[d, t] = pd.to_datetime(str(day_) + " " + str(time_) )

    L = []
    for i, staff in enumerate(staff_df["name"]):
        if day in day_off[i]:
            continue

        #print()
        #print(i,staff)
        #print(x[i,day].value)

        Task = []  #job name, start period, finish period
        j_prev = None
        for t in range(n_period+1):
            if t == n_period:
                #番兵を配置
                j = n_job
            else:
                j = int(y.get( (i,day,t), n_job) )
            #print(j, end=" ")

            if j == n_job: #ダミーのジョブ or 休憩
                if j_prev==None:
                    continue
                else:
                    # final task
                    Task.append( (j_prev, start_period, t) )
                    break

            if j_prev == None:         # first non-zero period
                start_period = t
                j_prev = j
                #print("start=",t,j_prev)
                continue

            if j == j_prev: #continues jobs
                j_prev = j
            else:
                # non-continuous jobs
                #print(t,j_prev,j)
                Task.append( (j_prev, start_period, t) )
                j_prev = j
                start_period = t

        #print(Task)
        for j,st,fi in Task:
            L.append(dict(Task= staff_df["name"].iloc[i], Start=dt_dic[d,st],
                                         Finish= dt_dic[d,fi], Resource= job_df["description"].iloc[j]))

    # 可視化するデータと色の情報をplotly.figure_factory.create_gantt()に渡す
    fig = ff.create_gantt(L, title="Gannt Chart", index_col='Resource',
                          show_colorbar=True, showgrid_x=True, showgrid_y=True, group_tasks=True)
    return fig

# %% ../nbs/10shift.ipynb 99
def plot_scop_for_shift(file_name: str="scop_out.txt"):
    with open(file_name) as f:
        out = f.readlines()
    x, y1, y2 = [],[],[] 
    for l in out[5:]: 
        sep = re.split("[=()/]", l)
        if sep[0] != 'penalty ':
            break
        hard, soft, cpu = map(float, [ sep[1], sep[2], sep[6]])
        x.append(cpu)
        y1.append(hard)
        y2.append(soft)
    fig = go.Figure()
    fig.add_trace(go.Scatter(
            x = x, 
            y = y1,
            mode='markers+lines',
            name= "hard",
            marker=dict(
                size=10,
                color= "red")
    ))
    fig.add_trace(go.Scatter(
            x = x, 
            y = y2,
            name ="soft",
            mode='markers+lines',
            marker=dict(
                size=8,
                color= "blue")
    ))
    fig.update_layout(title = "SCOP performance",
                   xaxis_title='CPU time',
                   yaxis_title='Penalty')
    return fig
