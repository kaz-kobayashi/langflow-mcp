"""サービスネットワーク設計 SENDO (SErvice Network Design Optimizer)"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/12snd.ipynb.

# %% auto 0
__all__ = ['folder', 'mapbox_access_token', 'k_th_sp', 'sndp', 'add_shortest_paths', 'make_result', 'draw_snd_all', 'solve_sndp']

# %% ../nbs/12snd.ipynb 3
import pandas as pd
import random
import math
import numpy as np
import networkx as nx
from geopy.distance import great_circle as distance

import sys
sys.path.append('..')
from pulp import PULP_CBC_CMD
from .mypulp import  GRB, quicksum, Model

#from gurobipy import Model, GRB, quicksum
import plotly.graph_objs as go
import plotly.express as px
import plotly
from collections import OrderedDict, defaultdict
folder = "./data/"

mapbox_access_token = 'pk.eyJ1IjoibWlraW9rdWJvIiwiYSI6ImNqYXQ3dHBqdzR5ZGwyd3BkeG5rOTl0b2UifQ.1utsXNi2V-WdzfWlvCMj_A'

# %% ../nbs/12snd.ipynb 13
def k_th_sp(G, source, sink, k, weight="weight"):
    """
    Find k-th shortest paths and returns path and its cost
    """
    cost_list, path_list = [], []
    for i, p in enumerate(nx.shortest_simple_paths(G, source, sink, weight=weight)):
        if i >= k:
            break
        v = p[0]
        cost = 0.
        for w in p[1:]:
            cost += G[v][w]["weight"]
            v = w
        cost_list.append( cost )
        path_list.append( tuple(p))
    return cost_list, path_list

# %% ../nbs/12snd.ipynb 15
def sndp(K, all_paths, paths, path_id, path_od, paths_through, Demand, Distance,
         transfer_cost, capacity, relax = False, cpu=10.):
    """
    サービスネットワーク設計問題に対するパス型のモデル
    """
    m = Model()
    x, y = {}, {}
    for (i,j) in K:
        if relax:
            y[i,j]= m.addVar(name="y[{0},{1}]".format(i,j), vtype="C")
        else:
            y[i,j]= m.addVar(name="y[{0},{1}]".format(i,j), vtype="I") #トラックの台数
    for p, i in path_id.items():
        x[i]= m.addVar(name="x[{0}]".format(i),vtype="B")
    total_transfer_cost = m.addVar(name="total_transfer_cost", vtype="C")
    total_vehicle_cost =  m.addVar(name="total_vehicle_cost", vtype="C")
        
    m.update()
    #パスごとの積替え費用の準備
    trans_cost ={} 
    for (o,d) in K:
        for p in paths[o,d]:
            sum_tc = 0.
            for i in  p:   #p[1:-1]: 最初と最後の積替えを除く場合
                sum_tc += transfer_cost[i]
            trans_cost[p] = sum_tc
            
    #目的関数
    m.setObjective( total_transfer_cost+ total_vehicle_cost, GRB.MINIMIZE )
    m.addConstr( total_transfer_cost == quicksum(Demand[o,d]* trans_cost[p] * x[ path_id[p] ] for (o,d) in K for p in paths[o,d] ) ) 
    m.addConstr( total_vehicle_cost == quicksum(Distance[i,j]*y[i,j] for (i,j) in y ) )
        
    for (o,d) in K:
        m.addConstr( quicksum( x[ path_id[p] ] for p in paths[o,d] ) == 1 )
    for (i,j) in K:
        m.addConstr( quicksum(Demand[path_od[p][0],path_od[p][1]] * x[path_id[p]] for p in paths_through[i,j])  <= capacity*y[i,j] )
    # 後続パスを用いた入木制約
    intree_const = {}
    for p in all_paths:
        if len(p)>=3:
            intree_const[path_id[p], path_id[p[1:] ]] = m.addConstr( x[path_id[p]]  <= x[path_id[p[1:]]] )
            #intree_const[path_id[p], path_id[p[1:] ]].Lazy = 3
    #Gurobiの場合
    #m.Params.Heuristics = 0.8
    #m.Params.OutputFlag = 0
    #m.Params.TIME_LIMIT = cpu
    #m.optimize()

    # mypulpの場合
    solver = PULP_CBC_CMD(timeLimit=cpu, presolve=True)
    m.optimize(solver)
    #print("obj fun. val. =", m.ObjVal)
    m.__data = x, y, total_transfer_cost, total_vehicle_cost 
    return m

# %% ../nbs/12snd.ipynb 16
def  add_shortest_paths(G, K, all_paths, paths, path_id, path_od, paths_through, k=1):
    """
    各地点間の第k最短路を計算し、追加する関数
    """
    def add_path(p,o,d):
        """
        入木制約を満たすために後続のパスを再帰的に追加する関数
        """
        if len(p)<=2 or p in paths[o,d]:
            return
        paths[o, d].add(p)
        path_od[p] =(o,d)
        all_paths.add(p)
        path_id[p] = len(all_paths)
        v = p[0]
        for w in p[1:]:
            paths_through[(v,w)].add(p)
            v = w
        add_path(p[1:],p[1],d)

    for (o, d) in K:
        cost, path = k_th_sp(G, o, d, k)
        for p in path:
            add_path(p,o,d)

# %% ../nbs/12snd.ipynb 18
def make_result(Demand, cust_df, K, paths, path_id, path_od, paths_through, x, y):
    n = len(cust_df)
    cust_name = cust_df.name.values
    origin, destin, od_path = [],[],[]
    for o in range(n):
        for d in range(n):
            if d==o:
                continue
            origin.append(cust_name[o])
            destin.append(cust_name[d])

            for p in paths[o,d]:
                 if x[path_id[p]].X > 0.1:
                    path_list = []
                    for v in p:
                        path_list.append( cust_name[v] )
            od_path.append( path_list )
    path_df = pd.DataFrame({"origin":origin, "destination":destin, "path":od_path})
    
    head, tail, flow, number = [],[],[],[]
    head_id, tail_id = [], []
    for (v,w) in K:
        if y[v,w].X > 0.1:
            head_id.append(v)
            tail_id.append(w)
            head.append( cust_name[v] )
            tail.append( cust_name[w] )
            number.append( y[v,w].X )
            flow.append( sum(Demand[path_od[p][0],path_od[p][1]] * x[path_id[p]].X for p in paths_through[v,w]) )
            
    vehicle_df = pd.DataFrame({"from_id": head_id, "to_id": tail_id, "from":head, "to":tail, "flow": flow, "number": number})

    return path_df, vehicle_df

# %% ../nbs/12snd.ipynb 20
def draw_snd_all(dc_df, x, y, pos, paths, path_id):
    """
    可視化関数
    """

    n = len(dc_df)
    K = [(i,j) for i in range(n) for j in range(n) if i!=j]

    #ベースの描画
    data = [
        go.Scattermapbox(
            lat=dc_df.lat,
            lon=dc_df.lon,
            mode='markers',
            marker=dict(
                size=20, color="blue", opacity=0.9
            ),
            text=dc_df.name,
            name="DCs"
        ),
    ]

    #運搬車の台数の描画
    edge_trace_lat, edge_trace_lon = [], []
    for (v,w) in K:
        if y[v,w].X > 0.1:
            edge_trace_lat += [pos[v][1], pos[w][1], None]
            edge_trace_lon += [pos[v][0], pos[w][0], None]
    data.append(
            go.Scattermapbox(
                lat=edge_trace_lat,
                lon=edge_trace_lon,
                line=dict(width=5, color="yellow"),
                hoverinfo='none',
                mode='lines',
                name= "Vehicle Movement"
            )
        )
    for d in range(n):
        destination = dc_df.name[d]
        #着地がdのパスの枝を抽出
        edge_trace_lat, edge_trace_lon = [], []
        G_sol = nx.Graph()
        for o in range(n):
            if d==o:
                continue
            for p in paths[o,d]:
                if x[path_id[p]].X > 0.1:
                    v = p[0]
                    for w in p[1:]:
                        G_sol.add_edge(v,w)
                        v = w
        for (v,w) in G_sol.edges():
            edge_trace_lat += [pos[v][1], pos[w][1], None]
            edge_trace_lon += [pos[v][0], pos[w][0], None]

        data.append(
                go.Scattermapbox(
                    lat=edge_trace_lat,
                    lon=edge_trace_lon,
                    line=dict(width=2,color="red"),
                    hoverinfo='none',
                    mode='lines',
                    name= "Paths to "+ str(destination)
                )
            )

    layout = go.Layout(
        autosize=True,
        hovermode='closest',
        mapbox=dict(
            accesstoken=mapbox_access_token,
            bearing=0,
            center=dict(
                lat=35.8573157,
                lon=139.64696
            ),
            pitch=0,
            zoom=5,
            style="dark"  # 'satellite-streets'
        ),
    )
    fig = go.Figure(data=data, layout=layout)
    return fig

# %% ../nbs/12snd.ipynb 22
def solve_sndp(dc_df, od_df, cost_per_dis, cost_per_time, capacity, max_cpu = 10, scaling=True, k=10, alpha=0.5, max_iter = 100, osrm = False):
    """
    サービスネットワーク設計問題を解くための関数
    """    
    n = len(dc_df)
    Demand = od_df.values
    
    transfer_cost = dc_df.vc #積替え費用
    base_capacity = dc_df.ub #ベースの容量（現在は未使用）
    
    #実距離と移動時間
    if osrm:
        durations, distances, node_df = compute_durations(dc_df)
        distances = np.array( distances )/1000.  # m => km 
        durations = np.array( durations )/3600.  # seconds => h
    else:
        distances = np.zeros( (n,n) )
        durations = np.zeros( (n,n) )
        for i, row1 in enumerate(dc_df.itertuples()):
            for j, row2 in enumerate(dc_df.itertuples()):
                distances[i,j] = distance( (row1.lat, row1.lon), (row2.lat,row2.lon) ).km
                durations[i,j] = distances[i,j]/50 #時速50kmを仮定
    
    K = [(i,j) for i in range(n) for j in range(n) if i!=j]
    
    cost = np.zeros ( (n,n) )
    for (i,j) in K:
        cost[i,j] = (distances[i,j]*cost_per_dis + durations[i,j]*cost_per_time) 
                
    G  = nx.DiGraph() #元のグラフ（距離を枝属性として保管）
    pos = { }
    for i, row in enumerate(dc_df.itertuples()):
        G.add_node(i, lat=row.lat, lon=row.lon)
        pos[i] = (G.nodes[i]["lon"],G.nodes[i]["lat"])
    for (i,j) in K:
        G.add_edge(i, j, weight = cost[i,j])

    all_paths = []
    paths = {}
    #path_cost = {}
    path_od ={} #dictionary that maps a path (tuple) to its origin-destination pair (tuple)
    for (o, d) in K:
        cost_, path = k_th_sp(G, o, d, k)
        paths[o, d] = set(path)
        for p in path:
            path_od[p] =(o,d)
        #path_cost[o, d] = cost
        all_paths.extend(path)
    # Dictionary that maps a path (tuple) to the path index
    path_id ={}
    for i, p in enumerate(all_paths):
        path_id[p] = i

    # set of paths through edge (v,w)
    paths_through = defaultdict(set)
    for p in path_id:
        v = p[0]
        for w in p[1:]:
            paths_through[(v,w)].add(p)
            v = w
    #paths_through
    all_paths = set(all_paths) #集合に変換

    #print("# of paths", len(all_paths))

    #勾配スケーリング＋列生成
    CPrime = cost.copy() 
    if scaling:
        for iter_ in range(max_iter):
            model = sndp(K, all_paths, paths, path_id, path_od, paths_through, Demand, CPrime, transfer_cost, capacity, relax = True, cpu=max_cpu)
            if model.Status !=2:  #実行不能 or エラー
                raise SolverError(f"Falied to solve the problem! Status Code is {model.Status}.")
            x,y,_,_ = model.__data
            for (i,j) in K:
                ybar = y[i,j].X
                if ybar>=0.000001:
                    ratio = math.ceil(ybar)/ybar
                    CPrime[i,j] = alpha* cost[i,j]*ratio + (1-alpha) * CPrime[i,j]
                    G[i][j]["weight"] = CPrime[i,j]
                    #print( Cost[i,j], distances[i,j]*ratio, ybar)

            before_ = len(all_paths)
            add_shortest_paths(G, K, all_paths, paths, path_id, path_od, paths_through, k=k)

            #print("# of paths", len(all_paths))
            after_ = len(all_paths)
            if before_ == after_:
                break

    # オリジナルの費用で整数最適化を解く
    model = sndp(K, all_paths, paths, path_id, path_od, paths_through, Demand, cost, transfer_cost, capacity, relax = False, cpu=max_cpu)
    if model.Status != 2:  #実行不能 or エラー
        raise SolverError(f"Falied to solve the problem! Status Code is {model.Status}.")

    x, y, total_transfer_cost, total_vehicle_cost  = model.__data
        
    #結果のデータフレーム作成
    cost_list =[total_transfer_cost.X, total_vehicle_cost.X ]
    cost_name =["transfer", "vehicle"]
    cost_df = pd.DataFrame.from_dict({"cost": cost_name, "value":cost_list})
    
    path_df, vehicle_df = make_result(Demand, dc_df, K, paths, path_id, path_od, paths_through, x, y)
    
    #図作成
    fig = draw_snd_all(dc_df, x, y, pos, paths, path_id)

    return path_df, vehicle_df, cost_df, fig
