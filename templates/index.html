<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Chat Agent</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Alpine.js -->
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>

    <!-- Marked.js for Markdown rendering -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

    <!-- Highlight.js for code syntax highlighting -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11/styles/github.min.css">
    <script src="https://cdn.jsdelivr.net/npm/highlight.js@11/lib/highlight.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/highlight.js@11/lib/languages/json.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/highlight.js@11/lib/languages/python.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/highlight.js@11/lib/languages/javascript.min.js"></script>

    <style>
        [x-cloak] { display: none !important; }

        .message-container {
            scroll-behavior: smooth;
        }

        .typing-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: #6B7280;
            animation: typing 1.4s infinite;
        }

        .typing-indicator:nth-child(2) {
            animation-delay: 0.2s;
        }

        .typing-indicator:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes typing {
            0%, 60%, 100% {
                transform: translateY(0);
                opacity: 0.7;
            }
            30% {
                transform: translateY(-10px);
                opacity: 1;
            }
        }

        .gradient-bg {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        /* Markdown styling */
        .markdown-content {
            line-height: 1.6;
        }

        .markdown-content h1,
        .markdown-content h2,
        .markdown-content h3,
        .markdown-content h4 {
            font-weight: bold;
            margin-top: 1em;
            margin-bottom: 0.5em;
        }

        .markdown-content h1 { font-size: 1.5em; }
        .markdown-content h2 { font-size: 1.3em; }
        .markdown-content h3 { font-size: 1.1em; }

        .markdown-content ul,
        .markdown-content ol {
            margin-left: 1.5em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
        }

        .markdown-content li {
            margin-bottom: 0.25em;
        }

        .markdown-content code {
            background-color: #f3f4f6;
            padding: 0.125rem 0.25rem;
            border-radius: 0.25rem;
            font-family: 'Courier New', monospace;
            font-size: 0.875em;
        }

        .markdown-content pre {
            background-color: #1f2937;
            color: #f9fafb;
            padding: 1rem;
            border-radius: 0.5rem;
            overflow-x: auto;
            margin: 0.5em 0;
        }

        .markdown-content pre code {
            background-color: transparent;
            padding: 0;
            color: inherit;
        }

        .markdown-content a {
            color: #2563eb;
            text-decoration: underline;
        }

        .markdown-content a:hover {
            color: #1d4ed8;
        }

        .markdown-content blockquote {
            border-left: 4px solid #e5e7eb;
            padding-left: 1em;
            margin-left: 0;
            color: #6b7280;
            font-style: italic;
        }

        .markdown-content table {
            border-collapse: collapse;
            width: 100%;
            margin: 0.5em 0;
        }

        .markdown-content table th,
        .markdown-content table td {
            border: 1px solid #e5e7eb;
            padding: 0.5em;
            text-align: left;
        }

        .markdown-content table th {
            background-color: #f3f4f6;
            font-weight: bold;
        }

        /* Code block styling */
        .hljs {
            border-radius: 0.5rem;
            font-size: 0.875em;
        }

        /* User message styling (white text on blue background) */
        .user-message .markdown-content a {
            color: #bfdbfe;
            text-decoration: underline;
        }

        .user-message .markdown-content a:hover {
            color: #dbeafe;
        }

        .user-message .markdown-content code {
            background-color: rgba(255, 255, 255, 0.2);
            color: #ffffff;
        }

        .user-message .markdown-content pre {
            background-color: rgba(0, 0, 0, 0.3);
        }

        /* JSON collapsible styling */
        .json-collapsible {
            border: 1px solid #e5e7eb;
            border-radius: 0.5rem;
            margin: 0.5em 0;
            overflow: hidden;
        }

        .json-collapsible-header {
            background-color: #f3f4f6;
            padding: 0.5rem 1rem;
            cursor: pointer;
            user-select: none;
            font-weight: 500;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .json-collapsible-header:hover {
            background-color: #e5e7eb;
        }

        .json-collapsible-content {
            max-height: 400px;
            overflow-y: auto;
        }

        .json-toggle-icon {
            transition: transform 0.2s;
        }

        .json-toggle-icon.collapsed {
            transform: rotate(-90deg);
        }
    </style>
</head>
<body class="bg-gray-50" x-data="chatApp()" x-init="init()">
    <div class="min-h-screen flex flex-col">
        <!-- Header -->
        <header class="gradient-bg text-white shadow-lg">
            <div class="container mx-auto px-4 py-4 flex justify-between items-center">
                <div>
                    <h1 class="text-2xl font-bold">ü§ñ AI Chat Agent</h1>
                    <p class="text-sm text-gray-200 mt-1">Powered by LLM</p>
                </div>
                <button
                    x-show="!skipAuth"
                    @click="logout()"
                    class="px-4 py-2 bg-white/20 hover:bg-white/30 rounded-lg text-sm font-medium transition-colors"
                >
                    „É≠„Ç∞„Ç¢„Ç¶„Éà
                </button>
            </div>
        </header>

        <!-- Main Chat Container -->
        <main class="flex-1 container mx-auto px-4 py-6 max-w-4xl">
            <!-- Messages Container -->
            <div
                class="message-container bg-white rounded-lg shadow-md p-6 mb-4 h-[calc(100vh-300px)] overflow-y-auto"
                x-ref="messageContainer"
            >
                <template x-if="messages.length === 0">
                    <div class="text-center text-gray-400 mt-20">
                        <svg class="w-16 h-16 mx-auto mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 10h.01M12 10h.01M16 10h.01M9 16H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v8a2 2 0 01-2 2h-5l-5 5v-5z"></path>
                        </svg>
                        <p class="text-lg">‰ºöË©±„ÇíÂßã„ÇÅ„Åæ„Åó„Çá„ÅÜÔºÅ</p>
                    </div>
                </template>

                <template x-for="(message, index) in messages" :key="index">
                    <div
                        class="mb-4 flex"
                        :class="message.role === 'user' ? 'justify-end' : 'justify-start'"
                    >
                        <div
                            class="max-w-[75%] rounded-lg px-4 py-3"
                            :class="message.role === 'user'
                                ? 'bg-gradient-to-r from-blue-500 to-blue-600 text-white user-message'
                                : 'bg-gray-100 text-gray-800'"
                        >
                            <div class="flex items-start gap-2">
                                <span class="text-lg" x-text="message.role === 'user' ? 'üë§' : 'ü§ñ'"></span>
                                <div class="flex-1 markdown-content text-sm" x-html="formatMessage(message.content)"></div>
                            </div>
                        </div>
                    </div>
                </template>

                <!-- Typing Indicator -->
                <template x-if="isLoading">
                    <div class="mb-4 flex justify-start">
                        <div class="max-w-[75%] rounded-lg px-4 py-3 bg-gray-100">
                            <div class="flex items-center gap-2">
                                <span class="text-lg">ü§ñ</span>
                                <div class="flex gap-1">
                                    <span class="typing-indicator"></span>
                                    <span class="typing-indicator"></span>
                                    <span class="typing-indicator"></span>
                                </div>
                            </div>
                        </div>
                    </div>
                </template>
            </div>

            <!-- Input Area -->
            <div class="bg-white rounded-lg shadow-md p-4">
                <form @submit.prevent="sendMessage()" class="flex gap-3">
                    <input
                        type="text"
                        x-model="userInput"
                        :disabled="isLoading"
                        placeholder="„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÂÖ•Âäõ..."
                        class="flex-1 px-4 py-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 disabled:bg-gray-100 disabled:cursor-not-allowed"
                        autocomplete="off"
                    />
                    <button
                        type="submit"
                        :disabled="isLoading || !userInput.trim()"
                        class="px-6 py-3 bg-gradient-to-r from-blue-500 to-blue-600 text-white rounded-lg font-semibold hover:from-blue-600 hover:to-blue-700 disabled:opacity-50 disabled:cursor-not-allowed transition-all"
                    >
                        <span x-show="!isLoading">ÈÄÅ‰ø°</span>
                        <span x-show="isLoading">ÈÄÅ‰ø°‰∏≠...</span>
                    </button>
                </form>

                <!-- Clear Chat Button -->
                <button
                    @click="clearChat()"
                    class="mt-3 text-sm text-gray-500 hover:text-gray-700 underline"
                    x-show="messages.length > 0"
                >
                    „ÉÅ„É£„ÉÉ„ÉàÂ±•Ê≠¥„Çí„ÇØ„É™„Ç¢
                </button>
            </div>
        </main>

        <!-- Footer -->
        <footer class="bg-white border-t py-4">
            <div class="container mx-auto px-4 text-center text-sm text-gray-600">
                <p>AI Chat Agent - FastAPI + Alpine.js + Tailwind CSS</p>
            </div>
        </footer>
    </div>

    <script>
        function chatApp() {
            return {
                messages: [],
                userInput: '',
                isLoading: false,
                modelName: 'qwen2.5:latest', // „Éá„Éï„Ç©„É´„ÉàÂÄ§Ôºà„É≠„Éº„Ç´„É´ÈñãÁô∫Áî®Ôºâ
                skipAuth: false, // Ë™çË®º„Çπ„Ç≠„ÉÉ„Éó„Éï„É©„Ç∞

                async init() {
                    // „Çµ„Éº„Éê„Éº„Åã„ÇâË®≠ÂÆö„ÇíÂèñÂæó
                    try {
                        const response = await fetch('/api/config');
                        if (response.ok) {
                            const config = await response.json();
                            this.modelName = config.model;
                            this.skipAuth = config.skip_auth;
                        }
                    } catch (error) {
                        console.error('Failed to load config:', error);
                    }

                    // Check if user is logged in (unless auth is skipped)
                    if (!this.skipAuth) {
                        const token = localStorage.getItem('token');
                        if (!token) {
                            window.location.href = '/';
                            return;
                        }
                    }

                    // Load messages from localStorage
                    const saved = localStorage.getItem('chatMessages');
                    if (saved) {
                        this.messages = JSON.parse(saved);
                    }
                },

                async sendMessage() {
                    if (!this.userInput.trim() || this.isLoading) return;

                    const userMessage = this.userInput.trim();
                    this.userInput = '';

                    // Add user message
                    this.messages.push({
                        role: 'user',
                        content: userMessage
                    });

                    this.isLoading = true;
                    this.scrollToBottom();

                    try {
                        const token = localStorage.getItem('token');

                        const response = await fetch('/api/chat', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${token}`
                            },
                            body: JSON.stringify({
                                messages: this.messages,
                                model: this.modelName
                            })
                        });

                        if (!response.ok) {
                            throw new Error('API request failed');
                        }

                        const reader = response.body.getReader();
                        const decoder = new TextDecoder();
                        let assistantMessage = '';

                        // Add assistant message placeholder
                        this.messages.push({
                            role: 'assistant',
                            content: ''
                        });

                        while (true) {
                            const { done, value } = await reader.read();
                            if (done) break;

                            const chunk = decoder.decode(value);
                            const lines = chunk.split('\n');

                            for (const line of lines) {
                                if (line.startsWith('data: ')) {
                                    const data = line.slice(6);
                                    if (data === '[DONE]') break;

                                    try {
                                        const parsed = JSON.parse(data);
                                        if (parsed.content) {
                                            assistantMessage += parsed.content;
                                            this.messages[this.messages.length - 1].content = assistantMessage;
                                            this.scrollToBottom();
                                        } else if (parsed.function_call) {
                                            // Function callÁµêÊûú„ÇíË°®Á§∫
                                            const funcName = parsed.function_call.name;
                                            const funcResult = parsed.function_call.result;

                                            let funcDisplay = `\n\nüîß **${funcName}„ÇíÂÆüË°å„Åó„Åæ„Åó„Åü**\n\n`;

                                            // Check if result contains visualization URL or ID
                                            if (funcResult.visualization_url) {
                                                const vizUrl = funcResult.visualization_url;
                                                const message = funcResult.message || 'ÂèØË¶ñÂåñÁµêÊûú„ÇíË°®Á§∫';
                                                funcDisplay += `üìä ${message}\nüîó [ÂèØË¶ñÂåñ„ÇíÈñã„Åè](${vizUrl})\n\n`;
                                            } else if (funcResult.visualization_id) {
                                                const vizId = funcResult.visualization_id;
                                                const vizUrl = `/api/visualization/${vizId}`;
                                                const message = funcResult.message || 'ÂèØË¶ñÂåñÁµêÊûú„ÇíË°®Á§∫';
                                                funcDisplay += `üìä ${message}\nüîó [ÂèØË¶ñÂåñ„ÇíÈñã„Åè](${vizUrl})\n\n`;
                                            }

                                            // Display key results if available
                                            if (funcResult.status === 'success') {
                                                funcDisplay += `‚úÖ **„Çπ„ÉÜ„Éº„Çø„Çπ**: ÊàêÂäü\n\n`;

                                                // Display important metrics
                                                if (funcResult.message) {
                                                    funcDisplay += `üìù **ÁµêÊûú**: ${funcResult.message}\n\n`;
                                                }

                                                // Extract key metrics to display
                                                const keyMetrics = [];

                                                // EOQ results
                                                if (funcResult.optimal_order_quantity !== undefined) keyMetrics.push(`üì¶ **ÊúÄÈÅ©Áô∫Ê≥®Èáè**: ${funcResult.optimal_order_quantity.toFixed(2)} units`);
                                                if (funcResult.total_cost !== undefined) keyMetrics.push(`üí∞ **Á∑è„Ç≥„Çπ„Éà**: ${funcResult.total_cost.toFixed(2)} ÂÜÜ/Âπ¥`);
                                                if (funcResult.ordering_cost !== undefined) keyMetrics.push(`üìù Áô∫Ê≥®„Ç≥„Çπ„Éà: ${funcResult.ordering_cost.toFixed(2)} ÂÜÜ/Âπ¥`);
                                                if (funcResult.holding_cost !== undefined) keyMetrics.push(`üì¶ Âú®Â∫´‰øùÁÆ°„Ç≥„Çπ„Éà: ${funcResult.holding_cost.toFixed(2)} ÂÜÜ/Âπ¥`);
                                                if (funcResult.purchase_cost !== undefined) keyMetrics.push(`üíµ Ë≥ºÂÖ•„Ç≥„Çπ„Éà: ${funcResult.purchase_cost.toFixed(2)} ÂÜÜ/Âπ¥`);

                                                // Optimization results
                                                if (funcResult.best_cost !== undefined) keyMetrics.push(`üí∞ **Á∑è„Ç≥„Çπ„Éà**: ${funcResult.best_cost.toFixed(2)}`);
                                                if (funcResult.average_cost !== undefined) keyMetrics.push(`üìä Âπ≥Âùá„Ç≥„Çπ„Éà: ${funcResult.average_cost.toFixed(2)}`);
                                                if (funcResult.optimal_Q !== undefined) keyMetrics.push(`üì¶ **ÊúÄÈÅ©Áô∫Ê≥®Èáè**: ${funcResult.optimal_Q.toFixed(2)}`);
                                                if (funcResult.iterations !== undefined) keyMetrics.push(`üîÑ ÂèçÂæ©ÂõûÊï∞: ${funcResult.iterations}`);

                                                // Forecast results
                                                if (funcResult.forecast && Array.isArray(funcResult.forecast)) {
                                                    const forecastSummary = funcResult.forecast.slice(0, 3).map(v => v.toFixed(1)).join(', ');
                                                    keyMetrics.push(`üìà ‰∫àÊ∏¨ÂÄ§: [${forecastSummary}, ...]`);
                                                }

                                                // Distribution fitting results
                                                if (funcResult.best_distribution) {
                                                    keyMetrics.push(`üìä **ÊúÄÈÅ©ÂàÜÂ∏É**: ${funcResult.best_distribution}`);
                                                }

                                                if (keyMetrics.length > 0) {
                                                    funcDisplay += `**‰∏ª„Å™ÁµêÊûú**:\n${keyMetrics.map(m => `${m}`).join('\n')}\n\n`;
                                                }
                                            } else if (funcResult.status === 'error') {
                                                funcDisplay += `‚ùå **„Ç®„É©„Éº**: ${funcResult.message}\n\n`;
                                            }

                                            // Add collapsible detailed JSON
                                            const detailsId = `json-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                                            funcDisplay += `<details class="json-collapsible" id="${detailsId}">
                                                <summary class="json-collapsible-header">
                                                    <span>üìã Ë©≥Á¥∞„Å™ÁµêÊûú„ÇíË°®Á§∫</span>
                                                    <span class="json-toggle-icon">‚ñº</span>
                                                </summary>
                                                <div class="json-collapsible-content">
\`\`\`json
${JSON.stringify(funcResult, null, 2)}
\`\`\`
                                                </div>
                                            </details>\n\n`;

                                            assistantMessage += funcDisplay;
                                            this.messages[this.messages.length - 1].content = assistantMessage;
                                            this.scrollToBottom();
                                        } else if (parsed.error) {
                                            this.messages[this.messages.length - 1].content = `„Ç®„É©„Éº: ${parsed.error}`;
                                        }
                                    } catch (e) {
                                        // Ignore parse errors
                                    }
                                }
                            }
                        }

                        // Save to localStorage
                        localStorage.setItem('chatMessages', JSON.stringify(this.messages));

                    } catch (error) {
                        console.error('Error:', error);
                        this.messages.push({
                            role: 'assistant',
                            content: '„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ„ÇÇ„ÅÜ‰∏ÄÂ∫¶„ÅäË©¶„Åó„Åè„Å†„Åï„ÅÑ„ÄÇ'
                        });
                    } finally {
                        this.isLoading = false;
                        this.scrollToBottom();
                    }
                },

                clearChat() {
                    if (confirm('„ÉÅ„É£„ÉÉ„ÉàÂ±•Ê≠¥„Çí„ÇØ„É™„Ç¢„Åó„Åæ„Åô„ÅãÔºü')) {
                        this.messages = [];
                        localStorage.removeItem('chatMessages');
                    }
                },

                logout() {
                    if (confirm('„É≠„Ç∞„Ç¢„Ç¶„Éà„Åó„Åæ„Åô„ÅãÔºü')) {
                        localStorage.removeItem('token');
                        localStorage.removeItem('chatMessages');
                        window.location.href = '/';
                    }
                },

                scrollToBottom() {
                    this.$nextTick(() => {
                        const container = this.$refs.messageContainer;
                        container.scrollTop = container.scrollHeight;
                    });
                },

                formatMessage(content) {
                    // Configure marked.js
                    marked.setOptions({
                        breaks: true,
                        gfm: true,
                        headerIds: false,
                        mangle: false,
                        highlight: function(code, lang) {
                            if (lang && hljs.getLanguage(lang)) {
                                try {
                                    return hljs.highlight(code, { language: lang }).value;
                                } catch (err) {}
                            }
                            return hljs.highlightAuto(code).value;
                        }
                    });

                    // Render Markdown to HTML
                    let html = marked.parse(content);

                    // Post-process: Make all links open in new tab
                    html = html.replace(/<a href=/g, '<a target="_blank" href=');

                    // Apply syntax highlighting to code blocks that weren't highlighted
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = html;
                    tempDiv.querySelectorAll('pre code').forEach((block) => {
                        if (!block.classList.contains('hljs')) {
                            hljs.highlightElement(block);
                        }
                    });

                    return tempDiv.innerHTML;
                }
            }
        }
    </script>
</body>
</html>
