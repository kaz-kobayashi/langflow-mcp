<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Chat Agent</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Alpine.js -->
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>

    <!-- Marked.js for Markdown rendering -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

    <!-- Highlight.js for code syntax highlighting -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11/styles/github.min.css">
    <script src="https://cdn.jsdelivr.net/npm/highlight.js@11/lib/highlight.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/highlight.js@11/lib/languages/json.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/highlight.js@11/lib/languages/python.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/highlight.js@11/lib/languages/javascript.min.js"></script>

    <style>
        [x-cloak] { display: none !important; }

        .message-container {
            scroll-behavior: smooth;
        }

        .typing-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: #6B7280;
            animation: typing 1.4s infinite;
        }

        .typing-indicator:nth-child(2) {
            animation-delay: 0.2s;
        }

        .typing-indicator:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes typing {
            0%, 60%, 100% {
                transform: translateY(0);
                opacity: 0.7;
            }
            30% {
                transform: translateY(-10px);
                opacity: 1;
            }
        }

        .gradient-bg {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        /* Markdown styling */
        .markdown-content {
            line-height: 1.6;
        }

        .markdown-content h1,
        .markdown-content h2,
        .markdown-content h3,
        .markdown-content h4 {
            font-weight: bold;
            margin-top: 1em;
            margin-bottom: 0.5em;
        }

        .markdown-content h1 { font-size: 1.5em; }
        .markdown-content h2 { font-size: 1.3em; }
        .markdown-content h3 { font-size: 1.1em; }

        .markdown-content ul,
        .markdown-content ol {
            margin-left: 1.5em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
        }

        .markdown-content li {
            margin-bottom: 0.25em;
        }

        .markdown-content code {
            background-color: #f3f4f6;
            padding: 0.125rem 0.25rem;
            border-radius: 0.25rem;
            font-family: 'Courier New', monospace;
            font-size: 0.875em;
        }

        .markdown-content pre {
            background-color: #1f2937;
            color: #f9fafb;
            padding: 1rem;
            border-radius: 0.5rem;
            overflow-x: auto;
            margin: 0.5em 0;
        }

        .markdown-content pre code {
            background-color: transparent;
            padding: 0;
            color: inherit;
        }

        .markdown-content a {
            color: #2563eb;
            text-decoration: underline;
        }

        .markdown-content a:hover {
            color: #1d4ed8;
        }

        .markdown-content blockquote {
            border-left: 4px solid #e5e7eb;
            padding-left: 1em;
            margin-left: 0;
            color: #6b7280;
            font-style: italic;
        }

        .markdown-content table {
            border-collapse: collapse;
            width: 100%;
            margin: 0.5em 0;
        }

        .markdown-content table th,
        .markdown-content table td {
            border: 1px solid #e5e7eb;
            padding: 0.5em;
            text-align: left;
        }

        .markdown-content table th {
            background-color: #f3f4f6;
            font-weight: bold;
        }

        /* Code block styling */
        .hljs {
            border-radius: 0.5rem;
            font-size: 0.875em;
        }

        /* User message styling (white text on blue background) */
        .user-message .markdown-content a {
            color: #bfdbfe;
            text-decoration: underline;
        }

        .user-message .markdown-content a:hover {
            color: #dbeafe;
        }

        .user-message .markdown-content code {
            background-color: rgba(255, 255, 255, 0.2);
            color: #ffffff;
        }

        .user-message .markdown-content pre {
            background-color: rgba(0, 0, 0, 0.3);
        }

        /* JSON collapsible styling */
        .json-collapsible {
            border: 1px solid #e5e7eb;
            border-radius: 0.5rem;
            margin: 0.5em 0;
            overflow: hidden;
        }

        .json-collapsible-header {
            background-color: #f3f4f6;
            padding: 0.5rem 1rem;
            cursor: pointer;
            user-select: none;
            font-weight: 500;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .json-collapsible-header:hover {
            background-color: #e5e7eb;
        }

        .json-collapsible-content {
            max-height: 400px;
            overflow-y: auto;
        }

        .json-toggle-icon {
            transition: transform 0.2s;
        }

        .json-toggle-icon.collapsed {
            transform: rotate(-90deg);
        }

        /* Modal styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 50;
        }

        .modal-content {
            background: white;
            border-radius: 1rem;
            max-width: 900px;
            max-height: 90vh;
            width: 90%;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .modal-header {
            padding: 1.5rem;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-body {
            padding: 1.5rem;
            overflow-y: auto;
            flex: 1;
        }

        .modal-footer {
            padding: 1.5rem;
            border-top: 1px solid #e5e7eb;
            display: flex;
            justify-content: flex-end;
            gap: 0.75rem;
        }

        .form-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .form-group {
            display: flex;
            flex-direction: column;
        }

        .form-label {
            font-size: 0.875rem;
            font-weight: 600;
            color: #374151;
            margin-bottom: 0.5rem;
        }

        .form-input {
            padding: 0.5rem 0.75rem;
            border: 1px solid #d1d5db;
            border-radius: 0.5rem;
            font-size: 0.875rem;
        }

        .form-input:focus {
            outline: none;
            border-color: #3b82f6;
            ring: 2px;
            ring-color: rgba(59, 130, 246, 0.5);
        }

        .table-container {
            overflow-x: auto;
            margin-top: 1rem;
        }

        .param-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.875rem;
        }

        .param-table th,
        .param-table td {
            padding: 0.5rem;
            text-align: left;
            border: 1px solid #e5e7eb;
        }

        .param-table th {
            background-color: #f3f4f6;
            font-weight: 600;
            color: #374151;
        }

        .param-table input {
            width: 100%;
            padding: 0.375rem;
            border: 1px solid #d1d5db;
            border-radius: 0.25rem;
        }

        .param-table input:focus {
            outline: none;
            border-color: #3b82f6;
        }
    </style>
</head>
<body class="bg-gray-50" x-data="chatApp()" x-init="init()">
    <div class="min-h-screen flex flex-col">
        <!-- Header -->
        <header class="gradient-bg text-white shadow-lg">
            <div class="container mx-auto px-4 py-4 flex justify-between items-center">
                <div>
                    <h1 class="text-2xl font-bold">🤖 AI Chat Agent</h1>
                    <p class="text-sm text-gray-200 mt-1">Powered by LLM</p>
                </div>
                <button
                    x-show="!skipAuth"
                    @click="logout()"
                    class="px-4 py-2 bg-white/20 hover:bg-white/30 rounded-lg text-sm font-medium transition-colors"
                >
                    ログアウト
                </button>
            </div>
        </header>

        <!-- Main Chat Container -->
        <main class="flex-1 container mx-auto px-4 py-6 max-w-4xl">
            <!-- Messages Container -->
            <div
                class="message-container bg-white rounded-lg shadow-md p-6 mb-4 h-[calc(100vh-300px)] overflow-y-auto"
                x-ref="messageContainer"
            >
                <template x-if="messages.length === 0">
                    <div class="text-center text-gray-400 mt-20">
                        <svg class="w-16 h-16 mx-auto mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 10h.01M12 10h.01M16 10h.01M9 16H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v8a2 2 0 01-2 2h-5l-5 5v-5z"></path>
                        </svg>
                        <p class="text-lg">会話を始めましょう！</p>
                    </div>
                </template>

                <template x-for="(message, index) in messages" :key="index">
                    <div
                        class="mb-4 flex"
                        :class="message.role === 'user' ? 'justify-end' : 'justify-start'"
                    >
                        <div
                            class="max-w-[75%] rounded-lg px-4 py-3"
                            :class="message.role === 'user'
                                ? 'bg-gradient-to-r from-blue-500 to-blue-600 text-white user-message'
                                : 'bg-gray-100 text-gray-800'"
                        >
                            <div class="flex items-start gap-2">
                                <span class="text-lg" x-text="message.role === 'user' ? '👤' : '🤖'"></span>
                                <div class="flex-1 markdown-content text-sm" x-html="formatMessage(message.content)"></div>
                            </div>
                        </div>
                    </div>
                </template>

                <!-- Typing Indicator -->
                <template x-if="isLoading">
                    <div class="mb-4 flex justify-start">
                        <div class="max-w-[75%] rounded-lg px-4 py-3 bg-gray-100">
                            <div class="flex items-center gap-2">
                                <span class="text-lg">🤖</span>
                                <div class="flex gap-1">
                                    <span class="typing-indicator"></span>
                                    <span class="typing-indicator"></span>
                                    <span class="typing-indicator"></span>
                                </div>
                            </div>
                        </div>
                    </div>
                </template>
            </div>

            <!-- Quick Access Buttons -->
            <div class="bg-white rounded-lg shadow-md p-4 mb-4">
                <div class="flex items-center justify-between mb-3">
                    <h3 class="text-sm font-semibold text-gray-700">🚀 機能選択</h3>
                </div>

                <!-- Guided Form Button (Primary) -->
                <button
                    @click="openGuidedForm()"
                    class="w-full mb-3 px-4 py-3 bg-gradient-to-r from-indigo-500 to-purple-600 hover:from-indigo-600 hover:to-purple-700 text-white rounded-lg text-sm font-semibold transition-all shadow-md hover:shadow-lg"
                >
                    ✨ 機能を選んで入力する（おすすめ）
                </button>

                <!-- Quick Access Buttons -->
                <div class="text-xs text-gray-500 mb-2 font-medium">よく使う機能：</div>
                <div class="flex flex-wrap gap-2">
                    <button
                        @click="openSupplyChainForm()"
                        class="px-3 py-2 bg-blue-50 hover:bg-blue-100 text-blue-700 rounded-lg text-xs font-medium transition-colors border border-blue-200"
                    >
                        🏭 サプライチェーン最適化
                    </button>
                    <button
                        @click="openQuickForm('eoq')"
                        class="px-3 py-2 bg-green-50 hover:bg-green-100 text-green-700 rounded-lg text-xs font-medium transition-colors border border-green-200"
                    >
                        📦 EOQ計算
                    </button>
                    <button
                        @click="openQuickForm('demand_forecast')"
                        class="px-3 py-2 bg-amber-50 hover:bg-amber-100 text-amber-700 rounded-lg text-xs font-medium transition-colors border border-amber-200"
                    >
                        📈 需要予測
                    </button>
                    <button
                        @click="openQuickForm('safety_stock')"
                        class="px-3 py-2 bg-purple-50 hover:bg-purple-100 text-purple-700 rounded-lg text-xs font-medium transition-colors border border-purple-200"
                    >
                        🛡️ 安全在庫計算
                    </button>
                    <button
                        @click="openExcelMESSAModal()"
                        class="px-3 py-2 bg-orange-50 hover:bg-orange-100 text-orange-700 rounded-lg text-xs font-medium transition-colors border border-orange-200"
                    >
                        📊 Excelで安全在庫最適化
                    </button>
                    <button
                        @click="openTableMESSAModal()"
                        class="px-3 py-2 bg-teal-50 hover:bg-teal-100 text-teal-700 rounded-lg text-xs font-medium transition-colors border border-teal-200"
                    >
                        📋 テーブルで安全在庫最適化
                    </button>
                </div>
            </div>

            <!-- Input Area -->
            <div class="bg-white rounded-lg shadow-md p-4">
                <form @submit.prevent="sendMessage()" class="flex gap-3">
                    <input
                        type="text"
                        x-model="userInput"
                        :disabled="isLoading"
                        placeholder="メッセージを入力..."
                        class="flex-1 px-4 py-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 disabled:bg-gray-100 disabled:cursor-not-allowed"
                        autocomplete="off"
                    />
                    <button
                        type="submit"
                        :disabled="isLoading || !userInput.trim()"
                        class="px-6 py-3 bg-gradient-to-r from-blue-500 to-blue-600 text-white rounded-lg font-semibold hover:from-blue-600 hover:to-blue-700 disabled:opacity-50 disabled:cursor-not-allowed transition-all"
                    >
                        <span x-show="!isLoading">送信</span>
                        <span x-show="isLoading">送信中...</span>
                    </button>
                </form>

                <!-- Auto Detection Mode Toggle -->
                <div class="mt-3 flex items-center justify-between">
                    <label class="flex items-center gap-2 text-sm cursor-pointer">
                        <input
                            type="checkbox"
                            x-model="autoDetectMode"
                            class="w-4 h-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500"
                        />
                        <span class="text-gray-700">
                            🎯 自動ツール検出モード
                            <span class="text-xs text-gray-500">(ツール自動選択&パラメータ確認)</span>
                        </span>
                    </label>

                    <!-- Clear Chat Button -->
                    <button
                        @click="clearChat()"
                        class="text-sm text-gray-500 hover:text-gray-700 underline"
                        x-show="messages.length > 0"
                    >
                        チャット履歴をクリア
                    </button>
                </div>
            </div>
        </main>

        <!-- Footer -->
        <footer class="bg-white border-t py-4">
            <div class="container mx-auto px-4 text-center text-sm text-gray-600">
                <p>AI Chat Agent - FastAPI + Alpine.js + Tailwind CSS</p>
            </div>
        </footer>
    </div>

    <!-- Guided Form Modal -->
    <div x-show="showGuidedModal" x-cloak class="modal-overlay" @click.self="closeGuidedForm()">
        <div class="modal-content">
            <div class="modal-header">
                <div>
                    <h2 class="text-xl font-bold text-gray-800">✨ 機能を選んで入力</h2>
                    <div class="text-sm text-gray-500 mt-1">
                        <span x-show="guidedForm.step === 1">ステップ 1/3: カテゴリーを選択</span>
                        <span x-show="guidedForm.step === 2">ステップ 2/3: 機能を選択</span>
                        <span x-show="guidedForm.step === 3">ステップ 3/3: パラメータを入力</span>
                    </div>
                </div>
                <button @click="closeGuidedForm()" class="text-gray-500 hover:text-gray-700">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>

            <div class="modal-body">
                <!-- Step 1: Category Selection -->
                <div x-show="guidedForm.step === 1" class="space-y-3">
                    <p class="text-sm text-gray-600 mb-4">実行したい機能のカテゴリーを選んでください：</p>
                    <template x-for="category in functionCategories" :key="category.id">
                        <button
                            @click="selectCategory(category)"
                            class="w-full p-4 text-left border-2 rounded-lg hover:border-indigo-500 hover:bg-indigo-50 transition-all"
                            :class="guidedForm.selectedCategory?.id === category.id ? 'border-indigo-500 bg-indigo-50' : 'border-gray-200'"
                        >
                            <div class="flex items-start gap-3">
                                <span class="text-3xl" x-text="category.icon"></span>
                                <div class="flex-1">
                                    <div class="font-semibold text-gray-800" x-text="category.name"></div>
                                    <div class="text-sm text-gray-600 mt-1" x-text="category.description"></div>
                                </div>
                            </div>
                        </button>
                    </template>
                </div>

                <!-- Step 2: Function Selection -->
                <div x-show="guidedForm.step === 2" class="space-y-3">
                    <button @click="guidedForm.step = 1" class="text-sm text-indigo-600 hover:text-indigo-700 mb-3">
                        ← カテゴリー選択に戻る
                    </button>
                    <p class="text-sm text-gray-600 mb-4">実行したい機能を選んでください：</p>
                    <template x-for="func in (guidedForm.selectedCategory?.functions || [])" :key="func.id">
                        <button
                            @click="selectFunction(func)"
                            class="w-full p-4 text-left border-2 rounded-lg hover:border-indigo-500 hover:bg-indigo-50 transition-all"
                            :class="guidedForm.selectedFunction?.id === func.id ? 'border-indigo-500 bg-indigo-50' : 'border-gray-200'"
                        >
                            <div class="flex items-center gap-3">
                                <span class="text-2xl" x-text="func.icon"></span>
                                <span class="font-medium text-gray-800" x-text="func.name"></span>
                            </div>
                        </button>
                    </template>
                </div>

                <!-- Step 3: Parameter Input (Dynamic Form) -->
                <div x-show="guidedForm.step === 3">
                    <button @click="guidedForm.step = 2" class="text-sm text-indigo-600 hover:text-indigo-700 mb-3">
                        ← 機能選択に戻る
                    </button>
                    <div x-show="guidedForm.selectedFunction" class="bg-indigo-50 border border-indigo-200 rounded-lg p-4 mb-4">
                        <div class="flex items-start gap-2">
                            <span class="text-2xl" x-text="guidedForm.selectedFunction?.icon"></span>
                            <div>
                                <div class="font-semibold text-gray-800" x-text="functionTemplates[guidedForm.selectedFunction?.id]?.name"></div>
                                <div class="text-sm text-gray-600 mt-1" x-text="functionTemplates[guidedForm.selectedFunction?.id]?.description"></div>
                            </div>
                        </div>
                    </div>
                    <div id="dynamicFormFields" class="space-y-4">
                        <!-- Dynamic fields will be inserted here -->
                    </div>
                </div>
            </div>

            <div class="modal-footer">
                <button
                    @click="closeGuidedForm()"
                    class="px-4 py-2 bg-gray-200 hover:bg-gray-300 text-gray-700 rounded-lg font-medium transition-colors"
                >
                    キャンセル
                </button>
                <button
                    x-show="guidedForm.step === 3"
                    @click="submitGuidedForm()"
                    class="px-6 py-2 bg-indigo-600 hover:bg-indigo-700 text-white rounded-lg font-medium transition-colors"
                >
                    実行する
                </button>
            </div>
        </div>
    </div>

    <!-- Supply Chain Simulation Modal -->
    <div x-show="showSupplyChainModal" x-cloak class="modal-overlay" @click.self="closeSupplyChainForm()">
        <div class="modal-content" @click.away="closeSupplyChainForm()">
            <div class="modal-header">
                <h2 class="text-xl font-bold text-gray-800">🏭 サプライチェーンシミュレーション</h2>
                <button @click="closeSupplyChainForm()" class="text-gray-500 hover:text-gray-700">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>

            <div class="modal-body">
                <!-- Basic Parameters -->
                <h3 class="text-lg font-semibold text-gray-800 mb-3">基本パラメータ</h3>
                <div class="form-grid">
                    <div class="form-group">
                        <label class="form-label">サンプル数</label>
                        <input type="number" x-model.number="scForm.numSamples" class="form-input" min="1">
                    </div>
                    <div class="form-group">
                        <label class="form-label">シミュレーション期間</label>
                        <input type="number" x-model.number="scForm.periods" class="form-input" min="1">
                    </div>
                    <div class="form-group">
                        <label class="form-label">段階数</label>
                        <input type="number" x-model.number="scForm.numStages" class="form-input" min="1" @change="updateStageData()">
                    </div>
                </div>

                <div class="form-grid">
                    <div class="form-group">
                        <label class="form-label">平均需要（個/日）</label>
                        <input type="number" x-model.number="scForm.meanDemand" class="form-input" step="0.1">
                    </div>
                    <div class="form-group">
                        <label class="form-label">標準偏差（個/日）</label>
                        <input type="number" x-model.number="scForm.stdDemand" class="form-input" step="0.1">
                    </div>
                    <div class="form-group">
                        <label class="form-label">バックオーダーコスト（円/個）</label>
                        <input type="number" x-model.number="scForm.backorderCost" class="form-input" step="0.1">
                    </div>
                    <div class="form-group">
                        <label class="form-label">固定発注コスト（円）</label>
                        <input type="number" x-model.number="scForm.fixedOrderCost" class="form-input" step="0.1">
                    </div>
                </div>

                <!-- Stage-specific Parameters Table -->
                <h3 class="text-lg font-semibold text-gray-800 mt-6 mb-3">段階別パラメータ</h3>
                <div class="table-container">
                    <table class="param-table">
                        <thead>
                            <tr>
                                <th>段階</th>
                                <th>リードタイム（日）</th>
                                <th>発注点 s（個）</th>
                                <th>基在庫レベル S（個）</th>
                                <th>在庫保管費用 h（円/個/日）</th>
                            </tr>
                        </thead>
                        <tbody>
                            <template x-for="(stage, index) in scForm.stages" :key="index">
                                <tr>
                                    <td x-text="'Stage ' + index"></td>
                                    <td><input type="number" x-model.number="stage.leadTime" min="0"></td>
                                    <td><input type="number" x-model.number="stage.reorderPoint" min="0"></td>
                                    <td><input type="number" x-model.number="stage.baseStockLevel" min="0"></td>
                                    <td><input type="number" x-model.number="stage.holdingCost" min="0" step="0.1"></td>
                                </tr>
                            </template>
                        </tbody>
                    </table>
                </div>
            </div>

            <div class="modal-footer">
                <button
                    @click="closeSupplyChainForm()"
                    class="px-4 py-2 bg-gray-200 hover:bg-gray-300 text-gray-700 rounded-lg font-medium transition-colors"
                >
                    キャンセル
                </button>
                <button
                    @click="submitSupplyChainForm()"
                    class="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg font-medium transition-colors"
                >
                    チャットに送信
                </button>
            </div>
        </div>
    </div>

    <!-- Parameter Confirmation Modal -->
    <div x-show="showParameterConfirmModal" x-cloak class="modal-overlay" @click.self="closeParameterConfirmModal()">
        <div class="modal-content">
            <div class="modal-header">
                <div>
                    <h2 class="text-xl font-bold text-gray-800">🎯 パラメータ確認</h2>
                    <div class="text-sm text-gray-500 mt-1">
                        抽出されたパラメータを確認して実行してください
                    </div>
                </div>
                <button @click="closeParameterConfirmModal()" class="text-gray-500 hover:text-gray-700">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>

            <div class="modal-body">
                <!-- Detected Tool -->
                <div x-show="detectedTool" class="bg-indigo-50 border border-indigo-200 rounded-lg p-4 mb-4">
                    <h3 class="text-sm font-semibold text-gray-700 mb-2">🔧 検出されたツール</h3>
                    <div class="text-lg font-bold text-indigo-700" x-text="detectedTool?.tool_name"></div>
                    <div class="text-sm text-gray-600 mt-1" x-text="detectedTool?.description"></div>
                    <div class="text-xs text-gray-500 mt-2">
                        信頼度: <span x-text="detectedTool?.confidence ? (detectedTool.confidence * 100).toFixed(0) + '%' : 'N/A'"></span>
                    </div>
                </div>

                <!-- Extracted Parameters -->
                <div x-show="extractedParameters" class="bg-green-50 border border-green-200 rounded-lg p-4 mb-4">
                    <h3 class="text-sm font-semibold text-gray-700 mb-3">📋 抽出されたパラメータ</h3>
                    <div class="space-y-2">
                        <template x-for="(value, key) in extractedParameters" :key="key">
                            <div class="flex items-center gap-2 text-sm">
                                <span class="font-medium text-gray-700 w-1/3" x-text="key + ':'"></span>
                                <span class="text-gray-900 flex-1" x-text="formatParamValue(value)"></span>
                            </div>
                        </template>
                    </div>
                </div>

                <!-- Error Display -->
                <div x-show="extractionError" class="bg-red-50 border border-red-200 rounded-lg p-4 mb-4">
                    <h3 class="text-sm font-semibold text-red-700 mb-2">❌ エラー</h3>
                    <div class="text-sm text-red-600" x-text="extractionError"></div>
                </div>

                <!-- Original User Text -->
                <div class="bg-gray-50 border border-gray-200 rounded-lg p-4">
                    <h3 class="text-sm font-semibold text-gray-700 mb-2">💬 元の入力</h3>
                    <div class="text-sm text-gray-600" x-text="pendingUserMessage"></div>
                </div>
            </div>

            <div class="modal-footer">
                <button
                    @click="closeParameterConfirmModal()"
                    class="px-4 py-2 bg-gray-200 hover:bg-gray-300 text-gray-700 rounded-lg font-medium transition-colors"
                >
                    キャンセル
                </button>
                <button
                    x-show="!extractionError"
                    @click="confirmAndExecute()"
                    class="px-6 py-2 bg-indigo-600 hover:bg-indigo-700 text-white rounded-lg font-medium transition-colors"
                >
                    実行する
                </button>
            </div>
        </div>
    </div>

    <!-- Excel MESSA Modal -->
    <div x-show="showExcelMESSAModal" x-cloak class="modal-overlay" @click.self="closeExcelMESSAModal()">
        <div class="modal-content" style="max-width: 600px;" @click.away="closeExcelMESSAModal()">
            <div class="modal-header">
                <h2 class="text-xl font-bold text-gray-800">📊 Excelで安全在庫最適化（MESSA）</h2>
                <button @click="closeExcelMESSAModal()" class="text-gray-500 hover:text-gray-700">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>

            <div class="modal-body">
                <p class="text-sm text-gray-600 mb-6">
                    Excelファイルで品目データとBOMデータを入力して、マルチエシュロンサプライチェーンの安全在庫配置を最適化します。
                </p>

                <!-- Step 1: Download Template -->
                <div class="mb-6">
                    <h3 class="text-md font-semibold text-gray-800 mb-3">ステップ1: Excelテンプレートをダウンロード</h3>
                    <button
                        @click="downloadExcelTemplate()"
                        class="w-full px-4 py-3 bg-green-600 hover:bg-green-700 text-white rounded-lg font-medium transition-colors flex items-center justify-center gap-2"
                    >
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                        </svg>
                        テンプレートをダウンロード
                    </button>
                </div>

                <!-- Step 2: Fill Data -->
                <div class="mb-6">
                    <h3 class="text-md font-semibold text-gray-800 mb-3">ステップ2: データを入力</h3>
                    <div class="bg-blue-50 border border-blue-200 rounded-lg p-4 text-sm text-blue-800">
                        <p class="font-medium mb-2">📝 入力内容：</p>
                        <ul class="list-disc list-inside space-y-1">
                            <li><strong>品目シート</strong>: 品目名、処理時間、平均需要、標準偏差、コストデータ</li>
                            <li><strong>部品展開表シート</strong>: 親子関係、数量</li>
                        </ul>
                    </div>
                </div>

                <!-- Step 3: Upload File -->
                <div class="mb-4">
                    <h3 class="text-md font-semibold text-gray-800 mb-3">ステップ3: ファイルをアップロードして最適化実行</h3>
                    <label class="block w-full">
                        <input
                            type="file"
                            accept=".xlsx,.xls"
                            @change="uploadExcelFile($event)"
                            class="w-full px-4 py-3 border-2 border-dashed border-gray-300 hover:border-blue-400 rounded-lg cursor-pointer file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-blue-600 file:text-white hover:file:bg-blue-700 transition-colors"
                        />
                    </label>
                    <p class="text-xs text-gray-500 mt-2">
                        Excelファイル（.xlsx または .xls）を選択してください
                    </p>
                </div>
            </div>

            <div class="modal-footer">
                <button
                    @click="closeExcelMESSAModal()"
                    class="px-4 py-2 bg-gray-200 hover:bg-gray-300 text-gray-800 rounded-lg font-medium transition-colors"
                >
                    閉じる
                </button>
            </div>
        </div>
    </div>

    <!-- Table MESSA Modal -->
    <div x-show="showTableMESSAModal" x-cloak class="modal-overlay" @click.self="closeTableMESSAModal()">
        <div class="modal-content" style="max-width: 900px; max-height: 90vh; overflow-y: auto;" @click.away="closeTableMESSAModal()">
            <div class="modal-header">
                <h2 class="text-xl font-bold text-gray-800">📋 テーブルで安全在庫最適化（MESSA）</h2>
                <button @click="closeTableMESSAModal()" class="text-gray-500 hover:text-gray-700">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>

            <div class="modal-body">
                <p class="text-sm text-gray-600 mb-6">
                    品目データとBOMデータをテーブル形式で入力して、マルチエシュロンサプライチェーンの安全在庫配置を最適化します。
                </p>

                <!-- 品目データセクション -->
                <div class="mb-8">
                    <div class="flex justify-between items-center mb-3">
                        <h3 class="text-md font-semibold text-gray-800">品目データ</h3>
                        <button
                            @click="addItemRow()"
                            class="px-3 py-1 bg-blue-600 hover:bg-blue-700 text-white rounded text-sm transition-colors"
                        >
                            + 行を追加
                        </button>
                    </div>

                    <div class="overflow-x-auto border border-gray-300 rounded-lg">
                        <table class="w-full text-sm">
                            <thead class="bg-gray-100 border-b border-gray-300">
                                <tr>
                                    <th class="px-2 py-2 text-left">品目名*</th>
                                    <th class="px-2 py-2 text-left">処理時間</th>
                                    <th class="px-2 py-2 text-left">最大<br/>サービス時間</th>
                                    <th class="px-2 py-2 text-left">平均需要*</th>
                                    <th class="px-2 py-2 text-left">需要標準偏差*</th>
                                    <th class="px-2 py-2 text-left">保管費用</th>
                                    <th class="px-2 py-2 text-left">欠品費用</th>
                                    <th class="px-2 py-2 text-left">固定費用</th>
                                    <th class="px-2 py-2 text-center">削除</th>
                                </tr>
                            </thead>
                            <tbody>
                                <template x-for="(item, index) in tableItems" :key="index">
                                    <tr class="border-b border-gray-200 hover:bg-gray-50">
                                        <td class="px-2 py-2">
                                            <input type="text" x-model="item.name" class="w-full px-2 py-1 border border-gray-300 rounded text-sm" placeholder="品目A" />
                                        </td>
                                        <td class="px-2 py-2">
                                            <input type="number" x-model.number="item.process_time" class="w-full px-2 py-1 border border-gray-300 rounded text-sm" min="0" step="1" />
                                        </td>
                                        <td class="px-2 py-2">
                                            <input type="number" x-model.number="item.max_service_time" class="w-full px-2 py-1 border border-gray-300 rounded text-sm" min="0" step="1" />
                                        </td>
                                        <td class="px-2 py-2">
                                            <input type="number" x-model.number="item.avg_demand" class="w-full px-2 py-1 border border-gray-300 rounded text-sm" min="0" step="0.1" placeholder="100" />
                                        </td>
                                        <td class="px-2 py-2">
                                            <input type="number" x-model.number="item.demand_std" class="w-full px-2 py-1 border border-gray-300 rounded text-sm" min="0" step="0.1" placeholder="20" />
                                        </td>
                                        <td class="px-2 py-2">
                                            <input type="number" x-model.number="item.holding_cost" class="w-full px-2 py-1 border border-gray-300 rounded text-sm" min="0" step="0.1" />
                                        </td>
                                        <td class="px-2 py-2">
                                            <input type="number" x-model.number="item.stockout_cost" class="w-full px-2 py-1 border border-gray-300 rounded text-sm" min="0" step="1" />
                                        </td>
                                        <td class="px-2 py-2">
                                            <input type="number" x-model.number="item.fixed_cost" class="w-full px-2 py-1 border border-gray-300 rounded text-sm" min="0" step="1" />
                                        </td>
                                        <td class="px-2 py-2 text-center">
                                            <button
                                                @click="removeItemRow(index)"
                                                :disabled="tableItems.length === 1"
                                                :class="tableItems.length === 1 ? 'text-gray-300 cursor-not-allowed' : 'text-red-600 hover:text-red-800'"
                                                class="text-sm"
                                            >
                                                🗑️
                                            </button>
                                        </td>
                                    </tr>
                                </template>
                            </tbody>
                        </table>
                    </div>
                    <p class="text-xs text-gray-500 mt-2">* は必須項目です</p>
                </div>

                <!-- BOMデータセクション -->
                <div class="mb-6">
                    <div class="flex justify-between items-center mb-3">
                        <h3 class="text-md font-semibold text-gray-800">BOM（部品展開表）データ</h3>
                        <button
                            @click="addBOMRow()"
                            class="px-3 py-1 bg-blue-600 hover:bg-blue-700 text-white rounded text-sm transition-colors"
                        >
                            + 行を追加
                        </button>
                    </div>

                    <div class="overflow-x-auto border border-gray-300 rounded-lg">
                        <table class="w-full text-sm">
                            <thead class="bg-gray-100 border-b border-gray-300">
                                <tr>
                                    <th class="px-3 py-2 text-left">子品目*</th>
                                    <th class="px-3 py-2 text-left">親品目*</th>
                                    <th class="px-3 py-2 text-left">数量</th>
                                    <th class="px-3 py-2 text-center">削除</th>
                                </tr>
                            </thead>
                            <tbody>
                                <template x-for="(bom, index) in tableBOM" :key="index">
                                    <tr class="border-b border-gray-200 hover:bg-gray-50">
                                        <td class="px-3 py-2">
                                            <input type="text" x-model="bom.child" class="w-full px-2 py-1 border border-gray-300 rounded text-sm" placeholder="品目B" />
                                        </td>
                                        <td class="px-3 py-2">
                                            <input type="text" x-model="bom.parent" class="w-full px-2 py-1 border border-gray-300 rounded text-sm" placeholder="品目A" />
                                        </td>
                                        <td class="px-3 py-2">
                                            <input type="number" x-model.number="bom.quantity" class="w-full px-2 py-1 border border-gray-300 rounded text-sm" min="1" step="1" />
                                        </td>
                                        <td class="px-3 py-2 text-center">
                                            <button
                                                @click="removeBOMRow(index)"
                                                :disabled="tableBOM.length === 1"
                                                :class="tableBOM.length === 1 ? 'text-gray-300 cursor-not-allowed' : 'text-red-600 hover:text-red-800'"
                                                class="text-sm"
                                            >
                                                🗑️
                                            </button>
                                        </td>
                                    </tr>
                                </template>
                            </tbody>
                        </table>
                    </div>
                    <p class="text-xs text-gray-500 mt-2">* は必須項目です</p>
                </div>
            </div>

            <div class="modal-footer">
                <button
                    @click="closeTableMESSAModal()"
                    class="px-4 py-2 bg-gray-200 hover:bg-gray-300 text-gray-800 rounded-lg font-medium transition-colors"
                >
                    キャンセル
                </button>
                <button
                    @click="submitTableMESSA()"
                    class="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg font-medium transition-colors"
                >
                    最適化を実行
                </button>
            </div>
        </div>
    </div>

    <script>
        function chatApp() {
            return {
                messages: [],
                userInput: '',
                isLoading: false,
                modelName: 'qwen2.5:latest', // デフォルト値（ローカル開発用）
                skipAuth: false, // 認証スキップフラグ
                autoDetectMode: false, // 自動ツール検出モード

                // Modal states
                showSupplyChainModal: false,
                showGuidedModal: false,
                showParameterConfirmModal: false, // パラメータ確認モーダル
                showExcelMESSAModal: false, // Excelアップロードモーダル
                showTableMESSAModal: false, // テーブル入力モーダル

                // Table Input Data
                tableItems: [
                    { name: '', process_time: 1, max_service_time: 0, avg_demand: '', demand_std: '', holding_cost: 1, stockout_cost: 100, fixed_cost: 1000 }
                ],
                tableBOM: [
                    { child: '', parent: '', quantity: 1 }
                ],

                // Parameter extraction state
                detectedTool: null,
                extractedParameters: null,
                extractionError: null,
                pendingUserMessage: '', // 保留中のユーザーメッセージ

                // Guided Form State
                guidedForm: {
                    step: 1, // 1: category selection, 2: function selection, 3: parameter input
                    selectedCategory: null,
                    selectedFunction: null,
                    parameters: {}
                },

                // Function Categories and Definitions
                functionCategories: [
                    {
                        id: 'simulation',
                        name: 'シミュレーション',
                        icon: '🎲',
                        description: '在庫方策のシミュレーション',
                        functions: [
                            { id: 'simulate_qr', name: '(Q,R)連続発注方策', icon: '📊' },
                            { id: 'simulate_ss', name: '(s,S)連続発注方策', icon: '📈' },
                            { id: 'simulate_base_stock', name: '基在庫方策', icon: '📉' },
                            { id: 'base_stock_simulation_using_dist', name: '分布ベース基在庫シミュレーション', icon: '🎯' }
                        ]
                    },
                    {
                        id: 'optimization',
                        name: '在庫最適化',
                        icon: '⚙️',
                        description: '発注方策パラメータの最適化',
                        functions: [
                            { id: 'optimize_qr', name: '(Q,R)方策の最適化', icon: '🔧' },
                            { id: 'optimize_ss', name: '(s,S)方策の最適化', icon: '🔨' },
                            { id: 'optimize_periodic', name: '定期発注方策の最適化', icon: '⚡' },
                            { id: 'optimize_safety_stock', name: '安全在庫配置の最適化', icon: '🛡️' }
                        ]
                    },
                    {
                        id: 'forecast',
                        name: '需要予測・分析',
                        icon: '📈',
                        description: '需要データの分析と予測',
                        functions: [
                            { id: 'forecast_demand', name: '需要予測（指数平滑法/移動平均）', icon: '🔮' },
                            { id: 'analyze_demand', name: '需要パターン分析', icon: '📊' },
                            { id: 'find_best_distribution', name: '最適分布フィッティング', icon: '📉' },
                            { id: 'fit_histogram', name: 'ヒストグラム分布', icon: '📊' }
                        ]
                    },
                    {
                        id: 'calculation',
                        name: '在庫計算',
                        icon: '🧮',
                        description: '基本的な在庫計算',
                        functions: [
                            { id: 'calculate_safety_stock', name: '安全在庫計算', icon: '🛡️' },
                            { id: 'calculate_eoq_incremental', name: 'EOQ（増分数量割引）', icon: '📦' },
                            { id: 'calculate_eoq_all_units', name: 'EOQ（全単位数量割引）', icon: '📦' },
                            { id: 'calculate_wagner_whitin', name: 'Wagner-Whitinアルゴリズム', icon: '📊' }
                        ]
                    }
                ],

                // Function Parameter Templates
                functionTemplates: {
                    'calculate_safety_stock': {
                        name: '安全在庫計算',
                        description: '需要の変動とリードタイムから安全在庫を計算します',
                        fields: [
                            { name: 'mu', label: '需要の平均（個/日）', type: 'number', default: 100, required: true, help: '1日あたりの平均需要量' },
                            { name: 'sigma', label: '需要の標準偏差（個/日）', type: 'number', default: 15, required: true, help: '需要のばらつき' },
                            { name: 'lead_time', label: 'リードタイム（日）', type: 'number', default: 7, required: true, help: '発注から納品までの日数' },
                            { name: 'service_level', label: 'サービスレベル', type: 'number', default: 0.95, min: 0.5, max: 0.999, step: 0.01, required: true, help: '在庫切れを防ぐ確率（0.95 = 95%）' }
                        ]
                    },
                    'forecast_demand': {
                        name: '需要予測',
                        description: '過去の需要データから将来の需要を予測します',
                        fields: [
                            { name: 'demand_history', label: '過去の需要データ', type: 'array', default: '[100, 105, 98, 110, 102]', required: true, help: '過去の需要データをカンマ区切りで入力' },
                            { name: 'forecast_periods', label: '予測期間', type: 'number', default: 10, required: true, help: '何期先まで予測するか' },
                            { name: 'method', label: '予測手法', type: 'select', options: [
                                { value: 'exponential_smoothing', label: '指数平滑法' },
                                { value: 'moving_average', label: '移動平均法' },
                                { value: 'linear_trend', label: '線形トレンド法' }
                            ], default: 'exponential_smoothing', required: true }
                        ]
                    },
                    'analyze_demand': {
                        name: '需要パターン分析',
                        description: '需要データの統計的分析を行い、平均、標準偏差、変動係数などを計算します。需要パターンの理解と在庫方策の選択に役立ちます',
                        fields: [
                            { name: 'demand', label: '需要データ', type: 'array', default: '[100, 105, 98, 110, 102, 95, 108, 103, 97, 112]', required: true, help: '需要データをカンマ区切りで入力（例: 10, 12, 8, 15, 11）' }
                        ]
                    },
                    'find_best_distribution': {
                        name: '最適分布フィッティング',
                        description: '需要データに最適な確率分布を自動的に見つけてフィッティングします。正規分布、ガンマ分布、対数正規分布など複数の分布を試し、最も適合度の高いものを選択します',
                        fields: [
                            { name: 'demand', label: '需要データ', type: 'array', default: '[100, 105, 98, 110, 102, 95, 108, 103, 97, 112, 101, 99, 106, 104, 98]', required: true, help: '需要データをカンマ区切りで入力。データ数が多いほど正確にフィッティングできます' }
                        ]
                    },
                    'fit_histogram': {
                        name: 'ヒストグラム分布フィッティング',
                        description: 'ヒストグラムを作成し、需要データの分布を可視化します。ビン数を調整して分布の詳細を把握できます',
                        fields: [
                            { name: 'demand_data', label: '需要データ', type: 'array', default: '[100, 105, 98, 110, 102, 95, 108, 103, 97, 112, 101, 99, 106, 104, 98]', required: true, help: '需要データをカンマ区切りで入力' },
                            { name: 'nbins', label: 'ビン数', type: 'number', default: 50, required: false, help: 'ヒストグラムのビン数（デフォルト: 50）' }
                        ]
                    },
                    'calculate_eoq_incremental': {
                        name: 'EOQ計算（増分数量割引）',
                        description: '数量割引を考慮した経済的発注量を計算します',
                        fields: [
                            { name: 'annual_demand', label: '年間需要（個）', type: 'number', default: 12000, required: true },
                            { name: 'order_cost', label: '発注コスト（円）', type: 'number', default: 500, required: true },
                            { name: 'holding_cost_rate', label: '在庫保管費率（%）', type: 'number', default: 20, required: true, help: '年間の在庫保管費用率' },
                            { name: 'price_table', label: '単価テーブル', type: 'table', columns: ['数量', '単価'], default: [[0, 12.0], [500, 11.5], [1000, 11.0]], required: true }
                        ]
                    },
                    'simulate_qr': {
                        name: '(Q,R)連続発注方策シミュレーション',
                        description: '発注量Qと発注点Rを使った連続監視型在庫方策',
                        fields: [
                            { name: 'n_samples', label: 'サンプル数', type: 'number', default: 100, required: false },
                            { name: 'n_periods', label: 'シミュレーション期間', type: 'number', default: 200, required: false },
                            { name: 'Q', label: '発注量Q（個）', type: 'number', default: 150, required: true },
                            { name: 'R', label: '発注点R（個）', type: 'number', default: 80, required: true },
                            { name: 'mu', label: '需要の平均（個/日）', type: 'number', default: 100, required: true },
                            { name: 'sigma', label: '需要の標準偏差', type: 'number', default: 15, required: true },
                            { name: 'lead_time', label: 'リードタイム（日）', type: 'number', default: 5, required: true },
                            { name: 'holding_cost', label: '在庫保管費用（円/個/日）', type: 'number', default: 1.0, required: true },
                            { name: 'stockout_cost', label: '品切れコスト（円/個）', type: 'number', default: 100, required: true },
                            { name: 'fixed_cost', label: '固定発注コスト（円）', type: 'number', default: 500, required: true }
                        ]
                    },
                    'simulate_ss': {
                        name: '(s,S)連続発注方策シミュレーション',
                        description: '発注点sと基在庫レベルSを使った連続監視型在庫方策',
                        fields: [
                            { name: 'n_samples', label: 'サンプル数', type: 'number', default: 100, required: false },
                            { name: 'n_periods', label: 'シミュレーション期間', type: 'number', default: 200, required: false },
                            { name: 's', label: '発注点s（個）', type: 'number', default: 80, required: true },
                            { name: 'S', label: '基在庫レベルS（個）', type: 'number', default: 200, required: true },
                            { name: 'mu', label: '需要の平均（個/日）', type: 'number', default: 100, required: true },
                            { name: 'sigma', label: '需要の標準偏差', type: 'number', default: 15, required: true },
                            { name: 'lead_time', label: 'リードタイム（日）', type: 'number', default: 5, required: true },
                            { name: 'holding_cost', label: '在庫保管費用（円/個/日）', type: 'number', default: 1.0, required: true },
                            { name: 'stockout_cost', label: '品切れコスト（円/個）', type: 'number', default: 100, required: true },
                            { name: 'fixed_cost', label: '固定発注コスト（円）', type: 'number', default: 500, required: true }
                        ]
                    },
                    'optimize_qr': {
                        name: '(Q,R)方策の最適化',
                        description: '(Q,R)方策の最適な発注量Qと発注点Rを計算します',
                        fields: [
                            { name: 'mu', label: '需要の平均（個/日）', type: 'number', default: 100, required: true },
                            { name: 'sigma', label: '需要の標準偏差', type: 'number', default: 15, required: true },
                            { name: 'lead_time', label: 'リードタイム（日）', type: 'number', default: 5, required: true },
                            { name: 'holding_cost', label: '在庫保管費用（円/個/日）', type: 'number', default: 1.0, required: true },
                            { name: 'stockout_cost', label: '品切れコスト（円/個）', type: 'number', default: 100, required: true },
                            { name: 'fixed_cost', label: '固定発注コスト（円）', type: 'number', default: 500, required: true }
                        ]
                    },
                    'optimize_ss': {
                        name: '(s,S)方策の最適化',
                        description: '(s,S)方策の最適な発注点sと基在庫レベルSを計算します',
                        fields: [
                            { name: 'mu', label: '需要の平均（個/日）', type: 'number', default: 100, required: true },
                            { name: 'sigma', label: '需要の標準偏差', type: 'number', default: 15, required: true },
                            { name: 'lead_time', label: 'リードタイム（日）', type: 'number', default: 5, required: true },
                            { name: 'holding_cost', label: '在庫保管費用（円/個/日）', type: 'number', default: 1.0, required: true },
                            { name: 'stockout_cost', label: '品切れコスト（円/個）', type: 'number', default: 100, required: true },
                            { name: 'fixed_cost', label: '固定発注コスト（円）', type: 'number', default: 500, required: true }
                        ]
                    },
                    'simulate_base_stock': {
                        name: '基在庫方策シミュレーション',
                        description: '定期発注方式で基在庫レベルまで補充する方策のシミュレーション',
                        fields: [
                            { name: 'mu', label: '需要の平均（個/日）', type: 'number', default: 100, required: true, help: '需要データを自動生成します' },
                            { name: 'sigma', label: '需要の標準偏差', type: 'number', default: 15, required: true },
                            { name: 'n_samples', label: 'サンプル数', type: 'number', default: 100, required: false },
                            { name: 'n_periods', label: 'シミュレーション期間', type: 'number', default: 200, required: false },
                            { name: 'base_stock_level', label: '基在庫レベルS（個）', type: 'number', default: 200, required: true },
                            { name: 'lead_time', label: 'リードタイム（日）', type: 'number', default: 5, required: true },
                            { name: 'capacity', label: '生産能力（個/日）', type: 'number', default: 1000, required: false, help: '無制限の場合は大きな値を設定' },
                            { name: 'holding_cost', label: '在庫保管費用（円/個/日）', type: 'number', default: 1.0, required: true },
                            { name: 'stockout_cost', label: '品切れコスト（円/個）', type: 'number', default: 100, required: true }
                        ]
                    },
                    'base_stock_simulation_using_dist': {
                        name: '分布ベース基在庫シミュレーション',
                        description: '確率分布から需要を生成して基在庫方策をシミュレーション',
                        fields: [
                            { name: 'n_samples', label: 'サンプル数', type: 'number', default: 100, required: false },
                            { name: 'n_periods', label: 'シミュレーション期間', type: 'number', default: 200, required: false },
                            { name: 'dist_type', label: '需要分布タイプ', type: 'select', options: [
                                { value: 'normal', label: '正規分布' },
                                { value: 'gamma', label: 'ガンマ分布' },
                                { value: 'poisson', label: 'ポアソン分布' },
                                { value: 'uniform', label: '一様分布' },
                                { value: 'exponential', label: '指数分布' },
                                { value: 'lognormal', label: '対数正規分布' }
                            ], default: 'normal', required: true },
                            { name: 'dist_mu', label: '分布パラメータ: 平均 (mu)', type: 'number', default: 100, required: true },
                            { name: 'dist_sigma', label: '分布パラメータ: 標準偏差 (sigma)', type: 'number', default: 15, required: true, help: '正規分布の場合' },
                            { name: 'base_stock_level', label: '基在庫レベルS（個）', type: 'number', default: 200, required: false, help: '省略すると自動計算' },
                            { name: 'lead_time', label: 'リードタイム（日）', type: 'number', default: 5, required: false },
                            { name: 'capacity', label: '生産能力（個/日）', type: 'number', default: 1000, required: false },
                            { name: 'holding_cost', label: '在庫保管費用（円/個/日）', type: 'number', default: 1.0, required: false },
                            { name: 'backorder_cost', label: 'バックオーダーコスト（円/個）', type: 'number', default: 100, required: false }
                        ]
                    },
                    'optimize_periodic': {
                        name: '定期発注方策の最適化',
                        description: 'サプライチェーンネットワーク全体の定期発注方策を最適化します',
                        fields: [
                            { name: 'note', label: '注意', type: 'info', default: 'この機能は複雑なため、「サプライチェーン最適化」ボタンをご利用ください', help: '「よく使う機能」の「🏭 サプライチェーン最適化」ボタンから、より詳細な設定が可能です。' }
                        ]
                    },
                    'optimize_safety_stock': {
                        name: '安全在庫配置の最適化（MESSA）',
                        description: 'マルチエシュロンサプライチェーンネットワーク全体の安全在庫配置を最適化します',
                        fields: [
                            {
                                name: 'complexity',
                                label: 'サプライチェーンの複雑度',
                                type: 'select',
                                options: [
                                    { value: 'simple', label: 'シンプル（3品目）' },
                                    { value: 'standard', label: '標準（5品目）' },
                                    { value: 'complex', label: '複雑（8品目）' }
                                ],
                                default: 'standard',
                                required: true,
                                help: 'サンプルデータを自動生成して最適化を実行します'
                            }
                        ]
                    },
                    'calculate_eoq_raw': {
                        name: '基本EOQ計算',
                        description: '経済発注量（EOQ）を計算し、最適な発注量と総コストを算出します',
                        fields: [
                            { name: 'annual_demand', label: '年間需要量（個/年）', type: 'number', default: 15000, required: true, help: '年間の総需要量' },
                            { name: 'order_cost', label: '発注固定費用（円/回）', type: 'number', default: 500, required: true, help: '1回の発注にかかる固定費用' },
                            { name: 'holding_cost_rate', label: '在庫保管費率（年率）', type: 'number', default: 0.25, required: true, help: '年間の在庫保管費率（例: 0.25 = 25%）' },
                            { name: 'unit_price', label: '単価（円/個）', type: 'number', default: 12, required: true, help: '商品の単価' },
                            { name: 'backorder_cost', label: 'バックオーダー費用（円/個）', type: 'number', default: 0, required: false, help: '品切れ時の費用（オプション、0の場合はバックオーダーなし）' }
                        ]
                    },
                    'calculate_eoq_incremental': {
                        name: 'EOQ（増分数量割引）',
                        description: '増分数量割引を考慮したEOQを計算します。発注量の各段階で価格が段階的に変わる場合に使用します',
                        fields: [
                            { name: 'K', label: '発注固定費用（円/回）', type: 'number', default: 500, required: true, help: '1回の発注にかかる固定費用' },
                            { name: 'd', label: '平均需要量（個/日）', type: 'number', default: 100, required: true, help: '1日あたりの平均需要量' },
                            { name: 'h', label: '在庫保管費用（円/個/日）', type: 'number', default: 0.1, required: true, help: '1個を1日保管するコスト' },
                            { name: 'b', label: '品切れ費用（円/個/日）', type: 'number', default: 10, required: true, help: '品切れ時の1個あたり1日の費用' },
                            { name: 'r', label: '割引率', type: 'number', default: 0.2, required: true, help: '在庫保管費の計算に使用する割引率' },
                            { name: 'unit_costs', label: '各価格帯の単価', type: 'array', default: '[12, 11, 10]', required: true, help: '各価格帯の単価をカンマ区切りで入力（例: 12, 11, 10）' },
                            { name: 'quantity_breaks', label: '各価格帯の最小発注量', type: 'array', default: '[0, 100, 200]', required: true, help: '各価格帯の最小発注量をカンマ区切りで入力（例: 0, 100, 200）' }
                        ]
                    },
                    'calculate_eoq_all_units': {
                        name: 'EOQ（全単位数量割引）',
                        description: '全単位数量割引を考慮したEOQを計算します。発注量に応じて全体の価格が変わる場合に使用します',
                        fields: [
                            { name: 'K', label: '発注固定費用（円/回）', type: 'number', default: 500, required: true, help: '1回の発注にかかる固定費用' },
                            { name: 'd', label: '平均需要量（個/日）', type: 'number', default: 100, required: true, help: '1日あたりの平均需要量' },
                            { name: 'h', label: '在庫保管費用（円/個/日）', type: 'number', default: 0.1, required: true, help: '1個を1日保管するコスト' },
                            { name: 'b', label: '品切れ費用（円/個/日）', type: 'number', default: 10, required: true, help: '品切れ時の1個あたり1日の費用' },
                            { name: 'r', label: '割引率', type: 'number', default: 0.2, required: true, help: '在庫保管費の計算に使用する割引率' },
                            { name: 'unit_costs', label: '各価格帯の単価', type: 'array', default: '[12, 11, 10]', required: true, help: '各価格帯の単価をカンマ区切りで入力（例: 12, 11, 10）' },
                            { name: 'quantity_breaks', label: '各価格帯の最小発注量', type: 'array', default: '[0, 100, 200]', required: true, help: '各価格帯の最小発注量をカンマ区切りで入力（例: 0, 100, 200）' }
                        ]
                    },
                    'calculate_wagner_whitin': {
                        name: 'Wagner-Whitinアルゴリズム',
                        description: '動的ロットサイジング問題を解き、将来の需要が既知の場合に総コストを最小化する発注スケジュールを計算します',
                        fields: [
                            { name: 'demand', label: '各期の需要量', type: 'array', default: '[10, 20, 30, 15, 25]', required: true, help: '各期の需要量をカンマ区切りで入力（例: 10, 20, 30, 15）' },
                            { name: 'fixed_cost', label: '固定発注費用（円/回）', type: 'number', default: 100, required: true, help: '発注ごとにかかる固定費用' },
                            { name: 'holding_cost', label: '在庫保管費用（円/unit/期）', type: 'number', default: 1, required: true, help: '在庫1単位を1期間保管するコスト' },
                            { name: 'variable_cost', label: '変動発注費用（円/unit）', type: 'number', default: 0, required: false, help: '発注量に応じて変わる費用（オプション）' }
                        ]
                    }
                },

                // Supply Chain Form Data
                scForm: {
                    numSamples: 50,
                    periods: 200,
                    numStages: 4,
                    meanDemand: 120,
                    stdDemand: 18,
                    backorderCost: 100,
                    fixedOrderCost: 1000,
                    stages: [
                        { leadTime: 3, reorderPoint: 250, baseStockLevel: 400, holdingCost: 0.5 },
                        { leadTime: 2, reorderPoint: 200, baseStockLevel: 320, holdingCost: 1.0 },
                        { leadTime: 2, reorderPoint: 180, baseStockLevel: 300, holdingCost: 2.0 },
                        { leadTime: 1, reorderPoint: 150, baseStockLevel: 250, holdingCost: 5.0 }
                    ]
                },

                async init() {
                    // サーバーから設定を取得
                    try {
                        const response = await fetch('/api/config');
                        if (response.ok) {
                            const config = await response.json();
                            this.modelName = config.model;
                            this.skipAuth = config.skip_auth;
                        }
                    } catch (error) {
                        console.error('Failed to load config:', error);
                    }

                    // Check if user is logged in (unless auth is skipped)
                    if (!this.skipAuth) {
                        const token = localStorage.getItem('token');
                        if (!token) {
                            window.location.href = '/';
                            return;
                        }
                    }

                    // Load messages from localStorage
                    const saved = localStorage.getItem('chatMessages');
                    if (saved) {
                        this.messages = JSON.parse(saved);
                    }
                },

                async sendMessage() {
                    if (!this.userInput.trim() || this.isLoading) return;

                    const userMessage = this.userInput.trim();
                    this.userInput = '';

                    // Check if auto-detect mode is enabled
                    if (this.autoDetectMode) {
                        // Intercept and run detection/extraction workflow
                        await this.detectToolAndExtractParams(userMessage);
                        return;
                    }

                    // Add user message
                    this.messages.push({
                        role: 'user',
                        content: userMessage
                    });

                    this.isLoading = true;
                    this.scrollToBottom();

                    try {
                        const token = localStorage.getItem('token');

                        const response = await fetch('/api/chat', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${token}`
                            },
                            body: JSON.stringify({
                                messages: this.messages,
                                model: this.modelName
                            })
                        });

                        if (!response.ok) {
                            throw new Error('API request failed');
                        }

                        const reader = response.body.getReader();
                        const decoder = new TextDecoder();
                        let assistantMessage = '';

                        // Add assistant message placeholder
                        this.messages.push({
                            role: 'assistant',
                            content: ''
                        });

                        while (true) {
                            const { done, value } = await reader.read();
                            if (done) break;

                            const chunk = decoder.decode(value);
                            const lines = chunk.split('\n');

                            for (const line of lines) {
                                if (line.startsWith('data: ')) {
                                    const data = line.slice(6);
                                    if (data === '[DONE]') break;

                                    try {
                                        const parsed = JSON.parse(data);
                                        if (parsed.content) {
                                            assistantMessage += parsed.content;
                                            this.messages[this.messages.length - 1].content = assistantMessage;
                                            this.scrollToBottom();
                                        } else if (parsed.function_call) {
                                            // Function call結果を表示
                                            const funcName = parsed.function_call.name;
                                            const funcResult = parsed.function_call.result;

                                            let funcDisplay = `\n\n🔧 **${funcName}を実行しました**\n\n`;

                                            // Check if result contains visualization URL or ID
                                            if (funcResult.visualization_url) {
                                                const vizUrl = funcResult.visualization_url;
                                                const message = funcResult.message || '可視化結果を表示';
                                                funcDisplay += `📊 ${message}\n🔗 [可視化を開く](${vizUrl})\n\n`;
                                            } else if (funcResult.visualization_id) {
                                                const vizId = funcResult.visualization_id;
                                                const vizUrl = `/api/visualization/${vizId}`;
                                                const message = funcResult.message || '可視化結果を表示';
                                                funcDisplay += `📊 ${message}\n🔗 [可視化を開く](${vizUrl})\n\n`;
                                            }

                                            // Display key results if available
                                            if (funcResult.status === 'success') {
                                                funcDisplay += `✅ **ステータス**: 成功\n\n`;

                                                // Display important metrics
                                                if (funcResult.message) {
                                                    funcDisplay += `📝 **結果**: ${funcResult.message}\n\n`;
                                                }

                                                // Extract key metrics to display
                                                const keyMetrics = [];

                                                // EOQ results
                                                if (funcResult.optimal_order_quantity !== undefined) keyMetrics.push(`📦 **最適発注量**: ${funcResult.optimal_order_quantity.toFixed(2)} units`);
                                                if (funcResult.total_cost !== undefined) keyMetrics.push(`💰 **総コスト**: ${funcResult.total_cost.toFixed(2)} 円/年`);
                                                if (funcResult.ordering_cost !== undefined) keyMetrics.push(`📝 発注コスト: ${funcResult.ordering_cost.toFixed(2)} 円/年`);
                                                if (funcResult.holding_cost !== undefined) keyMetrics.push(`📦 在庫保管コスト: ${funcResult.holding_cost.toFixed(2)} 円/年`);
                                                if (funcResult.purchase_cost !== undefined) keyMetrics.push(`💵 購入コスト: ${funcResult.purchase_cost.toFixed(2)} 円/年`);

                                                // Optimization results
                                                if (funcResult.best_cost !== undefined) keyMetrics.push(`💰 **総コスト**: ${funcResult.best_cost.toFixed(2)}`);
                                                if (funcResult.average_cost !== undefined) keyMetrics.push(`📊 平均コスト: ${funcResult.average_cost.toFixed(2)}`);
                                                if (funcResult.optimal_Q !== undefined) keyMetrics.push(`📦 **最適発注量**: ${funcResult.optimal_Q.toFixed(2)}`);
                                                if (funcResult.iterations !== undefined) keyMetrics.push(`🔄 反復回数: ${funcResult.iterations}`);

                                                // Forecast results
                                                if (funcResult.forecast && Array.isArray(funcResult.forecast)) {
                                                    const forecastSummary = funcResult.forecast.slice(0, 3).map(v => v.toFixed(1)).join(', ');
                                                    keyMetrics.push(`📈 予測値: [${forecastSummary}, ...]`);
                                                }

                                                // Distribution fitting results
                                                if (funcResult.best_distribution) {
                                                    keyMetrics.push(`📊 **最適分布**: ${funcResult.best_distribution}`);
                                                }

                                                if (keyMetrics.length > 0) {
                                                    funcDisplay += `**主な結果**:\n${keyMetrics.map(m => `${m}`).join('\n')}\n\n`;
                                                }
                                            } else if (funcResult.status === 'error') {
                                                funcDisplay += `❌ **エラー**: ${funcResult.message}\n\n`;
                                            }

                                            // Add collapsible detailed JSON
                                            const detailsId = `json-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                                            funcDisplay += `<details class="json-collapsible" id="${detailsId}">
                                                <summary class="json-collapsible-header">
                                                    <span>📋 詳細な結果を表示</span>
                                                    <span class="json-toggle-icon">▼</span>
                                                </summary>
                                                <div class="json-collapsible-content">
\`\`\`json
${JSON.stringify(funcResult, null, 2)}
\`\`\`
                                                </div>
                                            </details>\n\n`;

                                            assistantMessage += funcDisplay;
                                            this.messages[this.messages.length - 1].content = assistantMessage;
                                            this.scrollToBottom();
                                        } else if (parsed.error) {
                                            this.messages[this.messages.length - 1].content = `エラー: ${parsed.error}`;
                                        }
                                    } catch (e) {
                                        // Ignore parse errors
                                    }
                                }
                            }
                        }

                        // Save to localStorage
                        localStorage.setItem('chatMessages', JSON.stringify(this.messages));

                    } catch (error) {
                        console.error('Error:', error);
                        this.messages.push({
                            role: 'assistant',
                            content: 'エラーが発生しました。もう一度お試しください。'
                        });
                    } finally {
                        this.isLoading = false;
                        this.scrollToBottom();
                    }
                },

                clearChat() {
                    if (confirm('チャット履歴をクリアしますか？')) {
                        this.messages = [];
                        localStorage.removeItem('chatMessages');
                    }
                },

                logout() {
                    if (confirm('ログアウトしますか？')) {
                        localStorage.removeItem('token');
                        localStorage.removeItem('chatMessages');
                        window.location.href = '/';
                    }
                },

                scrollToBottom() {
                    this.$nextTick(() => {
                        const container = this.$refs.messageContainer;
                        container.scrollTop = container.scrollHeight;
                    });
                },

                formatMessage(content) {
                    // Configure marked.js
                    marked.setOptions({
                        breaks: true,
                        gfm: true,
                        headerIds: false,
                        mangle: false,
                        highlight: function(code, lang) {
                            if (lang && hljs.getLanguage(lang)) {
                                try {
                                    return hljs.highlight(code, { language: lang }).value;
                                } catch (err) {}
                            }
                            return hljs.highlightAuto(code).value;
                        }
                    });

                    // Render Markdown to HTML
                    let html = marked.parse(content);

                    // Post-process: Make all links open in new tab
                    html = html.replace(/<a href=/g, '<a target="_blank" href=');

                    // Apply syntax highlighting to code blocks that weren't highlighted
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = html;
                    tempDiv.querySelectorAll('pre code').forEach((block) => {
                        if (!block.classList.contains('hljs')) {
                            hljs.highlightElement(block);
                        }
                    });

                    return tempDiv.innerHTML;
                },

                // Supply Chain Form Methods
                openSupplyChainForm() {
                    this.showSupplyChainModal = true;
                },

                closeSupplyChainForm() {
                    this.showSupplyChainModal = false;
                },

                // Excel MESSA Form Methods
                openExcelMESSAModal() {
                    this.showExcelMESSAModal = true;
                },

                closeExcelMESSAModal() {
                    this.showExcelMESSAModal = false;
                },

                async downloadExcelTemplate() {
                    try {
                        const token = localStorage.getItem('token');
                        const headers = {};
                        if (token && !this.skipAuth) {
                            headers['Authorization'] = `Bearer ${token}`;
                        }

                        const response = await fetch('/api/download_messa_template', {
                            method: 'GET',
                            headers: headers
                        });

                        if (!response.ok) {
                            throw new Error('テンプレートのダウンロードに失敗しました');
                        }

                        const blob = await response.blob();
                        const url = window.URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = 'messa_template.xlsx';
                        document.body.appendChild(a);
                        a.click();
                        window.URL.revokeObjectURL(url);
                        document.body.removeChild(a);

                        alert('✅ Excelテンプレートをダウンロードしました');
                    } catch (error) {
                        console.error('Download error:', error);
                        alert('❌ ダウンロードエラー: ' + error.message);
                    }
                },

                async uploadExcelFile(event) {
                    const file = event.target.files[0];
                    if (!file) return;

                    const formData = new FormData();
                    formData.append('file', file);

                    try {
                        const token = localStorage.getItem('token');
                        const headers = {};
                        if (token && !this.skipAuth) {
                            headers['Authorization'] = `Bearer ${token}`;
                        }
                        // Don't set Content-Type for FormData - browser will set it with boundary

                        const response = await fetch('/api/upload_messa_excel', {
                            method: 'POST',
                            headers: headers,
                            body: formData
                        });

                        if (!response.ok) {
                            const errorData = await response.json();
                            throw new Error(errorData.detail || '最適化に失敗しました');
                        }

                        const result = await response.json();

                        // Display results
                        let resultMessage = `✅ 最適化が完了しました！\n\n総コスト: ${result.total_cost.toFixed(2)}円\n\n`;
                        resultMessage += '各拠点の最適在庫:\n';
                        result.optimization_results.forEach(node => {
                            resultMessage += `- ${node.node}: 安全在庫 ${node.safety_stock.toFixed(2)}, サービス時間 ${node.service_time.toFixed(2)}, リードタイム ${node.lead_time.toFixed(2)}\n`;
                        });

                        alert(resultMessage);
                        this.closeExcelMESSAModal();

                    } catch (error) {
                        console.error('Upload error:', error);
                        alert('❌ アップロードエラー: ' + error.message);
                    }
                },

                // Table MESSA Form Methods
                openTableMESSAModal() {
                    this.showTableMESSAModal = true;
                },

                closeTableMESSAModal() {
                    this.showTableMESSAModal = false;
                },

                addItemRow() {
                    this.tableItems.push({
                        name: '',
                        process_time: 1,
                        max_service_time: 0,
                        avg_demand: '',
                        demand_std: '',
                        holding_cost: 1,
                        stockout_cost: 100,
                        fixed_cost: 1000
                    });
                },

                removeItemRow(index) {
                    if (this.tableItems.length > 1) {
                        this.tableItems.splice(index, 1);
                    }
                },

                addBOMRow() {
                    this.tableBOM.push({
                        child: '',
                        parent: '',
                        quantity: 1
                    });
                },

                removeBOMRow(index) {
                    if (this.tableBOM.length > 1) {
                        this.tableBOM.splice(index, 1);
                    }
                },

                async submitTableMESSA() {
                    try {
                        // Validate data
                        for (let item of this.tableItems) {
                            if (!item.name || item.avg_demand === '' || item.demand_std === '') {
                                throw new Error('品目データに未入力の必須項目があります');
                            }
                        }

                        for (let bom of this.tableBOM) {
                            if (!bom.child || !bom.parent) {
                                throw new Error('BOMデータに未入力の必須項目があります');
                            }
                        }

                        // Prepare data
                        const items_data = JSON.stringify(this.tableItems);
                        const bom_data = JSON.stringify(this.tableBOM);

                        // Call optimization API
                        const token = localStorage.getItem('token');
                        const headers = {
                            'Content-Type': 'application/json'
                        };
                        if (token && !this.skipAuth) {
                            headers['Authorization'] = `Bearer ${token}`;
                        }

                        const response = await fetch('/api/tools/optimize_safety_stock', {
                            method: 'POST',
                            headers: headers,
                            body: JSON.stringify({
                                items_data: items_data,
                                bom_data: bom_data
                            })
                        });

                        if (!response.ok) {
                            const errorData = await response.json();
                            throw new Error(errorData.detail || '最適化に失敗しました');
                        }

                        const result = await response.json();

                        // Display results
                        if (result.status === 'success') {
                            let resultMessage = `✅ 最適化が完了しました！\n\n総コスト: ${result.total_cost.toFixed(2)}円\n\n`;
                            resultMessage += '各拠点の最適在庫:\n';
                            result.optimization_results.forEach(node => {
                                resultMessage += `- ${node.node}: 安全在庫 ${node.safety_stock.toFixed(2)}, サービス時間 ${node.service_time.toFixed(2)}, リードタイム ${node.lead_time.toFixed(2)}\n`;
                            });
                            alert(resultMessage);
                            this.closeTableMESSAModal();
                        } else {
                            throw new Error(result.message || '最適化に失敗しました');
                        }

                    } catch (error) {
                        console.error('Table MESSA error:', error);
                        alert('❌ エラー: ' + error.message);
                    }
                },

                updateStageData() {
                    const currentStages = this.scForm.stages.length;
                    const targetStages = this.scForm.numStages;

                    if (targetStages > currentStages) {
                        // Add new stages
                        for (let i = currentStages; i < targetStages; i++) {
                            this.scForm.stages.push({
                                leadTime: 1,
                                reorderPoint: 100,
                                baseStockLevel: 200,
                                holdingCost: 1.0
                            });
                        }
                    } else if (targetStages < currentStages) {
                        // Remove excess stages
                        this.scForm.stages = this.scForm.stages.slice(0, targetStages);
                    }
                },

                submitSupplyChainForm() {
                    // Extract data from form
                    const form = this.scForm;

                    // Build network_data JSON structure
                    const stages = form.stages.map((stage, idx) => ({
                        name: `Stage${idx}`,
                        h: stage.holdingCost,
                        net_replenishment_time: stage.leadTime,
                        initial_s: stage.reorderPoint,
                        initial_S: stage.baseStockLevel
                    }));

                    // Build linear connections (Stage0 -> Stage1 -> Stage2 -> ...)
                    const connections = [];
                    for (let i = 0; i < form.numStages - 1; i++) {
                        connections.push({
                            child: `Stage${i}`,
                            parent: `Stage${i + 1}`
                        });
                    }

                    // Build the demand distribution
                    const demandDist = {
                        type: 'normal',
                        mean: form.meanDemand,
                        std: form.stdDemand
                    };

                    const networkData = {
                        stages: stages,
                        connections: connections,
                        demand_dist: demandDist
                    };

                    // Create a simplified message that the LLM can parse
                    const message = `${form.numStages}段階サプライチェーンの定期発注最適化をしてください。

network_dataのJSON:
\`\`\`json
${JSON.stringify(networkData, null, 2)}
\`\`\`

パラメータ:
- algorithm: "sgd"
- max_iter: 100
- n_samples: ${form.numSamples}
- n_periods: ${form.periods}
- backorder_cost: ${form.backorderCost}
- fixed_order_cost: ${form.fixedOrderCost}
- learning_rate: 0.1

optimize_periodic_inventory関数を使用してください。最適化完了後、結果を可視化してください。`;

                    // Set user input and submit
                    this.userInput = message;
                    this.closeSupplyChainForm();
                    this.sendMessage();
                },

                // Guided Form Methods
                openGuidedForm() {
                    this.guidedForm = {
                        step: 1,
                        selectedCategory: null,
                        selectedFunction: null,
                        parameters: {}
                    };
                    this.showGuidedModal = true;
                },

                closeGuidedForm() {
                    this.showGuidedModal = false;
                },

                selectCategory(category) {
                    this.guidedForm.selectedCategory = category;
                    this.guidedForm.step = 2;
                },

                selectFunction(func) {
                    this.guidedForm.selectedFunction = func;
                    this.guidedForm.step = 3;
                    this.$nextTick(() => {
                        this.renderDynamicForm(func.id);
                    });
                },

                renderDynamicForm(functionId) {
                    const template = this.functionTemplates[functionId];
                    if (!template) return;

                    const container = document.getElementById('dynamicFormFields');
                    container.innerHTML = '';

                    template.fields.forEach(field => {
                        const fieldDiv = document.createElement('div');
                        fieldDiv.className = 'form-group';

                        // Label
                        const label = document.createElement('label');
                        label.className = 'form-label';
                        label.textContent = field.label + (field.required ? ' *' : '');
                        fieldDiv.appendChild(label);

                        // Help text
                        if (field.help) {
                            const help = document.createElement('div');
                            help.className = 'text-xs text-gray-500 mb-1';
                            help.textContent = field.help;
                            fieldDiv.appendChild(help);
                        }

                        // Input field
                        let input;
                        if (field.type === 'info') {
                            // Info field - display a message with a button to open supply chain form
                            const infoBox = document.createElement('div');
                            infoBox.className = 'bg-yellow-50 border border-yellow-200 rounded-lg p-4';

                            const infoText = document.createElement('div');
                            infoText.className = 'text-sm text-yellow-800 mb-3';
                            infoText.textContent = field.default;
                            infoBox.appendChild(infoText);

                            const button = document.createElement('button');
                            button.type = 'button';
                            button.className = 'px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg text-sm font-medium transition-colors';
                            button.textContent = '🏭 サプライチェーン最適化を開く';
                            button.onclick = () => {
                                this.closeGuidedForm();
                                this.openSupplyChainForm();
                            };
                            infoBox.appendChild(button);

                            fieldDiv.appendChild(infoBox);
                            container.appendChild(fieldDiv);
                            return; // Skip normal input processing
                        } else if (field.type === 'select') {
                            input = document.createElement('select');
                            input.className = 'form-input';
                            field.options.forEach(opt => {
                                const option = document.createElement('option');
                                option.value = opt.value;
                                option.textContent = opt.label;
                                if (opt.value === field.default) option.selected = true;
                                input.appendChild(option);
                            });
                        } else if (field.type === 'array') {
                            input = document.createElement('textarea');
                            input.className = 'form-input';
                            input.rows = 3;
                            input.placeholder = '例: 100, 105, 98, 110, 102';
                            input.value = field.default || '';
                        } else {
                            input = document.createElement('input');
                            input.type = field.type;
                            input.className = 'form-input';
                            input.value = field.default || '';
                            if (field.min !== undefined) input.min = field.min;
                            if (field.max !== undefined) input.max = field.max;
                            // Respect field.step if defined, otherwise use 'any' for number inputs
                            if (field.type === 'number') input.step = field.step !== undefined ? field.step : 'any';
                        }

                        input.id = `field_${field.name}`;
                        input.required = field.required;
                        fieldDiv.appendChild(input);

                        container.appendChild(fieldDiv);

                        // Store default value
                        this.guidedForm.parameters[field.name] = field.default;
                    });
                },

                submitGuidedForm() {
                    const template = this.functionTemplates[this.guidedForm.selectedFunction.id];
                    if (!template) return;

                    // Collect form values
                    const params = {};
                    template.fields.forEach(field => {
                        const input = document.getElementById(`field_${field.name}`);
                        if (input) {
                            let value = input.value;
                            if (field.type === 'number') {
                                value = parseFloat(value);
                            } else if (field.type === 'array') {
                                // Parse comma-separated values or JSON array
                                try {
                                    value = JSON.parse('[' + value.replace(/[\[\]]/g, '') + ']');
                                } catch {
                                    value = value.split(',').map(v => parseFloat(v.trim())).filter(v => !isNaN(v));
                                }
                            }
                            params[field.name] = value;
                        }
                    });

                    // Build message for LLM
                    const message = this.buildMessageFromParams(this.guidedForm.selectedFunction.id, template, params);

                    // Submit to chat
                    this.userInput = message;
                    this.closeGuidedForm();
                    this.sendMessage();
                },

                buildMessageFromParams(functionId, template, params) {
                    // Map function IDs to MCP tool names
                    const toolMapping = {
                        'simulate_qr': 'simulate_qr_policy',
                        'simulate_ss': 'simulate_ss_policy',
                        'simulate_base_stock': 'simulate_base_stock_policy',
                        'base_stock_simulation_using_dist': 'base_stock_simulation_using_dist',
                        'optimize_qr': 'optimize_qr_policy',
                        'optimize_ss': 'optimize_ss_policy',
                        'optimize_periodic': 'optimize_periodic_inventory',
                        'optimize_safety_stock': 'optimize_safety_stock_allocation',
                        'calculate_safety_stock': 'calculate_safety_stock',
                        'forecast_demand': 'forecast_demand',
                        'analyze_demand': 'analyze_demand_pattern',
                        'find_best_distribution': 'find_best_distribution',
                        'fit_histogram': 'fit_histogram_distribution',
                        'calculate_eoq_incremental': 'calculate_eoq_incremental_discount_raw',
                        'calculate_eoq_all_units': 'calculate_eoq_all_units_discount_raw',
                        'calculate_wagner_whitin': 'calculate_wagner_whitin'
                    };

                    const toolName = toolMapping[functionId] || functionId;

                    // Special handling for optimize_safety_stock - use generate_sample_data workflow
                    if (functionId === 'optimize_safety_stock') {
                        const complexity = params.complexity || 'standard';
                        const message = `安全在庫配置の最適化を実行します。

ステップ1: まず、generate_sample_data関数を実行してサンプルデータを生成してください。
complexity: "${complexity}"

ステップ2: generate_sample_dataから返されたitems_dataとbom_dataを使って、optimize_safety_stock_allocation関数を実行してください。

ステップ3: 最適化結果を日本語で分かりやすく説明してください。各ノードの最適安全在庫、サービス時間、リードタイムを報告してください。`;

                        return message;
                    }

                    // Special handling for base_stock_simulation_using_dist
                    if (functionId === 'base_stock_simulation_using_dist') {
                        // Build the demand_dist object from separate fields
                        const demandDist = {
                            type: params.dist_type || 'normal',
                            params: {
                                mu: params.dist_mu,
                                sigma: params.dist_sigma
                            }
                        };

                        // Remove the individual distribution fields and add the constructed object
                        const modifiedParams = { ...params };
                        delete modifiedParams.dist_type;
                        delete modifiedParams.dist_mu;
                        delete modifiedParams.dist_sigma;
                        modifiedParams.demand_dist = demandDist;
                        params = modifiedParams;
                    }

                    let message = `${template.name}を実行してください。${toolName}関数を使用してください。\n\n`;

                    // Add parameters in both readable format and JSON format for better LLM parsing
                    message += `パラメータ:\n`;
                    Object.entries(params).forEach(([key, value]) => {
                        const field = template.fields.find(f => f.name === key);
                        if (field || key === 'demand_dist') {
                            if (Array.isArray(value)) {
                                message += `- ${key}: [${value.join(', ')}]\n`;
                            } else if (typeof value === 'object' && value !== null) {
                                message += `- ${key}: ${JSON.stringify(value)}\n`;
                            } else if (typeof value === 'number') {
                                message += `- ${key}: ${value}\n`;
                            } else {
                                message += `- ${key}: "${value}"\n`;
                            }
                        }
                    });

                    // Add JSON format for more reliable parsing
                    message += `\nJSON形式:\n\`\`\`json\n${JSON.stringify(params, null, 2)}\n\`\`\`\n`;

                    // Add result request
                    message += `\n重要: 上記のパラメータをすべて含めて${toolName}関数を呼び出してください。実行後、結果を日本語で分かりやすく説明してください。`;

                    return message;
                },

                // Quick Form Methods
                openQuickForm(type) {
                    // Map quick form types to function IDs
                    const mapping = {
                        'eoq': 'calculate_eoq_incremental',
                        'demand_forecast': 'forecast_demand',
                        'safety_stock': 'calculate_safety_stock'
                    };

                    const functionId = mapping[type];
                    if (!functionId) return;

                    // Find the category and function
                    for (const category of this.functionCategories) {
                        const func = category.functions.find(f => f.id === functionId);
                        if (func) {
                            this.guidedForm = {
                                step: 3,
                                selectedCategory: category,
                                selectedFunction: func,
                                parameters: {}
                            };
                            this.showGuidedModal = true;
                            this.$nextTick(() => {
                                this.renderDynamicForm(functionId);
                            });
                            return;
                        }
                    }
                },

                // Auto-Detection Methods
                async detectToolAndExtractParams(userMessage) {
                    this.isLoading = true;
                    this.pendingUserMessage = userMessage;

                    try {
                        const token = localStorage.getItem('token');

                        // Step 1: Detect tool
                        const detectResponse = await fetch('/api/detect_tool', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${token}`
                            },
                            body: JSON.stringify({ user_text: userMessage })
                        });

                        if (!detectResponse.ok) {
                            throw new Error('Tool detection failed');
                        }

                        const detectResult = await detectResponse.json();

                        // Extract the recommended tool from the detected_tools array
                        const recommendedToolName = detectResult.recommended_tool;
                        const recommendedTool = detectResult.detected_tools.find(
                            tool => tool.tool_name === recommendedToolName
                        );

                        this.detectedTool = recommendedTool || detectResult.detected_tools[0];

                        // Step 2: Extract parameters with detected tool
                        const extractResponse = await fetch('/api/extract_parameters', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${token}`
                            },
                            body: JSON.stringify({
                                user_text: userMessage,
                                tool_name: this.detectedTool.tool_name
                            })
                        });

                        if (!extractResponse.ok) {
                            throw new Error('Parameter extraction failed');
                        }

                        const extractResult = await extractResponse.json();

                        // Backend returns either 'success: true' or 'status: success'
                        if (extractResult.success || extractResult.status === 'success') {
                            this.extractedParameters = extractResult.parameters || extractResult.extracted_params;
                            this.extractionError = null;
                        } else {
                            this.extractionError = extractResult.message || 'パラメータの抽出に失敗しました';
                            this.extractedParameters = null;
                        }

                        // Show the confirmation modal
                        this.showParameterConfirmModal = true;

                    } catch (error) {
                        console.error('Error in auto-detection:', error);
                        this.extractionError = `エラーが発生しました: ${error.message}`;
                        this.detectedTool = null;
                        this.extractedParameters = null;
                        this.showParameterConfirmModal = true;
                    } finally {
                        this.isLoading = false;
                    }
                },

                closeParameterConfirmModal() {
                    this.showParameterConfirmModal = false;
                    this.detectedTool = null;
                    this.extractedParameters = null;
                    this.extractionError = null;
                    this.pendingUserMessage = '';
                },

                async confirmAndExecute() {
                    // Close the modal
                    this.showParameterConfirmModal = false;

                    // Build the message with confirmed parameters
                    const toolName = this.detectedTool?.tool_name;
                    const params = this.extractedParameters;
                    const originalMessage = this.pendingUserMessage;

                    // Create a structured message that includes both the original request and extracted parameters
                    let message = `${originalMessage}\n\n--- 自動検出されたパラメータ ---\n`;
                    message += `ツール: ${toolName}\n`;
                    message += `パラメータ:\n`;

                    // Format parameters
                    Object.entries(params).forEach(([key, value]) => {
                        if (Array.isArray(value)) {
                            message += `- ${key}: [${value.join(', ')}]\n`;
                        } else if (typeof value === 'object' && value !== null) {
                            message += `- ${key}: ${JSON.stringify(value)}\n`;
                        } else {
                            message += `- ${key}: ${value}\n`;
                        }
                    });

                    message += `\nJSON形式:\n\`\`\`json\n${JSON.stringify(params, null, 2)}\n\`\`\`\n`;
                    message += `\n重要: ${toolName}関数を上記のパラメータで呼び出してください。`;

                    // Clear the modal state
                    this.detectedTool = null;
                    this.extractedParameters = null;
                    this.extractionError = null;
                    this.pendingUserMessage = '';

                    // Add user message and execute
                    this.messages.push({
                        role: 'user',
                        content: message
                    });

                    this.isLoading = true;
                    this.scrollToBottom();

                    try {
                        const token = localStorage.getItem('token');

                        const response = await fetch('/api/chat', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${token}`
                            },
                            body: JSON.stringify({
                                messages: this.messages,
                                model: this.modelName
                            })
                        });

                        if (!response.ok) {
                            throw new Error('API request failed');
                        }

                        const reader = response.body.getReader();
                        const decoder = new TextDecoder();
                        let assistantMessage = '';

                        // Add assistant message placeholder
                        this.messages.push({
                            role: 'assistant',
                            content: ''
                        });

                        while (true) {
                            const { done, value } = await reader.read();
                            if (done) break;

                            const chunk = decoder.decode(value);
                            const lines = chunk.split('\n');

                            for (const line of lines) {
                                if (line.startsWith('data: ')) {
                                    const data = line.slice(6);
                                    if (data === '[DONE]') break;

                                    try {
                                        const parsed = JSON.parse(data);
                                        if (parsed.content) {
                                            assistantMessage += parsed.content;
                                            this.messages[this.messages.length - 1].content = assistantMessage;
                                            this.scrollToBottom();
                                        } else if (parsed.function_call) {
                                            // Function call結果を表示
                                            const funcName = parsed.function_call.name;
                                            const funcResult = parsed.function_call.result;

                                            let funcDisplay = `\n\n🔧 **${funcName}を実行しました**\n\n`;

                                            // Check if result contains visualization URL or ID
                                            if (funcResult.visualization_url) {
                                                const vizUrl = funcResult.visualization_url;
                                                const message = funcResult.message || '可視化結果を表示';
                                                funcDisplay += `📊 ${message}\n🔗 [可視化を開く](${vizUrl})\n\n`;
                                            } else if (funcResult.visualization_id) {
                                                const vizId = funcResult.visualization_id;
                                                const vizUrl = `/api/visualization/${vizId}`;
                                                const message = funcResult.message || '可視化結果を表示';
                                                funcDisplay += `📊 ${message}\n🔗 [可視化を開く](${vizUrl})\n\n`;
                                            }

                                            // Display key results if available
                                            if (funcResult.status === 'success') {
                                                funcDisplay += `✅ **ステータス**: 成功\n\n`;

                                                // Display important metrics
                                                if (funcResult.message) {
                                                    funcDisplay += `📝 **結果**: ${funcResult.message}\n\n`;
                                                }

                                                // Extract key metrics to display
                                                const keyMetrics = [];

                                                // EOQ results
                                                if (funcResult.optimal_order_quantity !== undefined) keyMetrics.push(`📦 **最適発注量**: ${funcResult.optimal_order_quantity.toFixed(2)} units`);
                                                if (funcResult.total_cost !== undefined) keyMetrics.push(`💰 **総コスト**: ${funcResult.total_cost.toFixed(2)} 円/年`);
                                                if (funcResult.ordering_cost !== undefined) keyMetrics.push(`📝 発注コスト: ${funcResult.ordering_cost.toFixed(2)} 円/年`);
                                                if (funcResult.holding_cost !== undefined) keyMetrics.push(`📦 在庫保管コスト: ${funcResult.holding_cost.toFixed(2)} 円/年`);
                                                if (funcResult.purchase_cost !== undefined) keyMetrics.push(`💵 購入コスト: ${funcResult.purchase_cost.toFixed(2)} 円/年`);

                                                // Optimization results
                                                if (funcResult.best_cost !== undefined) keyMetrics.push(`💰 **総コスト**: ${funcResult.best_cost.toFixed(2)}`);
                                                if (funcResult.average_cost !== undefined) keyMetrics.push(`📊 平均コスト: ${funcResult.average_cost.toFixed(2)}`);
                                                if (funcResult.optimal_Q !== undefined) keyMetrics.push(`📦 **最適発注量**: ${funcResult.optimal_Q.toFixed(2)}`);
                                                if (funcResult.iterations !== undefined) keyMetrics.push(`🔄 反復回数: ${funcResult.iterations}`);

                                                // Forecast results
                                                if (funcResult.forecast && Array.isArray(funcResult.forecast)) {
                                                    const forecastSummary = funcResult.forecast.slice(0, 3).map(v => v.toFixed(1)).join(', ');
                                                    keyMetrics.push(`📈 予測値: [${forecastSummary}, ...]`);
                                                }

                                                // Distribution fitting results
                                                if (funcResult.best_distribution) {
                                                    keyMetrics.push(`📊 **最適分布**: ${funcResult.best_distribution}`);
                                                }

                                                if (keyMetrics.length > 0) {
                                                    funcDisplay += `**主な結果**:\n${keyMetrics.map(m => `${m}`).join('\n')}\n\n`;
                                                }
                                            } else if (funcResult.status === 'error') {
                                                funcDisplay += `❌ **エラー**: ${funcResult.message}\n\n`;
                                            }

                                            // Add collapsible detailed JSON
                                            const detailsId = `json-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                                            funcDisplay += `<details class="json-collapsible" id="${detailsId}">
                                                <summary class="json-collapsible-header">
                                                    <span>📋 詳細な結果を表示</span>
                                                    <span class="json-toggle-icon">▼</span>
                                                </summary>
                                                <div class="json-collapsible-content">
\`\`\`json
${JSON.stringify(funcResult, null, 2)}
\`\`\`
                                                </div>
                                            </details>\n\n`;

                                            assistantMessage += funcDisplay;
                                            this.messages[this.messages.length - 1].content = assistantMessage;
                                            this.scrollToBottom();
                                        } else if (parsed.error) {
                                            this.messages[this.messages.length - 1].content = `エラー: ${parsed.error}`;
                                        }
                                    } catch (e) {
                                        // Ignore parse errors
                                    }
                                }
                            }
                        }

                        // Save to localStorage
                        localStorage.setItem('chatMessages', JSON.stringify(this.messages));

                    } catch (error) {
                        console.error('Error:', error);
                        this.messages.push({
                            role: 'assistant',
                            content: 'エラーが発生しました。もう一度お試しください。'
                        });
                    } finally {
                        this.isLoading = false;
                        this.scrollToBottom();
                    }
                },

                formatParamValue(value) {
                    if (Array.isArray(value)) {
                        return `[${value.join(', ')}]`;
                    } else if (typeof value === 'object' && value !== null) {
                        return JSON.stringify(value, null, 2);
                    } else if (typeof value === 'number') {
                        return value.toFixed(2);
                    } else {
                        return String(value);
                    }
                }
            }
        }
    </script>
</body>
</html>
